/**
 * Generated by orval v7.18.0 ðŸº
 * Do not edit manually.
 * CipherBox API
 * Zero-knowledge encrypted cloud storage API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CreateApprovalDto,
  DeviceApprovalControllerCreateRequest201,
  DeviceApprovalControllerGetPending200Item,
  DeviceApprovalControllerGetStatus200,
  RespondApprovalDto,
} from '../models';

import { customInstance } from '../custom-instance';

/**
 * New device creates an approval request with an ephemeral public key for ECIES key exchange. Request expires after 5 minutes.
 * @summary Create device approval request
 */
export const deviceApprovalControllerCreateRequest = (
  createApprovalDto: CreateApprovalDto,
  signal?: AbortSignal
) => {
  return customInstance<DeviceApprovalControllerCreateRequest201>({
    url: `/device-approval/request`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createApprovalDto,
    signal,
  });
};

export const getDeviceApprovalControllerCreateRequestMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceApprovalControllerCreateRequest>>,
    TError,
    { data: CreateApprovalDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deviceApprovalControllerCreateRequest>>,
  TError,
  { data: CreateApprovalDto },
  TContext
> => {
  const mutationKey = ['deviceApprovalControllerCreateRequest'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceApprovalControllerCreateRequest>>,
    { data: CreateApprovalDto }
  > = (props) => {
    const { data } = props ?? {};

    return deviceApprovalControllerCreateRequest(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeviceApprovalControllerCreateRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof deviceApprovalControllerCreateRequest>>
>;
export type DeviceApprovalControllerCreateRequestMutationBody = CreateApprovalDto;
export type DeviceApprovalControllerCreateRequestMutationError = void;

/**
 * @summary Create device approval request
 */
export const useDeviceApprovalControllerCreateRequest = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deviceApprovalControllerCreateRequest>>,
      TError,
      { data: CreateApprovalDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deviceApprovalControllerCreateRequest>>,
  TError,
  { data: CreateApprovalDto },
  TContext
> => {
  const mutationOptions = getDeviceApprovalControllerCreateRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * New device polls this endpoint to check if the request has been approved, denied, or expired. Returns the encrypted factor key on approval.
 * @summary Poll approval request status
 */
export const deviceApprovalControllerGetStatus = (requestId: string, signal?: AbortSignal) => {
  return customInstance<DeviceApprovalControllerGetStatus200>({
    url: `/device-approval/${requestId}/status`,
    method: 'GET',
    signal,
  });
};

export const getDeviceApprovalControllerGetStatusQueryKey = (requestId?: string) => {
  return [`/device-approval/${requestId}/status`] as const;
};

export const getDeviceApprovalControllerGetStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
  TError = void,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDeviceApprovalControllerGetStatusQueryKey(requestId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>> = ({
    signal,
  }) => deviceApprovalControllerGetStatus(requestId, signal);

  return { queryKey, queryFn, enabled: !!requestId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DeviceApprovalControllerGetStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>
>;
export type DeviceApprovalControllerGetStatusQueryError = void;

export function useDeviceApprovalControllerGetStatus<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
  TError = void,
>(
  requestId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
          TError,
          Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDeviceApprovalControllerGetStatus<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
  TError = void,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
          TError,
          Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDeviceApprovalControllerGetStatus<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
  TError = void,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Poll approval request status
 */

export function useDeviceApprovalControllerGetStatus<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>,
  TError = void,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetStatus>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDeviceApprovalControllerGetStatusQueryOptions(requestId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Existing device fetches all non-expired pending approval requests for the authenticated user.
 * @summary List pending approval requests
 */
export const deviceApprovalControllerGetPending = (signal?: AbortSignal) => {
  return customInstance<DeviceApprovalControllerGetPending200Item[]>({
    url: `/device-approval/pending`,
    method: 'GET',
    signal,
  });
};

export const getDeviceApprovalControllerGetPendingQueryKey = () => {
  return [`/device-approval/pending`] as const;
};

export const getDeviceApprovalControllerGetPendingQueryOptions = <
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDeviceApprovalControllerGetPendingQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>> = ({
    signal,
  }) => deviceApprovalControllerGetPending(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DeviceApprovalControllerGetPendingQueryResult = NonNullable<
  Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>
>;
export type DeviceApprovalControllerGetPendingQueryError = void;

export function useDeviceApprovalControllerGetPending<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
          TError,
          Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDeviceApprovalControllerGetPending<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
          TError,
          Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDeviceApprovalControllerGetPending<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List pending approval requests
 */

export function useDeviceApprovalControllerGetPending<
  TData = Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof deviceApprovalControllerGetPending>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDeviceApprovalControllerGetPendingQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Existing device approves or denies an approval request. On approve, includes the ECIES-encrypted factor key.
 * @summary Respond to approval request
 */
export const deviceApprovalControllerRespond = (
  requestId: string,
  respondApprovalDto: RespondApprovalDto,
  signal?: AbortSignal
) => {
  return customInstance<void>({
    url: `/device-approval/${requestId}/respond`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: respondApprovalDto,
    signal,
  });
};

export const getDeviceApprovalControllerRespondMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceApprovalControllerRespond>>,
    TError,
    { requestId: string; data: RespondApprovalDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deviceApprovalControllerRespond>>,
  TError,
  { requestId: string; data: RespondApprovalDto },
  TContext
> => {
  const mutationKey = ['deviceApprovalControllerRespond'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceApprovalControllerRespond>>,
    { requestId: string; data: RespondApprovalDto }
  > = (props) => {
    const { requestId, data } = props ?? {};

    return deviceApprovalControllerRespond(requestId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeviceApprovalControllerRespondMutationResult = NonNullable<
  Awaited<ReturnType<typeof deviceApprovalControllerRespond>>
>;
export type DeviceApprovalControllerRespondMutationBody = RespondApprovalDto;
export type DeviceApprovalControllerRespondMutationError = void;

/**
 * @summary Respond to approval request
 */
export const useDeviceApprovalControllerRespond = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deviceApprovalControllerRespond>>,
      TError,
      { requestId: string; data: RespondApprovalDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deviceApprovalControllerRespond>>,
  TError,
  { requestId: string; data: RespondApprovalDto },
  TContext
> => {
  const mutationOptions = getDeviceApprovalControllerRespondMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * New device cancels its own pending approval request (cleanup on navigation away or recovery phrase used).
 * @summary Cancel approval request
 */
export const deviceApprovalControllerCancel = (requestId: string) => {
  return customInstance<void>({ url: `/device-approval/${requestId}`, method: 'DELETE' });
};

export const getDeviceApprovalControllerCancelMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceApprovalControllerCancel>>,
    TError,
    { requestId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deviceApprovalControllerCancel>>,
  TError,
  { requestId: string },
  TContext
> => {
  const mutationKey = ['deviceApprovalControllerCancel'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceApprovalControllerCancel>>,
    { requestId: string }
  > = (props) => {
    const { requestId } = props ?? {};

    return deviceApprovalControllerCancel(requestId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeviceApprovalControllerCancelMutationResult = NonNullable<
  Awaited<ReturnType<typeof deviceApprovalControllerCancel>>
>;

export type DeviceApprovalControllerCancelMutationError = void;

/**
 * @summary Cancel approval request
 */
export const useDeviceApprovalControllerCancel = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deviceApprovalControllerCancel>>,
      TError,
      { requestId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deviceApprovalControllerCancel>>,
  TError,
  { requestId: string },
  TContext
> => {
  const mutationOptions = getDeviceApprovalControllerCancelMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
