/**
 * Generated by orval v7.18.0 ðŸº
 * Do not edit manually.
 * CipherBox API
 * Zero-knowledge encrypted cloud storage API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AddShareKeysDto,
  CreateShareDto,
  CreateShareResponseDto,
  PendingRotationResponseDto,
  ReceivedShareResponseDto,
  SentShareResponseDto,
  ShareKeyResponseDto,
  SharesControllerLookupUserParams,
  UpdateEncryptedKeyDto,
} from '../models';

import { customInstance } from '../custom-instance';

/**
 * Share an encrypted folder or file with another user. The encryptedKey is the item key re-wrapped for the recipient via ECIES.
 * @summary Create a share
 */
export const sharesControllerCreateShare = (
  createShareDto: CreateShareDto,
  signal?: AbortSignal
) => {
  return customInstance<CreateShareResponseDto>({
    url: `/shares`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createShareDto,
    signal,
  });
};

export const getSharesControllerCreateShareMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sharesControllerCreateShare>>,
    TError,
    { data: CreateShareDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sharesControllerCreateShare>>,
  TError,
  { data: CreateShareDto },
  TContext
> => {
  const mutationKey = ['sharesControllerCreateShare'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sharesControllerCreateShare>>,
    { data: CreateShareDto }
  > = (props) => {
    const { data } = props ?? {};

    return sharesControllerCreateShare(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SharesControllerCreateShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerCreateShare>>
>;
export type SharesControllerCreateShareMutationBody = CreateShareDto;
export type SharesControllerCreateShareMutationError = void;

/**
 * @summary Create a share
 */
export const useSharesControllerCreateShare = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sharesControllerCreateShare>>,
      TError,
      { data: CreateShareDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sharesControllerCreateShare>>,
  TError,
  { data: CreateShareDto },
  TContext
> => {
  const mutationOptions = getSharesControllerCreateShareMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get all active, non-hidden shares received by the authenticated user.
 * @summary List received shares
 */
export const sharesControllerGetReceivedShares = (signal?: AbortSignal) => {
  return customInstance<ReceivedShareResponseDto[]>({
    url: `/shares/received`,
    method: 'GET',
    signal,
  });
};

export const getSharesControllerGetReceivedSharesQueryKey = () => {
  return [`/shares/received`] as const;
};

export const getSharesControllerGetReceivedSharesQueryOptions = <
  TData = Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSharesControllerGetReceivedSharesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>> = ({
    signal,
  }) => sharesControllerGetReceivedShares(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SharesControllerGetReceivedSharesQueryResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>
>;
export type SharesControllerGetReceivedSharesQueryError = void;

export function useSharesControllerGetReceivedShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetReceivedShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetReceivedShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List received shares
 */

export function useSharesControllerGetReceivedShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetReceivedShares>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSharesControllerGetReceivedSharesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all active shares created by the authenticated user.
 * @summary List sent shares
 */
export const sharesControllerGetSentShares = (signal?: AbortSignal) => {
  return customInstance<SentShareResponseDto[]>({ url: `/shares/sent`, method: 'GET', signal });
};

export const getSharesControllerGetSentSharesQueryKey = () => {
  return [`/shares/sent`] as const;
};

export const getSharesControllerGetSentSharesQueryOptions = <
  TData = Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetSentShares>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSharesControllerGetSentSharesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sharesControllerGetSentShares>>> = ({
    signal,
  }) => sharesControllerGetSentShares(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SharesControllerGetSentSharesQueryResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerGetSentShares>>
>;
export type SharesControllerGetSentSharesQueryError = void;

export function useSharesControllerGetSentShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetSentShares>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetSentShares>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetSentShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetSentShares>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetSentShares>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetSentShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetSentShares>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List sent shares
 */

export function useSharesControllerGetSentShares<
  TData = Awaited<ReturnType<typeof sharesControllerGetSentShares>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetSentShares>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSharesControllerGetSentSharesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Verify a public key belongs to a registered CipherBox user.
 * @summary Look up user by public key
 */
export const sharesControllerLookupUser = (
  params: SharesControllerLookupUserParams,
  signal?: AbortSignal
) => {
  return customInstance<void>({ url: `/shares/lookup`, method: 'GET', params, signal });
};

export const getSharesControllerLookupUserQueryKey = (
  params?: SharesControllerLookupUserParams
) => {
  return [`/shares/lookup`, ...(params ? [params] : [])] as const;
};

export const getSharesControllerLookupUserQueryOptions = <
  TData = Awaited<ReturnType<typeof sharesControllerLookupUser>>,
  TError = void,
>(
  params: SharesControllerLookupUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerLookupUser>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSharesControllerLookupUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sharesControllerLookupUser>>> = ({
    signal,
  }) => sharesControllerLookupUser(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sharesControllerLookupUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SharesControllerLookupUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerLookupUser>>
>;
export type SharesControllerLookupUserQueryError = void;

export function useSharesControllerLookupUser<
  TData = Awaited<ReturnType<typeof sharesControllerLookupUser>>,
  TError = void,
>(
  params: SharesControllerLookupUserParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerLookupUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerLookupUser>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerLookupUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerLookupUser<
  TData = Awaited<ReturnType<typeof sharesControllerLookupUser>>,
  TError = void,
>(
  params: SharesControllerLookupUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerLookupUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerLookupUser>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerLookupUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerLookupUser<
  TData = Awaited<ReturnType<typeof sharesControllerLookupUser>>,
  TError = void,
>(
  params: SharesControllerLookupUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerLookupUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Look up user by public key
 */

export function useSharesControllerLookupUser<
  TData = Awaited<ReturnType<typeof sharesControllerLookupUser>>,
  TError = void,
>(
  params: SharesControllerLookupUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerLookupUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSharesControllerLookupUserQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get shares that have been revoked but not yet key-rotated. Used by the client to detect lazy rotation needs before folder modification.
 * @summary Get pending rotations
 */
export const sharesControllerGetPendingRotations = (signal?: AbortSignal) => {
  return customInstance<PendingRotationResponseDto[]>({
    url: `/shares/pending-rotations`,
    method: 'GET',
    signal,
  });
};

export const getSharesControllerGetPendingRotationsQueryKey = () => {
  return [`/shares/pending-rotations`] as const;
};

export const getSharesControllerGetPendingRotationsQueryOptions = <
  TData = Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSharesControllerGetPendingRotationsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>> = ({
    signal,
  }) => sharesControllerGetPendingRotations(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SharesControllerGetPendingRotationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>
>;
export type SharesControllerGetPendingRotationsQueryError = void;

export function useSharesControllerGetPendingRotations<
  TData = Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetPendingRotations<
  TData = Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetPendingRotations<
  TData = Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get pending rotations
 */

export function useSharesControllerGetPendingRotations<
  TData = Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sharesControllerGetPendingRotations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSharesControllerGetPendingRotationsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all re-wrapped child keys for a share. Accessible by sharer or recipient.
 * @summary Get share keys
 */
export const sharesControllerGetShareKeys = (shareId: string, signal?: AbortSignal) => {
  return customInstance<ShareKeyResponseDto[]>({
    url: `/shares/${shareId}/keys`,
    method: 'GET',
    signal,
  });
};

export const getSharesControllerGetShareKeysQueryKey = (shareId?: string) => {
  return [`/shares/${shareId}/keys`] as const;
};

export const getSharesControllerGetShareKeysQueryOptions = <
  TData = Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
  TError = void,
>(
  shareId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShareKeys>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSharesControllerGetShareKeysQueryKey(shareId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sharesControllerGetShareKeys>>> = ({
    signal,
  }) => sharesControllerGetShareKeys(shareId, signal);

  return { queryKey, queryFn, enabled: !!shareId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SharesControllerGetShareKeysQueryResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerGetShareKeys>>
>;
export type SharesControllerGetShareKeysQueryError = void;

export function useSharesControllerGetShareKeys<
  TData = Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
  TError = void,
>(
  shareId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShareKeys>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetShareKeys>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetShareKeys<
  TData = Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
  TError = void,
>(
  shareId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShareKeys>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetShareKeys>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSharesControllerGetShareKeys<
  TData = Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
  TError = void,
>(
  shareId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShareKeys>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get share keys
 */

export function useSharesControllerGetShareKeys<
  TData = Awaited<ReturnType<typeof sharesControllerGetShareKeys>>,
  TError = void,
>(
  shareId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShareKeys>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSharesControllerGetShareKeysQueryOptions(shareId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Add re-wrapped child keys to an existing share. Only the sharer can add keys.
 * @summary Add share keys
 */
export const sharesControllerAddShareKeys = (
  shareId: string,
  addShareKeysDto: AddShareKeysDto,
  signal?: AbortSignal
) => {
  return customInstance<void>({
    url: `/shares/${shareId}/keys`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: addShareKeysDto,
    signal,
  });
};

export const getSharesControllerAddShareKeysMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sharesControllerAddShareKeys>>,
    TError,
    { shareId: string; data: AddShareKeysDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sharesControllerAddShareKeys>>,
  TError,
  { shareId: string; data: AddShareKeysDto },
  TContext
> => {
  const mutationKey = ['sharesControllerAddShareKeys'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sharesControllerAddShareKeys>>,
    { shareId: string; data: AddShareKeysDto }
  > = (props) => {
    const { shareId, data } = props ?? {};

    return sharesControllerAddShareKeys(shareId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SharesControllerAddShareKeysMutationResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerAddShareKeys>>
>;
export type SharesControllerAddShareKeysMutationBody = AddShareKeysDto;
export type SharesControllerAddShareKeysMutationError = void;

/**
 * @summary Add share keys
 */
export const useSharesControllerAddShareKeys = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sharesControllerAddShareKeys>>,
      TError,
      { shareId: string; data: AddShareKeysDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sharesControllerAddShareKeys>>,
  TError,
  { shareId: string; data: AddShareKeysDto },
  TContext
> => {
  const mutationOptions = getSharesControllerAddShareKeysMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Soft-delete a share by setting revokedAt. Only the sharer can revoke. Keys are kept for lazy rotation.
 * @summary Revoke a share
 */
export const sharesControllerRevokeShare = (shareId: string) => {
  return customInstance<void>({ url: `/shares/${shareId}`, method: 'DELETE' });
};

export const getSharesControllerRevokeShareMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sharesControllerRevokeShare>>,
    TError,
    { shareId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sharesControllerRevokeShare>>,
  TError,
  { shareId: string },
  TContext
> => {
  const mutationKey = ['sharesControllerRevokeShare'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sharesControllerRevokeShare>>,
    { shareId: string }
  > = (props) => {
    const { shareId } = props ?? {};

    return sharesControllerRevokeShare(shareId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SharesControllerRevokeShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerRevokeShare>>
>;

export type SharesControllerRevokeShareMutationError = void;

/**
 * @summary Revoke a share
 */
export const useSharesControllerRevokeShare = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sharesControllerRevokeShare>>,
      TError,
      { shareId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sharesControllerRevokeShare>>,
  TError,
  { shareId: string },
  TContext
> => {
  const mutationOptions = getSharesControllerRevokeShareMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Mark a share as hidden by the recipient. Only the recipient can hide.
 * @summary Hide a share
 */
export const sharesControllerHideShare = (shareId: string) => {
  return customInstance<void>({ url: `/shares/${shareId}/hide`, method: 'PATCH' });
};

export const getSharesControllerHideShareMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sharesControllerHideShare>>,
    TError,
    { shareId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sharesControllerHideShare>>,
  TError,
  { shareId: string },
  TContext
> => {
  const mutationKey = ['sharesControllerHideShare'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sharesControllerHideShare>>,
    { shareId: string }
  > = (props) => {
    const { shareId } = props ?? {};

    return sharesControllerHideShare(shareId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SharesControllerHideShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerHideShare>>
>;

export type SharesControllerHideShareMutationError = void;

/**
 * @summary Hide a share
 */
export const useSharesControllerHideShare = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sharesControllerHideShare>>,
      TError,
      { shareId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sharesControllerHideShare>>,
  TError,
  { shareId: string },
  TContext
> => {
  const mutationOptions = getSharesControllerHideShareMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update the encrypted key on an existing share after lazy key rotation. Only the sharer can update the key.
 * @summary Update share encrypted key
 */
export const sharesControllerUpdateShareEncryptedKey = (
  shareId: string,
  updateEncryptedKeyDto: UpdateEncryptedKeyDto
) => {
  return customInstance<void>({
    url: `/shares/${shareId}/encrypted-key`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateEncryptedKeyDto,
  });
};

export const getSharesControllerUpdateShareEncryptedKeyMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sharesControllerUpdateShareEncryptedKey>>,
    TError,
    { shareId: string; data: UpdateEncryptedKeyDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sharesControllerUpdateShareEncryptedKey>>,
  TError,
  { shareId: string; data: UpdateEncryptedKeyDto },
  TContext
> => {
  const mutationKey = ['sharesControllerUpdateShareEncryptedKey'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sharesControllerUpdateShareEncryptedKey>>,
    { shareId: string; data: UpdateEncryptedKeyDto }
  > = (props) => {
    const { shareId, data } = props ?? {};

    return sharesControllerUpdateShareEncryptedKey(shareId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SharesControllerUpdateShareEncryptedKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerUpdateShareEncryptedKey>>
>;
export type SharesControllerUpdateShareEncryptedKeyMutationBody = UpdateEncryptedKeyDto;
export type SharesControllerUpdateShareEncryptedKeyMutationError = void;

/**
 * @summary Update share encrypted key
 */
export const useSharesControllerUpdateShareEncryptedKey = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sharesControllerUpdateShareEncryptedKey>>,
      TError,
      { shareId: string; data: UpdateEncryptedKeyDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sharesControllerUpdateShareEncryptedKey>>,
  TError,
  { shareId: string; data: UpdateEncryptedKeyDto },
  TContext
> => {
  const mutationOptions = getSharesControllerUpdateShareEncryptedKeyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Hard-delete a revoked share after the sharer has rotated the folder key. Called after the client performs lazy key rotation.
 * @summary Complete key rotation
 */
export const sharesControllerCompleteRotation = (shareId: string) => {
  return customInstance<void>({ url: `/shares/${shareId}/complete-rotation`, method: 'DELETE' });
};

export const getSharesControllerCompleteRotationMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sharesControllerCompleteRotation>>,
    TError,
    { shareId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sharesControllerCompleteRotation>>,
  TError,
  { shareId: string },
  TContext
> => {
  const mutationKey = ['sharesControllerCompleteRotation'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sharesControllerCompleteRotation>>,
    { shareId: string }
  > = (props) => {
    const { shareId } = props ?? {};

    return sharesControllerCompleteRotation(shareId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SharesControllerCompleteRotationMutationResult = NonNullable<
  Awaited<ReturnType<typeof sharesControllerCompleteRotation>>
>;

export type SharesControllerCompleteRotationMutationError = void;

/**
 * @summary Complete key rotation
 */
export const useSharesControllerCompleteRotation = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sharesControllerCompleteRotation>>,
      TError,
      { shareId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sharesControllerCompleteRotation>>,
  TError,
  { shareId: string },
  TContext
> => {
  const mutationOptions = getSharesControllerCompleteRotationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
