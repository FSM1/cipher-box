<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CipherBox Vault Recovery</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #0a0a0a;
      color: #d4d4d4;
      font-family: 'Courier New', Courier, monospace;
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      max-width: 700px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    header {
      border-bottom: 1px solid #333;
      padding-bottom: 1.5rem;
      margin-bottom: 2rem;
    }

    header h1 {
      color: #22c55e;
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    header .subtitle {
      color: #888;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .security-note {
      background: #1a1a2e;
      border: 1px solid #333;
      border-left: 3px solid #22c55e;
      padding: 0.75rem 1rem;
      margin-bottom: 2rem;
      font-size: 0.8rem;
      color: #aaa;
    }

    /* Step indicators */
    .steps-indicator {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
    }

    .step-dot {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      color: #555;
    }

    .step-dot.active { color: #22c55e; }
    .step-dot.complete { color: #22c55e; }
    .step-dot.pending { color: #555; }

    .step-dot .num {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid currentColor;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
    }

    .step-dot.complete .num {
      background: #22c55e;
      color: #0a0a0a;
      border-color: #22c55e;
    }

    .step-dot.active .num {
      border-color: #22c55e;
      color: #22c55e;
    }

    .step-dot .sep {
      color: #333;
      margin: 0 0.15rem;
    }

    /* Step sections */
    .step { display: none; }
    .step.visible { display: block; }

    .step h2 {
      color: #22c55e;
      font-size: 1.1rem;
      margin-bottom: 1rem;
    }

    .step p {
      margin-bottom: 1rem;
      font-size: 0.85rem;
      color: #aaa;
    }

    label {
      display: block;
      color: #888;
      font-size: 0.8rem;
      margin-bottom: 0.35rem;
    }

    textarea, input[type="text"], input[type="url"] {
      width: 100%;
      background: #111;
      border: 1px solid #333;
      color: #d4d4d4;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.8rem;
      padding: 0.5rem;
      border-radius: 3px;
      margin-bottom: 1rem;
      resize: vertical;
    }

    textarea:focus, input[type="text"]:focus, input[type="url"]:focus {
      outline: none;
      border-color: #22c55e;
    }

    input[type="file"] {
      display: block;
      margin-bottom: 1rem;
      color: #888;
      font-size: 0.8rem;
    }

    input[type="file"]::file-selector-button {
      background: #1a1a1a;
      border: 1px solid #333;
      color: #d4d4d4;
      padding: 0.35rem 0.75rem;
      border-radius: 3px;
      cursor: pointer;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.8rem;
      margin-right: 0.75rem;
    }

    .or-divider {
      text-align: center;
      color: #555;
      font-size: 0.75rem;
      margin: 0.5rem 0;
    }

    button.primary {
      background: #22c55e;
      color: #0a0a0a;
      border: none;
      padding: 0.6rem 1.5rem;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.85rem;
      font-weight: bold;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 0.5rem;
    }

    button.primary:hover { background: #16a34a; }
    button.primary:disabled { background: #333; color: #666; cursor: not-allowed; }

    .error {
      background: #2d1111;
      border: 1px solid #7f1d1d;
      color: #fca5a5;
      padding: 0.5rem 0.75rem;
      border-radius: 3px;
      font-size: 0.8rem;
      margin-bottom: 1rem;
      display: none;
    }

    .error.visible { display: block; }

    .success-info {
      background: #0d2818;
      border: 1px solid #14532d;
      color: #86efac;
      padding: 0.5rem 0.75rem;
      border-radius: 3px;
      font-size: 0.8rem;
      margin-bottom: 1rem;
    }

    .parsed-info {
      background: #111;
      border: 1px solid #333;
      padding: 0.5rem 0.75rem;
      border-radius: 3px;
      font-size: 0.78rem;
      margin-bottom: 1rem;
      color: #aaa;
    }

    .parsed-info .field {
      margin-bottom: 0.25rem;
    }

    .parsed-info .field-name {
      color: #888;
    }

    .parsed-info .field-value {
      color: #d4d4d4;
      word-break: break-all;
    }

    /* Gateway config */
    .gateway-hint {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 1rem;
    }

    /* Progress log */
    .progress-log {
      background: #050505;
      border: 1px solid #222;
      border-radius: 3px;
      padding: 0.75rem;
      max-height: 400px;
      overflow-y: auto;
      font-size: 0.78rem;
      line-height: 1.7;
      margin-bottom: 1rem;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .log-entry { color: #888; }
    .log-entry.info { color: #d4d4d4; }
    .log-entry.success { color: #22c55e; }
    .log-entry.error { color: #ef4444; }
    .log-entry.warn { color: #f59e0b; }

    .download-btn {
      background: #22c55e;
      color: #0a0a0a;
      border: none;
      padding: 0.75rem 2rem;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9rem;
      font-weight: bold;
      border-radius: 3px;
      cursor: pointer;
      display: none;
      margin-top: 1rem;
    }

    .download-btn.visible { display: inline-block; }
    .download-btn:hover { background: #16a34a; }

    .post-recovery-note {
      margin-top: 1rem;
      font-size: 0.78rem;
      color: #666;
      display: none;
    }

    .post-recovery-note.visible { display: block; }

    footer {
      margin-top: 3rem;
      padding-top: 1rem;
      border-top: 1px solid #222;
      color: #444;
      font-size: 0.7rem;
      text-align: center;
    }

    @media (max-width: 600px) {
      .container { padding: 1rem 0.75rem; }
      header h1 { font-size: 1.2rem; }
      .steps-indicator { flex-wrap: wrap; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>&gt; cipherbox vault recovery</h1>
      <p class="subtitle">
        This tool recovers your CipherBox vault using only your export file and private key.
        It connects directly to public IPFS gateways -- no CipherBox servers are contacted.
      </p>
    </header>

    <div class="steps-indicator">
      <span class="step-dot active" id="dot-1"><span class="num">1</span> Load</span>
      <span class="sep" style="color:#333">-</span>
      <span class="step-dot pending" id="dot-2"><span class="num">2</span> Key</span>
      <span class="sep" style="color:#333">-</span>
      <span class="step-dot pending" id="dot-3"><span class="num">3</span> Gateway</span>
      <span class="sep" style="color:#333">-</span>
      <span class="step-dot pending" id="dot-4"><span class="num">4</span> Recover</span>
    </div>

    <!-- Step 1: Load Export -->
    <div class="step visible" id="step-1">
      <h2>Step 1: Load Export File</h2>
      <p>Select your CipherBox vault export JSON file or paste its contents below.</p>

      <label for="export-file">Upload export file (.json)</label>
      <input type="file" id="export-file" accept=".json">

      <div class="or-divider">-- or paste JSON --</div>

      <label for="export-text">Paste export JSON</label>
      <textarea id="export-text" rows="6" placeholder='{"format":"cipherbox-vault-export","version":"1.0",...}'></textarea>

      <div class="error" id="error-1"></div>

      <button class="primary" id="btn-load">[ Load Export ]</button>
    </div>

    <!-- Step 2: Provide Private Key -->
    <div class="step" id="step-2">
      <h2>Step 2: Provide Private Key</h2>
      <p>Enter your secp256k1 private key to decrypt the vault root keys.</p>

      <div class="parsed-info" id="export-info"></div>

      <label for="key-text">Private key (hex or base64)</label>
      <textarea id="key-text" rows="2" placeholder="64 hex characters or ~44 base64 characters"></textarea>

      <div class="or-divider">-- or upload key file --</div>

      <label for="key-file">Upload key file</label>
      <input type="file" id="key-file">

      <div class="error" id="error-2"></div>

      <button class="primary" id="btn-decrypt">[ Decrypt Keys ]</button>
    </div>

    <!-- Step 3: Configure Gateway -->
    <div class="step" id="step-3">
      <h2>Step 3: Configure Gateways</h2>
      <p>Configure IPFS gateways for IPNS resolution and content retrieval. Defaults should work for most users.</p>

      <div class="success-info">Root keys decrypted successfully.</div>

      <label for="ipns-gateway">IPNS Resolution Gateway</label>
      <input type="url" id="ipns-gateway" value="https://delegated-ipfs.dev">
      <div class="gateway-hint">Alternatives: https://ipfs.io (uses /api/v0/name/resolve fallback)</div>

      <label for="ipfs-gateway">IPFS Content Gateway</label>
      <input type="url" id="ipfs-gateway" value="https://ipfs.io">
      <div class="gateway-hint">Alternatives: https://dweb.link, https://cloudflare-ipfs.com</div>

      <div class="error" id="error-3"></div>

      <button class="primary" id="btn-recover">[ Start Recovery ]</button>
    </div>

    <!-- Step 4: Recovery Progress -->
    <div class="step" id="step-4">
      <h2>Step 4: Recovery Progress</h2>

      <div class="progress-log" id="progress-log"></div>

      <div class="error" id="error-4"></div>

      <button class="download-btn" id="btn-download">[ Download Recovered Files ]</button>

      <p class="post-recovery-note" id="post-note">
        Your private key was used in-memory only and is not stored or transmitted.
        Close this page when done. Consider clearing your browser history.
      </p>
    </div>

    <footer>
      CipherBox Vault Recovery Tool -- Standalone, no server dependencies.
    </footer>
  </div>

  <!-- fflate UMD (must load before module script) -->
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>

  <script type="module">
    // =========================================================================
    // CDN Imports
    // =========================================================================
    import { secp256k1 } from 'https://cdn.jsdelivr.net/npm/@noble/curves@1/secp256k1/+esm';
    import { hkdf } from 'https://cdn.jsdelivr.net/npm/@noble/hashes@1/hkdf/+esm';
    import { sha256 } from 'https://cdn.jsdelivr.net/npm/@noble/hashes@1/sha2/+esm';
    import { concatBytes } from 'https://cdn.jsdelivr.net/npm/@noble/hashes@1/utils/+esm';
    import * as ed from 'https://cdn.jsdelivr.net/npm/@noble/ed25519@2/+esm';

    // =========================================================================
    // State
    // =========================================================================
    let exportData = null;
    let rootFolderKey = null;
    let rootIpnsPrivateKey = null;
    let privateKeyBytes = null;
    let recoveredFiles = [];
    let fileCount = 0;
    let errorCount = 0;
    let ipnsFailures = [];

    // =========================================================================
    // Utility Functions
    // =========================================================================
    function hexToBytes(hex) {
      const clean = hex.startsWith('0x') ? hex.slice(2) : hex;
      if (clean.length % 2 !== 0) throw new Error('Invalid hex: odd length');
      const bytes = new Uint8Array(clean.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        const b = parseInt(clean.substring(i * 2, i * 2 + 2), 16);
        if (Number.isNaN(b)) throw new Error('Invalid hex character');
        bytes[i] = b;
      }
      return bytes;
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function base64ToBytes(b64) {
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    function truncate(str, len) {
      if (str.length <= len) return str;
      return str.slice(0, len) + '...';
    }

    // =========================================================================
    // Crypto: ECIES Decrypt (matches eciesjs@0.4.16 exactly)
    // =========================================================================
    async function eciesDecrypt(privKeyBytes, encryptedHex) {
      const data = typeof encryptedHex === 'string' ? hexToBytes(encryptedHex) : encryptedHex;

      // 1. Extract ephemeral public key (65 bytes, uncompressed, 0x04 prefix)
      if (data.length < 65 + 16 + 16) {
        throw new Error('ECIES ciphertext too short');
      }
      const ephemeralPK = data.slice(0, 65);
      const payload = data.slice(65);

      // 2. Compute ECDH shared point (uncompressed output)
      //    eciesjs passes compressed ephemeral PK to getSharedSecret internally
      //    but output is uncompressed (compressed=false)
      const ephemeralPKCompressed = secp256k1.ProjectivePoint.fromHex(ephemeralPK).toRawBytes(true);
      const sharedPoint = secp256k1.getSharedSecret(privKeyBytes, ephemeralPKCompressed, false);

      // 3. senderPoint = ephemeral PK uncompressed (65 bytes)
      const senderPoint = ephemeralPK;

      // 4. Derive shared key: HKDF-SHA256(ikm=senderPoint||sharedPoint, salt=undefined, info=undefined, length=32)
      const ikm = concatBytes(senderPoint, sharedPoint);
      const sharedKey = hkdf(sha256, ikm, undefined, undefined, 32);

      // 5. Extract nonce (16 bytes), tag (16 bytes), ciphertext
      const nonce = payload.slice(0, 16);
      const tag = payload.slice(16, 32);
      const ciphertext = payload.slice(32);

      // 6. Decrypt with AES-256-GCM
      //    Web Crypto expects ciphertext||tag concatenated
      const combined = new Uint8Array(ciphertext.length + tag.length);
      combined.set(ciphertext, 0);
      combined.set(tag, ciphertext.length);

      const cryptoKey = await crypto.subtle.importKey(
        'raw', sharedKey, { name: 'AES-GCM' }, false, ['decrypt']
      );
      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: nonce }, cryptoKey, combined
      );

      return new Uint8Array(plaintext);
    }

    // =========================================================================
    // Crypto: AES-256-GCM Folder Metadata Decrypt
    // =========================================================================
    async function decryptFolderMetadata(encryptedJson, folderKey) {
      // encryptedJson = { iv: "hex", data: "base64" }
      const iv = hexToBytes(encryptedJson.iv);       // 12 bytes
      const ciphertext = base64ToBytes(encryptedJson.data); // includes 16-byte auth tag

      const cryptoKey = await crypto.subtle.importKey(
        'raw', folderKey, { name: 'AES-GCM' }, false, ['decrypt']
      );
      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv }, cryptoKey, ciphertext
      );

      return JSON.parse(new TextDecoder().decode(plaintext));
    }

    // =========================================================================
    // Crypto: AES-256-GCM File Decrypt
    // =========================================================================
    async function decryptFile(encryptedBytes, fileKey, fileIvHex) {
      const iv = hexToBytes(fileIvHex); // 12 bytes

      const cryptoKey = await crypto.subtle.importKey(
        'raw', fileKey, { name: 'AES-GCM' }, false, ['decrypt']
      );
      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv }, cryptoKey, encryptedBytes
      );

      return new Uint8Array(plaintext);
    }

    // =========================================================================
    // Crypto: HKDF File IPNS Derivation (v2 per-file metadata)
    // =========================================================================
    const FILE_HKDF_SALT = new TextEncoder().encode('CipherBox-v1');

    /**
     * Derive a file's IPNS name from user's private key and fileId using HKDF.
     * Matches the derivation in @cipherbox/crypto deriveFileIpnsKeypair.
     *
     * Path: secp256k1 privateKey -> HKDF-SHA256 -> 32-byte Ed25519 seed
     *       -> Ed25519 public key -> IPNS name (k51...)
     */
    async function deriveFileIpnsName(userPrivateKey, fileId) {
      const info = new TextEncoder().encode(`cipherbox-file-ipns-v1:${fileId}`);

      // 1. HKDF-SHA256 to derive 32-byte Ed25519 seed
      const keyMaterial = await crypto.subtle.importKey(
        'raw', userPrivateKey, 'HKDF', false, ['deriveBits']
      );
      const derivedBits = await crypto.subtle.deriveBits(
        { name: 'HKDF', hash: 'SHA-256', salt: FILE_HKDF_SALT, info },
        keyMaterial, 256
      );
      const ed25519Seed = new Uint8Array(derivedBits);

      // 2. Derive Ed25519 public key from seed
      const ed25519PublicKey = await ed.getPublicKeyAsync(ed25519Seed);

      // 3. Derive IPNS name from Ed25519 public key
      return ed25519PublicKeyToIpnsName(ed25519PublicKey);
    }

    /**
     * Convert an Ed25519 public key to an IPNS name (k51... base36 CIDv1).
     *
     * CID structure:
     *   0x01 (CIDv1) + 0x72 (libp2p-key codec) + multihash
     * Multihash:
     *   0x00 (identity hash) + 0x24 (36 bytes digest length) + digest
     * Digest (protobuf-encoded Ed25519 public key):
     *   0x08 0x01 (field 1: KeyType = Ed25519)
     *   0x12 0x20 (field 2: Data, 32 bytes)
     *   + 32 bytes public key
     */
    function ed25519PublicKeyToIpnsName(publicKey) {
      // Build CID bytes: version(1) + codec(0x72) + identity-multihash(protobuf key)
      const cidBytes = new Uint8Array(40); // 2 + 2 + 4 + 32
      cidBytes[0] = 0x01; // CIDv1
      cidBytes[1] = 0x72; // libp2p-key multicodec
      cidBytes[2] = 0x00; // identity multihash function code
      cidBytes[3] = 0x24; // digest length = 36 bytes
      // Protobuf: field 1 (KeyType) = Ed25519 = 1
      cidBytes[4] = 0x08;
      cidBytes[5] = 0x01;
      // Protobuf: field 2 (Data) = length-delimited, 32 bytes
      cidBytes[6] = 0x12;
      cidBytes[7] = 0x20;
      // Ed25519 public key bytes
      cidBytes.set(publicKey, 8);

      // Encode as base36lower with 'k' multibase prefix
      return base36Encode(cidBytes);
    }

    /**
     * Base36 encode bytes with 'k' multibase prefix (base36lower).
     * Encodes as a big-endian unsigned integer in base36.
     */
    function base36Encode(bytes) {
      const ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';

      // Convert bytes to a BigInt (big-endian unsigned)
      let n = 0n;
      for (const b of bytes) {
        n = (n << 8n) | BigInt(b);
      }

      // Convert to base36
      if (n === 0n) return 'k0';
      const digits = [];
      while (n > 0n) {
        digits.push(ALPHABET[Number(n % 36n)]);
        n = n / 36n;
      }

      // Count leading zero bytes for zero-padding
      let leadingZeros = 0;
      for (const b of bytes) {
        if (b === 0) leadingZeros++;
        else break;
      }
      for (let i = 0; i < leadingZeros; i++) {
        digits.push('0');
      }

      digits.reverse();
      return 'k' + digits.join('');
    }

    // =========================================================================
    // Crypto: Decrypt File Metadata (v2 per-file IPNS records)
    // =========================================================================
    /**
     * Decrypt per-file metadata. Same format as folder metadata:
     * { iv: "hex", data: "base64" } encrypted with parent folderKey (AES-256-GCM).
     */
    async function decryptFileMetadata(encryptedJson, folderKey) {
      const iv = hexToBytes(encryptedJson.iv);
      const ciphertext = base64ToBytes(encryptedJson.data);

      const cryptoKey = await crypto.subtle.importKey(
        'raw', folderKey, { name: 'AES-GCM' }, false, ['decrypt']
      );
      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv }, cryptoKey, ciphertext
      );

      return JSON.parse(new TextDecoder().decode(plaintext));
    }

    // =========================================================================
    // IPNS Resolution
    // =========================================================================
    async function resolveIpns(ipnsName, gatewayUrl) {
      const maxRetries = 3;

      // Primary: Delegated routing API
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const url = `${gatewayUrl}/routing/v1/ipns/${ipnsName}`;
          const resp = await fetch(url, {
            headers: { 'Accept': 'application/vnd.ipfs.ipns-record' }
          });

          if (resp.ok) {
            // The delegated routing API can return the IPNS record in different formats
            // Try JSON first (application/json), then raw record
            const contentType = resp.headers.get('Content-Type') || '';

            if (contentType.includes('application/json')) {
              const json = await resp.json();
              // Extract CID from the record value
              if (json.record && json.record.value) {
                return extractCidFromValue(json.record.value);
              }
              if (json.value) {
                return extractCidFromValue(json.value);
              }
            }

            // For vnd.ipfs.ipns-record, the response is a binary IPNS record
            // We need to parse the CBOR/protobuf to extract the Value field
            const recordBytes = new Uint8Array(await resp.arrayBuffer());
            const cid = extractCidFromIpnsRecord(recordBytes);
            if (cid) return cid;
          }
        } catch (e) {
          if (attempt < maxRetries - 1) {
            await sleep(1000 * Math.pow(2, attempt));
            continue;
          }
        }
      }

      // Fallback: ipfs.io name resolve API
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const url = `https://ipfs.io/api/v0/name/resolve?arg=${ipnsName}`;
          const resp = await fetch(url);
          if (resp.ok) {
            const json = await resp.json();
            if (json.Path) {
              return extractCidFromValue(json.Path);
            }
          }
        } catch (e) {
          if (attempt < maxRetries - 1) {
            await sleep(1000 * Math.pow(2, attempt));
            continue;
          }
        }
      }

      throw new Error(`Failed to resolve IPNS name: ${truncate(ipnsName, 20)}`);
    }

    function extractCidFromValue(value) {
      // Value is typically "/ipfs/bafy..." - extract the CID
      if (typeof value === 'string') {
        if (value.startsWith('/ipfs/')) return value.slice(6);
        return value;
      }
      // If it's bytes (from CBOR), decode as string
      if (value instanceof Uint8Array) {
        const str = new TextDecoder().decode(value);
        if (str.startsWith('/ipfs/')) return str.slice(6);
        return str;
      }
      throw new Error('Unexpected IPNS value format');
    }

    function extractCidFromIpnsRecord(recordBytes) {
      // IPNS records are protobuf-encoded.
      // The Value field is field number 2 (wire type 2 = length-delimited).
      // We need to find field 2 in the protobuf.
      try {
        let offset = 0;
        while (offset < recordBytes.length) {
          const fieldByte = recordBytes[offset];
          const fieldNumber = fieldByte >> 3;
          const wireType = fieldByte & 0x07;

          offset++;

          if (wireType === 2) {
            // Length-delimited
            let length = 0;
            let shift = 0;
            while (offset < recordBytes.length) {
              const b = recordBytes[offset++];
              length |= (b & 0x7f) << shift;
              if ((b & 0x80) === 0) break;
              shift += 7;
            }

            if (fieldNumber === 2) {
              // Value field - this is the IPFS path
              const valueBytes = recordBytes.slice(offset, offset + length);
              const value = new TextDecoder().decode(valueBytes);
              return extractCidFromValue(value);
            }

            offset += length;
          } else if (wireType === 0) {
            // Varint - skip
            while (offset < recordBytes.length && (recordBytes[offset] & 0x80) !== 0) offset++;
            offset++;
          } else {
            // Unknown wire type, bail
            break;
          }
        }
      } catch (e) {
        // Failed to parse protobuf
      }
      return null;
    }

    // =========================================================================
    // IPFS Content Fetch
    // =========================================================================
    async function fetchFromIpfs(cid, ipfsGatewayUrl) {
      const maxRetries = 3;

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const url = `${ipfsGatewayUrl}/ipfs/${cid}`;
          const resp = await fetch(url);
          if (resp.ok) {
            return new Uint8Array(await resp.arrayBuffer());
          }
          if (resp.status === 404) {
            throw new Error(`Content not found on IPFS: ${truncate(cid, 20)}`);
          }
        } catch (e) {
          if (e.message.includes('not found')) throw e;
          if (attempt < maxRetries - 1) {
            await sleep(1000 * Math.pow(2, attempt));
            continue;
          }
          throw new Error(`Failed to fetch from IPFS: ${truncate(cid, 20)}`);
        }
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // =========================================================================
    // Recursive Folder Recovery
    // =========================================================================
    async function recoverFolder(ipnsName, folderKey, path, gatewayConfig) {
      // 1. Resolve IPNS name -> CID
      log(`Resolving IPNS: ${truncate(ipnsName, 30)}...`, 'info');
      const cid = await resolveIpns(ipnsName, gatewayConfig.ipnsGateway);
      log(`  Resolved to CID: ${truncate(cid, 40)}`, 'info');

      // 2. Fetch encrypted metadata
      log(`Fetching metadata for ${path || '/'}...`, 'info');
      const metadataBytes = await fetchFromIpfs(cid, gatewayConfig.ipfsGateway);

      // 3. Parse as JSON (encrypted metadata format)
      let encryptedMeta;
      try {
        encryptedMeta = JSON.parse(new TextDecoder().decode(metadataBytes));
      } catch (e) {
        throw new Error(`Failed to parse metadata JSON for ${path || '/'}`);
      }

      // 4. Decrypt metadata
      log(`Decrypting metadata for ${path || '/'}...`, 'info');
      const metadata = await decryptFolderMetadata(encryptedMeta, folderKey);

      if (!metadata.children || !Array.isArray(metadata.children)) {
        log(`  No children in ${path || '/'}`, 'info');
        return;
      }

      // Reject non-v2 metadata
      if (metadata.version !== 'v2') {
        log(`  ERROR: Unsupported metadata version "${metadata.version}" for ${path || '/'} (only v2 supported). Skipping folder.`, 'error');
        errorCount++;
        return;
      }

      log(`  Found ${metadata.children.length} items in ${path || '/'}`, 'success');

      // 5. Process each child
      for (const child of metadata.children) {
        if (child.type === 'folder') {
          try {
            // ECIES-decrypt subfolder keys
            log(`Decrypting keys for folder: ${child.name}`, 'info');
            const subFolderKey = await eciesDecrypt(privateKeyBytes, child.folderKeyEncrypted);

            // We decrypt the IPNS private key for completeness but only need the name
            // (ipnsPrivateKey is 64-byte libp2p format: seed||pubkey)
            const subPath = path ? `${path}/${child.name}` : child.name;

            // Recurse into subfolder
            await recoverFolder(child.ipnsName, subFolderKey, subPath, gatewayConfig);
          } catch (e) {
            log(`  ERROR recovering folder "${child.name}": ${e.message}`, 'error');
            errorCount++;
          }
        } else if (child.type === 'file') {
          // Validate FilePointer has required fileMetaIpnsName
          if (!child.fileMetaIpnsName) {
            log(`  ERROR: Invalid file child "${child.name}": missing fileMetaIpnsName (v1 format not supported)`, 'error');
            errorCount++;
            continue;
          }

          // ── FilePointer: resolve per-file IPNS to get file metadata ──
          try {
            const filePath = path ? `${path}/${child.name}` : child.name;
            log(`Resolving file IPNS: ${child.name}...`, 'info');

            const fileIpnsName = child.fileMetaIpnsName;

            // a. Resolve file IPNS to get file metadata CID
            let fileMetaCid;
            try {
              fileMetaCid = await resolveIpns(fileIpnsName, gatewayConfig.ipnsGateway);
            } catch (resolveErr) {
              log(`  WARNING: File IPNS record may have expired for "${child.name}". ` +
                  `IPNS name: ${truncate(fileIpnsName, 30)}. ` +
                  `File content CID is not recoverable via IPNS.`, 'warn');
              ipnsFailures.push({ name: child.name, ipnsName: fileIpnsName });
              errorCount++;
              continue;
            }

            log(`  File metadata CID: ${truncate(fileMetaCid, 40)}`, 'info');

            // b. Fetch encrypted file metadata from IPFS
            const encFileMetaBytes = await fetchFromIpfs(fileMetaCid, gatewayConfig.ipfsGateway);
            const encFileMeta = JSON.parse(new TextDecoder().decode(encFileMetaBytes));

            // c. Decrypt file metadata with parent's folderKey
            const fileMeta = await decryptFileMetadata(encFileMeta, folderKey);

            // d. Extract file details from decrypted metadata
            const { cid: contentCid, fileKeyEncrypted, fileIv, size, encryptionMode } = fileMeta;

            log(`Downloading: ${filePath}... (${formatSize(size || 0)})`, 'info');

            // e. ECIES-decrypt file key
            const fileKey = await eciesDecrypt(privateKeyBytes, fileKeyEncrypted);

            // f. Fetch encrypted file from IPFS
            const encryptedFile = await fetchFromIpfs(contentCid, gatewayConfig.ipfsGateway);

            // g. Decrypt file content
            const decryptedFile = await decryptFile(encryptedFile, fileKey, fileIv);

            // Store for zip
            recoveredFiles.push({ path: filePath, data: decryptedFile });
            fileCount++;

            log(`  Decrypted: ${filePath} (${formatSize(decryptedFile.length)})`, 'success');
          } catch (e) {
            log(`  ERROR recovering file "${child.name}": ${e.message}`, 'error');
            errorCount++;
          }
        }
      }
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // =========================================================================
    // Logging
    // =========================================================================
    const logEl = document.getElementById('progress-log');

    function log(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = message;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }

    // =========================================================================
    // Step Navigation
    // =========================================================================
    function showStep(n) {
      for (let i = 1; i <= 4; i++) {
        document.getElementById(`step-${i}`).classList.toggle('visible', i === n);
        const dot = document.getElementById(`dot-${i}`);
        dot.classList.remove('active', 'complete', 'pending');
        if (i < n) dot.classList.add('complete');
        else if (i === n) dot.classList.add('active');
        else dot.classList.add('pending');
      }
    }

    function showError(stepN, msg) {
      const el = document.getElementById(`error-${stepN}`);
      el.textContent = msg;
      el.classList.add('visible');
    }

    function clearError(stepN) {
      const el = document.getElementById(`error-${stepN}`);
      el.textContent = '';
      el.classList.remove('visible');
    }

    // =========================================================================
    // Step 1: Load Export
    // =========================================================================
    document.getElementById('btn-load').addEventListener('click', async () => {
      clearError(1);

      let jsonText = '';
      const fileInput = document.getElementById('export-file');
      const textInput = document.getElementById('export-text');

      if (fileInput.files.length > 0) {
        jsonText = await fileInput.files[0].text();
      } else if (textInput.value.trim()) {
        jsonText = textInput.value.trim();
      } else {
        showError(1, 'Please select a file or paste the export JSON.');
        return;
      }

      try {
        const parsed = JSON.parse(jsonText);

        if (parsed.format !== 'cipherbox-vault-export') {
          showError(1, 'Invalid export file: missing or incorrect "format" field. Expected "cipherbox-vault-export".');
          return;
        }

        if (parsed.version !== '1.0') {
          showError(1, `Unsupported export version: "${parsed.version}". This tool supports version "1.0".`);
          return;
        }

        if (!parsed.rootIpnsName || !parsed.encryptedRootFolderKey || !parsed.encryptedRootIpnsPrivateKey) {
          showError(1, 'Export file is missing required fields (rootIpnsName, encryptedRootFolderKey, encryptedRootIpnsPrivateKey).');
          return;
        }

        exportData = parsed;

        // Show parsed info in step 2
        let infoHtml = `<div class="field"><span class="field-name">rootIpnsName:</span> <span class="field-value">${truncate(parsed.rootIpnsName, 50)}</span></div>`;
        if (parsed.exportedAt) {
          infoHtml += `<div class="field"><span class="field-name">exportedAt:</span> <span class="field-value">${parsed.exportedAt}</span></div>`;
        }
        if (parsed.derivationInfo) {
          infoHtml += `<div class="field"><span class="field-name">derivationInfo:</span> <span class="field-value">${JSON.stringify(parsed.derivationInfo)}</span></div>`;
        }
        document.getElementById('export-info').innerHTML = infoHtml;

        showStep(2);
      } catch (e) {
        showError(1, 'Failed to parse JSON: ' + e.message);
      }
    });

    // Also load file on file input change
    document.getElementById('export-file').addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        document.getElementById('export-text').value = '';
      }
    });

    // =========================================================================
    // Step 2: Decrypt Keys
    // =========================================================================
    document.getElementById('btn-decrypt').addEventListener('click', async () => {
      clearError(2);

      let keyText = '';
      const keyFile = document.getElementById('key-file');
      const keyInput = document.getElementById('key-text');

      if (keyFile.files.length > 0) {
        keyText = (await keyFile.files[0].text()).trim();
      } else if (keyInput.value.trim()) {
        keyText = keyInput.value.trim();
      } else {
        showError(2, 'Please provide your private key.');
        return;
      }

      try {
        // Auto-detect format: hex (64 chars) or base64 (~44 chars)
        if (/^(0x)?[0-9a-fA-F]{64}$/.test(keyText)) {
          privateKeyBytes = hexToBytes(keyText);
        } else if (/^[A-Za-z0-9+/=]{40,50}$/.test(keyText)) {
          privateKeyBytes = base64ToBytes(keyText);
        } else if (/^[0-9a-fA-F]{64}$/.test(keyText.replace(/^0x/, ''))) {
          privateKeyBytes = hexToBytes(keyText);
        } else {
          // Try hex first, then base64
          try {
            privateKeyBytes = hexToBytes(keyText);
          } catch {
            try {
              privateKeyBytes = base64ToBytes(keyText);
            } catch {
              showError(2, 'Could not parse private key. Provide 32 bytes as 64 hex characters or base64.');
              return;
            }
          }
        }

        if (privateKeyBytes.length !== 32) {
          showError(2, `Private key must be 32 bytes (got ${privateKeyBytes.length} bytes). Check your input format.`);
          privateKeyBytes = null;
          return;
        }

        // Try ECIES-decrypting root folder key
        const btn = document.getElementById('btn-decrypt');
        btn.disabled = true;
        btn.textContent = '[ Decrypting... ]';

        try {
          rootFolderKey = await eciesDecrypt(privateKeyBytes, exportData.encryptedRootFolderKey);
          rootIpnsPrivateKey = await eciesDecrypt(privateKeyBytes, exportData.encryptedRootIpnsPrivateKey);
        } catch (e) {
          showError(2, 'Failed to decrypt keys. Make sure you are using the correct private key.');
          btn.disabled = false;
          btn.textContent = '[ Decrypt Keys ]';
          privateKeyBytes = null;
          return;
        }

        btn.disabled = false;
        btn.textContent = '[ Decrypt Keys ]';

        showStep(3);
      } catch (e) {
        showError(2, 'Error: ' + e.message);
      }
    });

    document.getElementById('key-file').addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        document.getElementById('key-text').value = '';
      }
    });

    // =========================================================================
    // Step 3: Start Recovery
    // =========================================================================
    document.getElementById('btn-recover').addEventListener('click', async () => {
      clearError(3);

      const ipnsGateway = document.getElementById('ipns-gateway').value.trim().replace(/\/+$/, '');
      const ipfsGateway = document.getElementById('ipfs-gateway').value.trim().replace(/\/+$/, '');

      if (!ipnsGateway || !ipfsGateway) {
        showError(3, 'Both gateway URLs are required.');
        return;
      }

      const gatewayConfig = { ipnsGateway, ipfsGateway };

      // Move to step 4
      showStep(4);

      // Reset state
      recoveredFiles = [];
      fileCount = 0;
      errorCount = 0;
      ipnsFailures = [];
      logEl.innerHTML = '';

      log('CipherBox Vault Recovery starting...', 'info');
      log(`IPNS gateway: ${ipnsGateway}`, 'info');
      log(`IPFS gateway: ${ipfsGateway}`, 'info');
      log('', 'info');

      try {
        await recoverFolder(exportData.rootIpnsName, rootFolderKey, '', gatewayConfig);

        log('', 'info');
        if (fileCount === 0 && errorCount === 0) {
          log('Recovery complete. Vault is empty (no files found).', 'warn');
        } else if (errorCount === 0) {
          log(`Recovery complete. ${fileCount} file(s) recovered successfully.`, 'success');
        } else {
          log(`Recovery complete. ${fileCount} file(s) recovered, ${errorCount} error(s).`, 'warn');
        }

        // Report IPNS resolution failures with details for manual recovery
        if (ipnsFailures.length > 0) {
          log('', 'info');
          log(`${ipnsFailures.length} file(s) had expired IPNS records:`, 'warn');
          for (const f of ipnsFailures) {
            log(`  - ${f.name} (IPNS: ${truncate(f.ipnsName, 40)})`, 'warn');
          }
          log('These files are still on IPFS but their CIDs cannot be discovered via IPNS.', 'warn');
          log('If you have the CIDs from another source, you can retrieve them manually.', 'info');
        }

        if (fileCount > 0) {
          document.getElementById('btn-download').classList.add('visible');
        }

        document.getElementById('post-note').classList.add('visible');
      } catch (e) {
        log(`FATAL ERROR: ${e.message}`, 'error');
        showError(4, 'Recovery failed: ' + e.message);
        document.getElementById('post-note').classList.add('visible');
      }
    });

    // =========================================================================
    // Step 4: Download Zip
    // =========================================================================
    document.getElementById('btn-download').addEventListener('click', () => {
      if (recoveredFiles.length === 0) return;

      log('Creating zip archive...', 'info');

      try {
        // Build fflate zip structure: { "path/file.txt": Uint8Array }
        const zipData = {};
        for (const file of recoveredFiles) {
          zipData[file.path] = file.data;
        }

        const zipped = fflate.zipSync(zipData);

        // Trigger download
        const blob = new Blob([zipped], { type: 'application/zip' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const date = new Date().toISOString().slice(0, 10);
        a.href = url;
        a.download = `cipherbox-recovery-${date}.zip`;
        a.click();
        URL.revokeObjectURL(url);

        log('Zip download started.', 'success');
      } catch (e) {
        log(`Failed to create zip: ${e.message}`, 'error');
      }
    });
  </script>
</body>
</html>
