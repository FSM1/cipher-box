//! Cross-language test vectors for crypto operations.
//!
//! All test vectors were generated by `generate-test-vectors.mjs` using the
//! @cipherbox/crypto TypeScript module. The Rust implementations must produce
//! byte-identical output for deterministic operations (AES with fixed IV/key,
//! Ed25519 signatures, IPNS name derivation).

use super::aes;
use super::ecies;
use super::ed25519;
use super::folder::{
    decrypt_folder_metadata, encrypt_folder_metadata, FileEntry, FolderChild, FolderEntry,
    FolderMetadata,
};
use super::ipns;
use super::utils;

// ============================================================
// AES-256-GCM Cross-Language Test Vectors
// ============================================================

/// Fixed AES key from TypeScript test vector generation.
const AES_TEST_KEY: &str = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
/// Fixed AES IV from TypeScript test vector generation.
const AES_TEST_IV: &str = "aabbccddeeff00112233aabb";
/// Expected ciphertext (with 16-byte tag) from TypeScript encryptAesGcm.
const AES_EXPECTED_CIPHERTEXT: &str =
    "196a1416ae4cf2abbd0bb8bdd7dd16be5527207b3c04f9e0a0acf4274fdccbdd5e";

#[test]
fn aes_cross_language_encrypt() {
    let key_bytes = hex::decode(AES_TEST_KEY).unwrap();
    let iv_bytes = hex::decode(AES_TEST_IV).unwrap();
    let plaintext = b"Hello, CipherBox!";

    let key: [u8; 32] = key_bytes.try_into().unwrap();
    let iv: [u8; 12] = iv_bytes.try_into().unwrap();

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    assert_eq!(
        hex::encode(&ciphertext),
        AES_EXPECTED_CIPHERTEXT,
        "Rust AES-256-GCM ciphertext must match TypeScript output"
    );
}

#[test]
fn aes_cross_language_decrypt() {
    let key_bytes = hex::decode(AES_TEST_KEY).unwrap();
    let iv_bytes = hex::decode(AES_TEST_IV).unwrap();
    let ciphertext = hex::decode(AES_EXPECTED_CIPHERTEXT).unwrap();

    let key: [u8; 32] = key_bytes.try_into().unwrap();
    let iv: [u8; 12] = iv_bytes.try_into().unwrap();

    let plaintext = aes::decrypt_aes_gcm(&ciphertext, &key, &iv).unwrap();
    assert_eq!(
        String::from_utf8(plaintext).unwrap(),
        "Hello, CipherBox!",
        "Rust must decrypt TypeScript ciphertext correctly"
    );
}

#[test]
fn aes_roundtrip() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Round-trip test data for AES-256-GCM";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    let decrypted = aes::decrypt_aes_gcm(&ciphertext, &key, &iv).unwrap();

    assert_eq!(decrypted, plaintext);
}

#[test]
fn aes_ciphertext_includes_tag() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Test";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    // ciphertext = plaintext + 16-byte auth tag
    assert_eq!(ciphertext.len(), plaintext.len() + aes::AES_TAG_SIZE);
}

#[test]
fn aes_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Secret data";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key1, &iv).unwrap();
    let result = aes::decrypt_aes_gcm(&ciphertext, &key2, &iv);
    assert!(result.is_err());
}

#[test]
fn aes_tampered_ciphertext_fails() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Authenticated data";

    let mut ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    ciphertext[0] ^= 0xff;

    let result = aes::decrypt_aes_gcm(&ciphertext, &key, &iv);
    assert!(result.is_err());
}

#[test]
fn aes_empty_plaintext() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    assert_eq!(ciphertext.len(), aes::AES_TAG_SIZE);

    let decrypted = aes::decrypt_aes_gcm(&ciphertext, &key, &iv).unwrap();
    assert!(decrypted.is_empty());
}

// ============================================================
// AES Seal/Unseal Tests
// ============================================================

#[test]
fn seal_unseal_roundtrip() {
    let key = utils::generate_file_key();
    let plaintext = b"Hello, CipherBox!";

    let sealed = aes::seal_aes_gcm(plaintext, &key).unwrap();
    let unsealed = aes::unseal_aes_gcm(&sealed, &key).unwrap();

    assert_eq!(unsealed, plaintext);
}

#[test]
fn seal_format_iv_ciphertext_tag() {
    let key = utils::generate_file_key();
    let plaintext = b"Test";

    let sealed = aes::seal_aes_gcm(plaintext, &key).unwrap();
    // Sealed = IV (12) + ciphertext (plaintext.len()) + tag (16)
    assert_eq!(
        sealed.len(),
        aes::AES_IV_SIZE + plaintext.len() + aes::AES_TAG_SIZE
    );
}

#[test]
fn seal_random_iv_produces_different_output() {
    let key = utils::generate_file_key();
    let plaintext = b"Same plaintext";

    let sealed1 = aes::seal_aes_gcm(plaintext, &key).unwrap();
    let sealed2 = aes::seal_aes_gcm(plaintext, &key).unwrap();

    assert_ne!(sealed1, sealed2, "Random IV should produce different sealed output");

    // But both unseal to same plaintext
    let unsealed1 = aes::unseal_aes_gcm(&sealed1, &key).unwrap();
    let unsealed2 = aes::unseal_aes_gcm(&sealed2, &key).unwrap();
    assert_eq!(unsealed1, plaintext);
    assert_eq!(unsealed2, plaintext);
}

#[test]
fn unseal_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let plaintext = b"Secret data";

    let sealed = aes::seal_aes_gcm(plaintext, &key1).unwrap();
    let result = aes::unseal_aes_gcm(&sealed, &key2);
    assert!(result.is_err());
}

#[test]
fn unseal_too_short_fails() {
    let key = utils::generate_file_key();
    let short_data = vec![0u8; 27]; // less than IV(12) + tag(16) = 28
    let result = aes::unseal_aes_gcm(&short_data, &key);
    assert!(result.is_err());
}

#[test]
fn seal_empty_plaintext() {
    let key = utils::generate_file_key();
    let plaintext = b"";

    let sealed = aes::seal_aes_gcm(plaintext, &key).unwrap();
    assert_eq!(sealed.len(), aes::AES_IV_SIZE + aes::AES_TAG_SIZE);

    let unsealed = aes::unseal_aes_gcm(&sealed, &key).unwrap();
    assert!(unsealed.is_empty());
}

// ============================================================
// Ed25519 Cross-Language Test Vectors
// ============================================================

/// Fixed Ed25519 private key (from RFC 8032 test vector).
const ED25519_TEST_PRIVATE_KEY: &str =
    "9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60";
/// Expected public key from the private key above.
const ED25519_TEST_PUBLIC_KEY: &str =
    "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a";
/// Expected signature for "Hello, CipherBox!" with the above key.
const ED25519_TEST_SIGNATURE: &str =
    "a4cc4f358e30c8630839e457bf9a27da2062b3c6ca588b3947a9085d909d807c9be05a6a0b69e9fdc5e5b6503e79c04b1bdd92921350559e35376b78f9ca5601";

#[test]
fn ed25519_cross_language_public_key() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let expected_public = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();

    let public_key = ed25519::get_public_key(&private_key).unwrap();
    assert_eq!(
        public_key, expected_public,
        "Rust Ed25519 public key derivation must match TypeScript"
    );
}

#[test]
fn ed25519_cross_language_signature() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let message = b"Hello, CipherBox!";

    let signature = ed25519::sign_ed25519(message, &private_key).unwrap();
    assert_eq!(
        hex::encode(&signature),
        ED25519_TEST_SIGNATURE,
        "Rust Ed25519 signature must be byte-identical to TypeScript (deterministic)"
    );
}

#[test]
fn ed25519_cross_language_verify() {
    let public_key = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let message = b"Hello, CipherBox!";
    let signature = hex::decode(ED25519_TEST_SIGNATURE).unwrap();

    let valid = ed25519::verify_ed25519(message, &signature, &public_key);
    assert!(valid, "TypeScript Ed25519 signature must verify in Rust");
}

#[test]
fn ed25519_deterministic_signatures() {
    let (_, private_key) = ed25519::generate_ed25519_keypair();
    let message = b"deterministic test";

    let sig1 = ed25519::sign_ed25519(message, &private_key).unwrap();
    let sig2 = ed25519::sign_ed25519(message, &private_key).unwrap();
    assert_eq!(sig1, sig2, "Ed25519 signatures must be deterministic");
}

#[test]
fn ed25519_sign_verify_roundtrip() {
    let (public_key, private_key) = ed25519::generate_ed25519_keypair();
    let message = b"Round-trip test for Ed25519";

    let signature = ed25519::sign_ed25519(message, &private_key).unwrap();
    assert_eq!(signature.len(), 64);

    let valid = ed25519::verify_ed25519(message, &signature, &public_key);
    assert!(valid);
}

#[test]
fn ed25519_wrong_public_key_fails() {
    let (_, private_key1) = ed25519::generate_ed25519_keypair();
    let (public_key2, _) = ed25519::generate_ed25519_keypair();
    let message = b"signed by keypair1";

    let signature = ed25519::sign_ed25519(message, &private_key1).unwrap();
    let valid = ed25519::verify_ed25519(message, &signature, &public_key2);
    assert!(!valid);
}

#[test]
fn ed25519_modified_message_fails() {
    let (public_key, private_key) = ed25519::generate_ed25519_keypair();
    let original = b"original message";
    let modified = b"modified message";

    let signature = ed25519::sign_ed25519(original, &private_key).unwrap();
    let valid = ed25519::verify_ed25519(modified, &signature, &public_key);
    assert!(!valid);
}

#[test]
fn ed25519_invalid_key_size_fails() {
    let short_key = vec![0u8; 16];
    let result = ed25519::sign_ed25519(b"test", &short_key);
    assert!(result.is_err());
}

#[test]
fn ed25519_invalid_signature_returns_false() {
    let (public_key, _) = ed25519::generate_ed25519_keypair();
    let bad_sig = vec![0u8; 32]; // wrong size
    assert!(!ed25519::verify_ed25519(b"test", &bad_sig, &public_key));
}

#[test]
fn ed25519_invalid_public_key_returns_false() {
    let bad_pub = vec![0u8; 16]; // wrong size
    let sig = vec![0u8; 64];
    assert!(!ed25519::verify_ed25519(b"test", &sig, &bad_pub));
}

// ============================================================
// ECIES Cross-Language Test Vectors
// ============================================================

/// Fixed secp256k1 private key for ECIES tests.
const ECIES_TEST_PRIVATE_KEY: &str =
    "c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721";
/// Corresponding uncompressed public key (65 bytes, 0x04 prefix).
const ECIES_TEST_PUBLIC_KEY: &str =
    "042c8c31fc9f990c6b55e3865a184a4ce50e09481f2eaeb3e60ec1cea13a6ae64564b95e4fdb6948c0386e189b006a29f686769b011704275e4459822dc3328085";
/// Plaintext for ECIES test.
const ECIES_TEST_PLAINTEXT: &str =
    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
/// TypeScript-wrapped ciphertext for Rust to unwrap.
const ECIES_TS_WRAPPED: &str =
    "04d8fffb3faadd4a9977c520a6627f3ff4fa0f8350032398bb1bfa7c0bdff2661212743ee8fec655eb145cefc7fb1a6d52f6062f7ce8f16666e080af74685294e1218732428593e85e92dc42580fcc6e0dbae6237813e9961f8fdd8409e0592d7442ac41d85539dac237cc344f1766e41532b7ea90274a83da7e40f4733e21a022";

#[test]
fn ecies_unwrap_typescript_wrapped() {
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let wrapped = hex::decode(ECIES_TS_WRAPPED).unwrap();
    let expected_plaintext = hex::decode(ECIES_TEST_PLAINTEXT).unwrap();

    let unwrapped = ecies::unwrap_key(&wrapped, &private_key).unwrap();
    assert_eq!(
        unwrapped, expected_plaintext,
        "Rust must decrypt TypeScript ECIES-wrapped data"
    );
}

#[test]
fn ecies_roundtrip() {
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    let plaintext = hex::decode(ECIES_TEST_PLAINTEXT).unwrap();

    let wrapped = ecies::wrap_key(&plaintext, &public_key).unwrap();
    let unwrapped = ecies::unwrap_key(&wrapped, &private_key).unwrap();
    assert_eq!(unwrapped, plaintext);
}

#[test]
fn ecies_ephemeral_key_produces_different_output() {
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let plaintext = hex::decode(ECIES_TEST_PLAINTEXT).unwrap();

    let wrapped1 = ecies::wrap_key(&plaintext, &public_key).unwrap();
    let wrapped2 = ecies::wrap_key(&plaintext, &public_key).unwrap();
    assert_ne!(
        wrapped1, wrapped2,
        "ECIES uses ephemeral keys, output should differ"
    );

    // Both should unwrap to same plaintext
    let unwrapped1 = ecies::unwrap_key(&wrapped1, &private_key).unwrap();
    let unwrapped2 = ecies::unwrap_key(&wrapped2, &private_key).unwrap();
    assert_eq!(unwrapped1, plaintext);
    assert_eq!(unwrapped2, plaintext);
}

#[test]
fn ecies_wrong_private_key_fails() {
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    let plaintext = b"test data";

    let wrapped = ecies::wrap_key(plaintext, &public_key).unwrap();

    // Use a different private key
    let wrong_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap(); // 32 bytes but wrong key
    let result = ecies::unwrap_key(&wrapped, &wrong_key);
    assert!(result.is_err());
}

#[test]
fn ecies_invalid_public_key_size_fails() {
    let short_key = vec![0u8; 33]; // compressed key size, wrong
    let result = ecies::wrap_key(b"test", &short_key);
    assert!(result.is_err());
}

#[test]
fn ecies_invalid_public_key_prefix_fails() {
    let mut bad_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    bad_key[0] = 0x02; // change to compressed prefix
    let result = ecies::wrap_key(b"test", &bad_key);
    assert!(result.is_err());
}

#[test]
fn ecies_invalid_private_key_size_fails() {
    let short_key = vec![0u8; 16]; // too short
    let wrapped = hex::decode(ECIES_TS_WRAPPED).unwrap();
    let result = ecies::unwrap_key(&wrapped, &short_key);
    assert!(result.is_err());
}

#[test]
fn ecies_tampered_ciphertext_fails() {
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();

    let mut wrapped = ecies::wrap_key(b"test data", &public_key).unwrap();
    let mid = wrapped.len() / 2;
    wrapped[mid] ^= 0xff;

    let result = ecies::unwrap_key(&wrapped, &private_key);
    assert!(result.is_err());
}

// ============================================================
// Folder Metadata Tests
// ============================================================

#[test]
fn folder_metadata_encrypt_decrypt_roundtrip() {
    let key = utils::generate_file_key();
    let metadata = FolderMetadata {
        version: "v1".to_string(),
        children: vec![
            FolderChild::File(FileEntry {
                id: "file-001".to_string(),
                name: "test.txt".to_string(),
                cid: "bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4".to_string(),
                file_key_encrypted: "deadbeef".to_string(),
                file_iv: "aabbccdd".to_string(),
                size: 1024,
                created_at: 1700000000000,
                modified_at: 1700000000000,
                encryption_mode: "GCM".to_string(),
            }),
            FolderChild::Folder(FolderEntry {
                id: "folder-001".to_string(),
                name: "documents".to_string(),
                ipns_name: "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgq"
                    .to_string(),
                folder_key_encrypted: "cafebabe".to_string(),
                ipns_private_key_encrypted: "abcd1234".to_string(),
                created_at: 1700000000000,
                modified_at: 1700000000000,
            }),
        ],
    };

    let sealed = encrypt_folder_metadata(&metadata, &key).unwrap();
    let decrypted = decrypt_folder_metadata(&sealed, &key).unwrap();

    assert_eq!(decrypted.version, "v1");
    assert_eq!(decrypted.children.len(), 2);
}

#[test]
fn folder_metadata_camel_case_serialization() {
    let file_entry = FileEntry {
        id: "f1".to_string(),
        name: "test.txt".to_string(),
        cid: "bafy123".to_string(),
        file_key_encrypted: "abc".to_string(),
        file_iv: "def".to_string(),
        size: 100,
        created_at: 1000,
        modified_at: 2000,
        encryption_mode: "GCM".to_string(),
    };

    let json = serde_json::to_string(&file_entry).unwrap();
    // Verify camelCase field names
    assert!(json.contains("fileKeyEncrypted"), "Must use camelCase: fileKeyEncrypted");
    assert!(json.contains("fileIv"), "Must use camelCase: fileIv");
    assert!(json.contains("encryptionMode"), "Must use camelCase: encryptionMode");
    assert!(json.contains("createdAt"), "Must use camelCase: createdAt");
    assert!(json.contains("modifiedAt"), "Must use camelCase: modifiedAt");
    // Should NOT contain snake_case
    assert!(!json.contains("file_key_encrypted"));
    assert!(!json.contains("file_iv"));
    assert!(!json.contains("encryption_mode"));
}

#[test]
fn folder_entry_camel_case_serialization() {
    let folder_entry = FolderEntry {
        id: "d1".to_string(),
        name: "docs".to_string(),
        ipns_name: "k51...".to_string(),
        folder_key_encrypted: "abc".to_string(),
        ipns_private_key_encrypted: "xyz".to_string(),
        created_at: 1000,
        modified_at: 2000,
    };

    let json = serde_json::to_string(&folder_entry).unwrap();
    assert!(json.contains("ipnsName"), "Must use camelCase: ipnsName");
    assert!(
        json.contains("folderKeyEncrypted"),
        "Must use camelCase: folderKeyEncrypted"
    );
    assert!(
        json.contains("ipnsPrivateKeyEncrypted"),
        "Must use camelCase: ipnsPrivateKeyEncrypted"
    );
    assert!(json.contains("createdAt"), "Must use camelCase: createdAt");
    assert!(json.contains("modifiedAt"), "Must use camelCase: modifiedAt");
    // Should NOT contain snake_case
    assert!(!json.contains("ipns_name"));
    assert!(!json.contains("folder_key_encrypted"));
    assert!(!json.contains("ipns_private_key_encrypted"));
}

#[test]
fn folder_metadata_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let metadata = FolderMetadata {
        version: "v1".to_string(),
        children: vec![],
    };

    let sealed = encrypt_folder_metadata(&metadata, &key1).unwrap();
    let result = decrypt_folder_metadata(&sealed, &key2);
    assert!(result.is_err());
}

// ============================================================
// IPNS Record Creation Tests
// ============================================================

#[test]
fn ipns_record_creation() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(
        &pk,
        "/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4",
        42,
        86400000,
    )
    .unwrap();

    assert_eq!(
        record.value,
        "/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4"
    );
    assert_eq!(record.sequence, 42);
    assert_eq!(record.validity_type, 0);
    assert_eq!(record.signature_v1.len(), 64);
    assert_eq!(record.signature_v2.len(), 64);
    assert!(!record.data.is_empty());
    assert_eq!(record.public_key.len(), 32);
}

#[test]
fn ipns_record_has_correct_public_key() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let expected_public = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 0, 86400000).unwrap();
    assert_eq!(record.public_key, expected_public);
}

#[test]
fn ipns_record_validity_is_future() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 0, 86400000).unwrap();

    // Validity should contain a year >= 2026
    assert!(
        record.validity.starts_with("20"),
        "Validity should be a future timestamp"
    );
    assert!(
        record.validity.ends_with('Z'),
        "Validity should end with Z (UTC)"
    );
    assert!(
        record.validity.contains('T'),
        "Validity should be RFC3339 format"
    );
}

#[test]
fn ipns_record_signature_v2_is_deterministic_for_same_cbor() {
    // Since the CBOR data includes a timestamp, the signature will differ
    // between calls. But for the SAME CBOR data, the signature must be deterministic.
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.clone().try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 1, 86400000).unwrap();

    // Re-sign the same CBOR data manually to verify determinism
    let prefix = b"ipns-signature:";
    let mut data_to_sign = Vec::new();
    data_to_sign.extend_from_slice(prefix);
    data_to_sign.extend_from_slice(&record.data);

    let sig = ed25519::sign_ed25519(&data_to_sign, &private_key).unwrap();
    assert_eq!(
        sig, record.signature_v2,
        "V2 signature must be deterministic"
    );
}

#[test]
fn ipns_record_cbor_data_contains_expected_fields() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();
    let value = "/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4";

    let record = ipns::create_ipns_record(&pk, value, 42, 86400000).unwrap();

    // The CBOR data should decode to a map with TTL, Value, Sequence, Validity, ValidityType
    let cbor_value: ciborium::Value =
        ciborium::from_reader(std::io::Cursor::new(&record.data)).unwrap();

    if let ciborium::Value::Map(entries) = cbor_value {
        assert_eq!(entries.len(), 5, "CBOR map should have 5 fields");

        // Check field names exist
        let keys: Vec<String> = entries
            .iter()
            .filter_map(|(k, _)| {
                if let ciborium::Value::Text(s) = k {
                    Some(s.clone())
                } else {
                    None
                }
            })
            .collect();

        assert!(keys.contains(&"TTL".to_string()));
        assert!(keys.contains(&"Value".to_string()));
        assert!(keys.contains(&"Sequence".to_string()));
        assert!(keys.contains(&"Validity".to_string()));
        assert!(keys.contains(&"ValidityType".to_string()));
    } else {
        panic!("CBOR data should be a map");
    }
}

// ============================================================
// IPNS Record Marshaling Tests
// ============================================================

#[test]
fn ipns_marshal_produces_protobuf() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 0, 86400000).unwrap();
    let marshaled = ipns::marshal_ipns_record(&record).unwrap();

    assert!(!marshaled.is_empty());
    // Protobuf: first byte should be a field tag
    // Field 1 (Value), wire type 2 (length-delimited) => tag = 0x0a
    assert_eq!(
        marshaled[0], 0x0a,
        "Protobuf should start with field 1 tag"
    );
}

#[test]
fn ipns_marshal_contains_all_fields() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 7, 86400000).unwrap();
    let marshaled = ipns::marshal_ipns_record(&record).unwrap();

    // The marshaled bytes should contain the value string
    let value_bytes = b"/ipfs/bafy123";
    let marshaled_contains_value = marshaled
        .windows(value_bytes.len())
        .any(|w| w == value_bytes);
    assert!(
        marshaled_contains_value,
        "Marshaled protobuf should contain the value"
    );
}

// ============================================================
// IPNS Name Derivation Cross-Language Test
// ============================================================

/// Expected IPNS name from TypeScript deriveIpnsName.
const IPNS_EXPECTED_NAME: &str =
    "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgq";

#[test]
fn ipns_name_cross_language() {
    let public_key = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let pk: [u8; 32] = public_key.try_into().unwrap();

    let name = ipns::derive_ipns_name(&pk).unwrap();
    assert_eq!(
        name, IPNS_EXPECTED_NAME,
        "Rust IPNS name must match TypeScript deriveIpnsName output"
    );
}

#[test]
fn ipns_name_is_deterministic() {
    let public_key = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let pk: [u8; 32] = public_key.try_into().unwrap();

    let name1 = ipns::derive_ipns_name(&pk).unwrap();
    let name2 = ipns::derive_ipns_name(&pk).unwrap();
    assert_eq!(name1, name2, "IPNS name derivation must be deterministic");
}

#[test]
fn ipns_name_starts_with_k51() {
    let (public_key, _) = ed25519::generate_ed25519_keypair();
    let pk: [u8; 32] = public_key.try_into().unwrap();

    let name = ipns::derive_ipns_name(&pk).unwrap();
    assert!(
        name.starts_with("k51"),
        "IPNS name should start with k51 (base36 CIDv1)"
    );
}

#[test]
fn ipns_name_different_keys_produce_different_names() {
    let (pk1, _) = ed25519::generate_ed25519_keypair();
    let (pk2, _) = ed25519::generate_ed25519_keypair();
    let pk1: [u8; 32] = pk1.try_into().unwrap();
    let pk2: [u8; 32] = pk2.try_into().unwrap();

    let name1 = ipns::derive_ipns_name(&pk1).unwrap();
    let name2 = ipns::derive_ipns_name(&pk2).unwrap();
    assert_ne!(name1, name2, "Different keys should produce different names");
}

// ============================================================
// Utility Tests
// ============================================================

#[test]
fn hex_roundtrip() {
    let original = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];
    let hex_str = utils::bytes_to_hex(&original);
    let decoded = utils::hex_to_bytes(&hex_str).unwrap();
    assert_eq!(decoded, original);
}

#[test]
fn generate_file_key_is_32_bytes() {
    let key = utils::generate_file_key();
    assert_eq!(key.len(), 32);
}

#[test]
fn generate_iv_is_12_bytes() {
    let iv = utils::generate_iv();
    assert_eq!(iv.len(), 12);
}

#[test]
fn generate_random_bytes_correct_length() {
    for len in [0, 1, 16, 32, 64, 1024] {
        let bytes = utils::generate_random_bytes(len);
        assert_eq!(bytes.len(), len);
    }
}

#[test]
fn clear_bytes_zeros_data() {
    let mut data = vec![0xff; 32];
    utils::clear_bytes(&mut data);
    assert!(data.iter().all(|&b| b == 0));
}
