//! Cross-language test vectors for crypto operations.
//!
//! All test vectors were generated by `generate-test-vectors.mjs` using the
//! @cipherbox/crypto TypeScript module. The Rust implementations must produce
//! byte-identical output for deterministic operations (AES with fixed IV/key,
//! Ed25519 signatures, IPNS name derivation).

use super::aes;
use super::aes_ctr;
use super::ecies;
use super::ed25519;
use super::folder::{
    decrypt_any_folder_metadata, decrypt_file_metadata, decrypt_folder_metadata,
    encrypt_file_metadata, encrypt_folder_metadata, AnyFolderMetadata, FileEntry, FileMetadata,
    FilePointer, FolderChild, FolderChildV2, FolderEntry, FolderMetadata, FolderMetadataV2,
};
use super::hkdf;
use super::ipns;
use super::utils;

// ============================================================
// AES-256-GCM Cross-Language Test Vectors
// ============================================================

/// Fixed AES key from TypeScript test vector generation.
const AES_TEST_KEY: &str = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
/// Fixed AES IV from TypeScript test vector generation.
const AES_TEST_IV: &str = "aabbccddeeff00112233aabb";
/// Expected ciphertext (with 16-byte tag) from TypeScript encryptAesGcm.
const AES_EXPECTED_CIPHERTEXT: &str =
    "196a1416ae4cf2abbd0bb8bdd7dd16be5527207b3c04f9e0a0acf4274fdccbdd5e";

#[test]
fn aes_cross_language_encrypt() {
    let key_bytes = hex::decode(AES_TEST_KEY).unwrap();
    let iv_bytes = hex::decode(AES_TEST_IV).unwrap();
    let plaintext = b"Hello, CipherBox!";

    let key: [u8; 32] = key_bytes.try_into().unwrap();
    let iv: [u8; 12] = iv_bytes.try_into().unwrap();

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    assert_eq!(
        hex::encode(&ciphertext),
        AES_EXPECTED_CIPHERTEXT,
        "Rust AES-256-GCM ciphertext must match TypeScript output"
    );
}

#[test]
fn aes_cross_language_decrypt() {
    let key_bytes = hex::decode(AES_TEST_KEY).unwrap();
    let iv_bytes = hex::decode(AES_TEST_IV).unwrap();
    let ciphertext = hex::decode(AES_EXPECTED_CIPHERTEXT).unwrap();

    let key: [u8; 32] = key_bytes.try_into().unwrap();
    let iv: [u8; 12] = iv_bytes.try_into().unwrap();

    let plaintext = aes::decrypt_aes_gcm(&ciphertext, &key, &iv).unwrap();
    assert_eq!(
        String::from_utf8(plaintext).unwrap(),
        "Hello, CipherBox!",
        "Rust must decrypt TypeScript ciphertext correctly"
    );
}

#[test]
fn aes_roundtrip() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Round-trip test data for AES-256-GCM";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    let decrypted = aes::decrypt_aes_gcm(&ciphertext, &key, &iv).unwrap();

    assert_eq!(decrypted, plaintext);
}

#[test]
fn aes_ciphertext_includes_tag() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Test";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    // ciphertext = plaintext + 16-byte auth tag
    assert_eq!(ciphertext.len(), plaintext.len() + aes::AES_TAG_SIZE);
}

#[test]
fn aes_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Secret data";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key1, &iv).unwrap();
    let result = aes::decrypt_aes_gcm(&ciphertext, &key2, &iv);
    assert!(result.is_err());
}

#[test]
fn aes_tampered_ciphertext_fails() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"Authenticated data";

    let mut ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    ciphertext[0] ^= 0xff;

    let result = aes::decrypt_aes_gcm(&ciphertext, &key, &iv);
    assert!(result.is_err());
}

#[test]
fn aes_empty_plaintext() {
    let key = utils::generate_file_key();
    let iv = utils::generate_iv();
    let plaintext = b"";

    let ciphertext = aes::encrypt_aes_gcm(plaintext, &key, &iv).unwrap();
    assert_eq!(ciphertext.len(), aes::AES_TAG_SIZE);

    let decrypted = aes::decrypt_aes_gcm(&ciphertext, &key, &iv).unwrap();
    assert!(decrypted.is_empty());
}

// ============================================================
// AES Seal/Unseal Tests
// ============================================================

#[test]
fn seal_unseal_roundtrip() {
    let key = utils::generate_file_key();
    let plaintext = b"Hello, CipherBox!";

    let sealed = aes::seal_aes_gcm(plaintext, &key).unwrap();
    let unsealed = aes::unseal_aes_gcm(&sealed, &key).unwrap();

    assert_eq!(unsealed, plaintext);
}

#[test]
fn seal_format_iv_ciphertext_tag() {
    let key = utils::generate_file_key();
    let plaintext = b"Test";

    let sealed = aes::seal_aes_gcm(plaintext, &key).unwrap();
    // Sealed = IV (12) + ciphertext (plaintext.len()) + tag (16)
    assert_eq!(
        sealed.len(),
        aes::AES_IV_SIZE + plaintext.len() + aes::AES_TAG_SIZE
    );
}

#[test]
fn seal_random_iv_produces_different_output() {
    let key = utils::generate_file_key();
    let plaintext = b"Same plaintext";

    let sealed1 = aes::seal_aes_gcm(plaintext, &key).unwrap();
    let sealed2 = aes::seal_aes_gcm(plaintext, &key).unwrap();

    assert_ne!(sealed1, sealed2, "Random IV should produce different sealed output");

    // But both unseal to same plaintext
    let unsealed1 = aes::unseal_aes_gcm(&sealed1, &key).unwrap();
    let unsealed2 = aes::unseal_aes_gcm(&sealed2, &key).unwrap();
    assert_eq!(unsealed1, plaintext);
    assert_eq!(unsealed2, plaintext);
}

#[test]
fn unseal_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let plaintext = b"Secret data";

    let sealed = aes::seal_aes_gcm(plaintext, &key1).unwrap();
    let result = aes::unseal_aes_gcm(&sealed, &key2);
    assert!(result.is_err());
}

#[test]
fn unseal_too_short_fails() {
    let key = utils::generate_file_key();
    let short_data = vec![0u8; 27]; // less than IV(12) + tag(16) = 28
    let result = aes::unseal_aes_gcm(&short_data, &key);
    assert!(result.is_err());
}

#[test]
fn seal_empty_plaintext() {
    let key = utils::generate_file_key();
    let plaintext = b"";

    let sealed = aes::seal_aes_gcm(plaintext, &key).unwrap();
    assert_eq!(sealed.len(), aes::AES_IV_SIZE + aes::AES_TAG_SIZE);

    let unsealed = aes::unseal_aes_gcm(&sealed, &key).unwrap();
    assert!(unsealed.is_empty());
}

// ============================================================
// Ed25519 Cross-Language Test Vectors
// ============================================================

/// Fixed Ed25519 private key (from RFC 8032 test vector).
const ED25519_TEST_PRIVATE_KEY: &str =
    "9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60";
/// Expected public key from the private key above.
const ED25519_TEST_PUBLIC_KEY: &str =
    "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a";
/// Expected signature for "Hello, CipherBox!" with the above key.
const ED25519_TEST_SIGNATURE: &str =
    "a4cc4f358e30c8630839e457bf9a27da2062b3c6ca588b3947a9085d909d807c9be05a6a0b69e9fdc5e5b6503e79c04b1bdd92921350559e35376b78f9ca5601";

#[test]
fn ed25519_cross_language_public_key() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let expected_public = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();

    let public_key = ed25519::get_public_key(&private_key).unwrap();
    assert_eq!(
        public_key, expected_public,
        "Rust Ed25519 public key derivation must match TypeScript"
    );
}

#[test]
fn ed25519_cross_language_signature() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let message = b"Hello, CipherBox!";

    let signature = ed25519::sign_ed25519(message, &private_key).unwrap();
    assert_eq!(
        hex::encode(&signature),
        ED25519_TEST_SIGNATURE,
        "Rust Ed25519 signature must be byte-identical to TypeScript (deterministic)"
    );
}

#[test]
fn ed25519_cross_language_verify() {
    let public_key = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let message = b"Hello, CipherBox!";
    let signature = hex::decode(ED25519_TEST_SIGNATURE).unwrap();

    let valid = ed25519::verify_ed25519(message, &signature, &public_key);
    assert!(valid, "TypeScript Ed25519 signature must verify in Rust");
}

#[test]
fn ed25519_deterministic_signatures() {
    let (_, private_key) = ed25519::generate_ed25519_keypair();
    let message = b"deterministic test";

    let sig1 = ed25519::sign_ed25519(message, &private_key).unwrap();
    let sig2 = ed25519::sign_ed25519(message, &private_key).unwrap();
    assert_eq!(sig1, sig2, "Ed25519 signatures must be deterministic");
}

#[test]
fn ed25519_sign_verify_roundtrip() {
    let (public_key, private_key) = ed25519::generate_ed25519_keypair();
    let message = b"Round-trip test for Ed25519";

    let signature = ed25519::sign_ed25519(message, &private_key).unwrap();
    assert_eq!(signature.len(), 64);

    let valid = ed25519::verify_ed25519(message, &signature, &public_key);
    assert!(valid);
}

#[test]
fn ed25519_wrong_public_key_fails() {
    let (_, private_key1) = ed25519::generate_ed25519_keypair();
    let (public_key2, _) = ed25519::generate_ed25519_keypair();
    let message = b"signed by keypair1";

    let signature = ed25519::sign_ed25519(message, &private_key1).unwrap();
    let valid = ed25519::verify_ed25519(message, &signature, &public_key2);
    assert!(!valid);
}

#[test]
fn ed25519_modified_message_fails() {
    let (public_key, private_key) = ed25519::generate_ed25519_keypair();
    let original = b"original message";
    let modified = b"modified message";

    let signature = ed25519::sign_ed25519(original, &private_key).unwrap();
    let valid = ed25519::verify_ed25519(modified, &signature, &public_key);
    assert!(!valid);
}

#[test]
fn ed25519_invalid_key_size_fails() {
    let short_key = vec![0u8; 16];
    let result = ed25519::sign_ed25519(b"test", &short_key);
    assert!(result.is_err());
}

#[test]
fn ed25519_invalid_signature_returns_false() {
    let (public_key, _) = ed25519::generate_ed25519_keypair();
    let bad_sig = vec![0u8; 32]; // wrong size
    assert!(!ed25519::verify_ed25519(b"test", &bad_sig, &public_key));
}

#[test]
fn ed25519_invalid_public_key_returns_false() {
    let bad_pub = vec![0u8; 16]; // wrong size
    let sig = vec![0u8; 64];
    assert!(!ed25519::verify_ed25519(b"test", &sig, &bad_pub));
}

// ============================================================
// ECIES Cross-Language Test Vectors
// ============================================================

/// Fixed secp256k1 private key for ECIES tests.
const ECIES_TEST_PRIVATE_KEY: &str =
    "c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721";
/// Corresponding uncompressed public key (65 bytes, 0x04 prefix).
const ECIES_TEST_PUBLIC_KEY: &str =
    "042c8c31fc9f990c6b55e3865a184a4ce50e09481f2eaeb3e60ec1cea13a6ae64564b95e4fdb6948c0386e189b006a29f686769b011704275e4459822dc3328085";
/// Plaintext for ECIES test.
const ECIES_TEST_PLAINTEXT: &str =
    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
/// TypeScript-wrapped ciphertext for Rust to unwrap.
const ECIES_TS_WRAPPED: &str =
    "04d8fffb3faadd4a9977c520a6627f3ff4fa0f8350032398bb1bfa7c0bdff2661212743ee8fec655eb145cefc7fb1a6d52f6062f7ce8f16666e080af74685294e1218732428593e85e92dc42580fcc6e0dbae6237813e9961f8fdd8409e0592d7442ac41d85539dac237cc344f1766e41532b7ea90274a83da7e40f4733e21a022";

#[test]
fn ecies_unwrap_typescript_wrapped() {
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let wrapped = hex::decode(ECIES_TS_WRAPPED).unwrap();
    let expected_plaintext = hex::decode(ECIES_TEST_PLAINTEXT).unwrap();

    let unwrapped = ecies::unwrap_key(&wrapped, &private_key).unwrap();
    assert_eq!(
        unwrapped, expected_plaintext,
        "Rust must decrypt TypeScript ECIES-wrapped data"
    );
}

#[test]
fn ecies_roundtrip() {
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    let plaintext = hex::decode(ECIES_TEST_PLAINTEXT).unwrap();

    let wrapped = ecies::wrap_key(&plaintext, &public_key).unwrap();
    let unwrapped = ecies::unwrap_key(&wrapped, &private_key).unwrap();
    assert_eq!(unwrapped, plaintext);
}

#[test]
fn ecies_ephemeral_key_produces_different_output() {
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let plaintext = hex::decode(ECIES_TEST_PLAINTEXT).unwrap();

    let wrapped1 = ecies::wrap_key(&plaintext, &public_key).unwrap();
    let wrapped2 = ecies::wrap_key(&plaintext, &public_key).unwrap();
    assert_ne!(
        wrapped1, wrapped2,
        "ECIES uses ephemeral keys, output should differ"
    );

    // Both should unwrap to same plaintext
    let unwrapped1 = ecies::unwrap_key(&wrapped1, &private_key).unwrap();
    let unwrapped2 = ecies::unwrap_key(&wrapped2, &private_key).unwrap();
    assert_eq!(unwrapped1, plaintext);
    assert_eq!(unwrapped2, plaintext);
}

#[test]
fn ecies_wrong_private_key_fails() {
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    let plaintext = b"test data";

    let wrapped = ecies::wrap_key(plaintext, &public_key).unwrap();

    // Use a different private key
    let wrong_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap(); // 32 bytes but wrong key
    let result = ecies::unwrap_key(&wrapped, &wrong_key);
    assert!(result.is_err());
}

#[test]
fn ecies_invalid_public_key_size_fails() {
    let short_key = vec![0u8; 33]; // compressed key size, wrong
    let result = ecies::wrap_key(b"test", &short_key);
    assert!(result.is_err());
}

#[test]
fn ecies_invalid_public_key_prefix_fails() {
    let mut bad_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();
    bad_key[0] = 0x02; // change to compressed prefix
    let result = ecies::wrap_key(b"test", &bad_key);
    assert!(result.is_err());
}

#[test]
fn ecies_invalid_private_key_size_fails() {
    let short_key = vec![0u8; 16]; // too short
    let wrapped = hex::decode(ECIES_TS_WRAPPED).unwrap();
    let result = ecies::unwrap_key(&wrapped, &short_key);
    assert!(result.is_err());
}

#[test]
fn ecies_tampered_ciphertext_fails() {
    let private_key = hex::decode(ECIES_TEST_PRIVATE_KEY).unwrap();
    let public_key = hex::decode(ECIES_TEST_PUBLIC_KEY).unwrap();

    let mut wrapped = ecies::wrap_key(b"test data", &public_key).unwrap();
    let mid = wrapped.len() / 2;
    wrapped[mid] ^= 0xff;

    let result = ecies::unwrap_key(&wrapped, &private_key);
    assert!(result.is_err());
}

// ============================================================
// Folder Metadata Tests
// ============================================================

#[test]
fn folder_metadata_encrypt_decrypt_roundtrip() {
    let key = utils::generate_file_key();
    let metadata = FolderMetadata {
        version: "v1".to_string(),
        children: vec![
            FolderChild::File(FileEntry {
                id: "file-001".to_string(),
                name: "test.txt".to_string(),
                cid: "bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4".to_string(),
                file_key_encrypted: "deadbeef".to_string(),
                file_iv: "aabbccdd".to_string(),
                size: 1024,
                created_at: 1700000000000,
                modified_at: 1700000000000,
                encryption_mode: "GCM".to_string(),
            }),
            FolderChild::Folder(FolderEntry {
                id: "folder-001".to_string(),
                name: "documents".to_string(),
                ipns_name: "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgq"
                    .to_string(),
                folder_key_encrypted: "cafebabe".to_string(),
                ipns_private_key_encrypted: "abcd1234".to_string(),
                created_at: 1700000000000,
                modified_at: 1700000000000,
            }),
        ],
    };

    let sealed = encrypt_folder_metadata(&metadata, &key).unwrap();
    let decrypted = decrypt_folder_metadata(&sealed, &key).unwrap();

    assert_eq!(decrypted.version, "v1");
    assert_eq!(decrypted.children.len(), 2);
}

#[test]
fn folder_metadata_camel_case_serialization() {
    let file_entry = FileEntry {
        id: "f1".to_string(),
        name: "test.txt".to_string(),
        cid: "bafy123".to_string(),
        file_key_encrypted: "abc".to_string(),
        file_iv: "def".to_string(),
        size: 100,
        created_at: 1000,
        modified_at: 2000,
        encryption_mode: "GCM".to_string(),
    };

    let json = serde_json::to_string(&file_entry).unwrap();
    // Verify camelCase field names
    assert!(json.contains("fileKeyEncrypted"), "Must use camelCase: fileKeyEncrypted");
    assert!(json.contains("fileIv"), "Must use camelCase: fileIv");
    assert!(json.contains("encryptionMode"), "Must use camelCase: encryptionMode");
    assert!(json.contains("createdAt"), "Must use camelCase: createdAt");
    assert!(json.contains("modifiedAt"), "Must use camelCase: modifiedAt");
    // Should NOT contain snake_case
    assert!(!json.contains("file_key_encrypted"));
    assert!(!json.contains("file_iv"));
    assert!(!json.contains("encryption_mode"));
}

#[test]
fn folder_entry_camel_case_serialization() {
    let folder_entry = FolderEntry {
        id: "d1".to_string(),
        name: "docs".to_string(),
        ipns_name: "k51...".to_string(),
        folder_key_encrypted: "abc".to_string(),
        ipns_private_key_encrypted: "xyz".to_string(),
        created_at: 1000,
        modified_at: 2000,
    };

    let json = serde_json::to_string(&folder_entry).unwrap();
    assert!(json.contains("ipnsName"), "Must use camelCase: ipnsName");
    assert!(
        json.contains("folderKeyEncrypted"),
        "Must use camelCase: folderKeyEncrypted"
    );
    assert!(
        json.contains("ipnsPrivateKeyEncrypted"),
        "Must use camelCase: ipnsPrivateKeyEncrypted"
    );
    assert!(json.contains("createdAt"), "Must use camelCase: createdAt");
    assert!(json.contains("modifiedAt"), "Must use camelCase: modifiedAt");
    // Should NOT contain snake_case
    assert!(!json.contains("ipns_name"));
    assert!(!json.contains("folder_key_encrypted"));
    assert!(!json.contains("ipns_private_key_encrypted"));
}

#[test]
fn folder_metadata_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let metadata = FolderMetadata {
        version: "v1".to_string(),
        children: vec![],
    };

    let sealed = encrypt_folder_metadata(&metadata, &key1).unwrap();
    let result = decrypt_folder_metadata(&sealed, &key2);
    assert!(result.is_err());
}

// ============================================================
// IPNS Record Creation Tests
// ============================================================

#[test]
fn ipns_record_creation() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(
        &pk,
        "/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4",
        42,
        86400000,
    )
    .unwrap();

    assert_eq!(
        record.value,
        "/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4"
    );
    assert_eq!(record.sequence, 42);
    assert_eq!(record.validity_type, 0);
    assert_eq!(record.signature_v1.len(), 64);
    assert_eq!(record.signature_v2.len(), 64);
    assert!(!record.data.is_empty());
    assert_eq!(record.public_key.len(), 32);
}

#[test]
fn ipns_record_has_correct_public_key() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let expected_public = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 0, 86400000).unwrap();
    assert_eq!(record.public_key, expected_public);
}

#[test]
fn ipns_record_validity_is_future() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 0, 86400000).unwrap();

    // Validity should contain a year >= 2026
    assert!(
        record.validity.starts_with("20"),
        "Validity should be a future timestamp"
    );
    assert!(
        record.validity.ends_with('Z'),
        "Validity should end with Z (UTC)"
    );
    assert!(
        record.validity.contains('T'),
        "Validity should be RFC3339 format"
    );
}

#[test]
fn ipns_record_signature_v2_is_deterministic_for_same_cbor() {
    // Since the CBOR data includes a timestamp, the signature will differ
    // between calls. But for the SAME CBOR data, the signature must be deterministic.
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.clone().try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 1, 86400000).unwrap();

    // Re-sign the same CBOR data manually to verify determinism
    let prefix = b"ipns-signature:";
    let mut data_to_sign = Vec::new();
    data_to_sign.extend_from_slice(prefix);
    data_to_sign.extend_from_slice(&record.data);

    let sig = ed25519::sign_ed25519(&data_to_sign, &private_key).unwrap();
    assert_eq!(
        sig, record.signature_v2,
        "V2 signature must be deterministic"
    );
}

#[test]
fn ipns_record_cbor_data_contains_expected_fields() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();
    let value = "/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4";

    let record = ipns::create_ipns_record(&pk, value, 42, 86400000).unwrap();

    // The CBOR data should decode to a map with TTL, Value, Sequence, Validity, ValidityType
    let cbor_value: ciborium::Value =
        ciborium::from_reader(std::io::Cursor::new(&record.data)).unwrap();

    if let ciborium::Value::Map(entries) = cbor_value {
        assert_eq!(entries.len(), 5, "CBOR map should have 5 fields");

        // Check field names exist
        let keys: Vec<String> = entries
            .iter()
            .filter_map(|(k, _)| {
                if let ciborium::Value::Text(s) = k {
                    Some(s.clone())
                } else {
                    None
                }
            })
            .collect();

        assert!(keys.contains(&"TTL".to_string()));
        assert!(keys.contains(&"Value".to_string()));
        assert!(keys.contains(&"Sequence".to_string()));
        assert!(keys.contains(&"Validity".to_string()));
        assert!(keys.contains(&"ValidityType".to_string()));
    } else {
        panic!("CBOR data should be a map");
    }
}

// ============================================================
// IPNS Record Marshaling Tests
// ============================================================

#[test]
fn ipns_marshal_produces_protobuf() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 0, 86400000).unwrap();
    let marshaled = ipns::marshal_ipns_record(&record).unwrap();

    assert!(!marshaled.is_empty());
    // Protobuf: first byte should be a field tag
    // Field 1 (Value), wire type 2 (length-delimited) => tag = 0x0a
    assert_eq!(
        marshaled[0], 0x0a,
        "Protobuf should start with field 1 tag"
    );
}

#[test]
fn ipns_marshal_contains_all_fields() {
    let private_key = hex::decode(ED25519_TEST_PRIVATE_KEY).unwrap();
    let pk: [u8; 32] = private_key.try_into().unwrap();

    let record = ipns::create_ipns_record(&pk, "/ipfs/bafy123", 7, 86400000).unwrap();
    let marshaled = ipns::marshal_ipns_record(&record).unwrap();

    // The marshaled bytes should contain the value string
    let value_bytes = b"/ipfs/bafy123";
    let marshaled_contains_value = marshaled
        .windows(value_bytes.len())
        .any(|w| w == value_bytes);
    assert!(
        marshaled_contains_value,
        "Marshaled protobuf should contain the value"
    );
}

// ============================================================
// IPNS Name Derivation Cross-Language Test
// ============================================================

/// Expected IPNS name from TypeScript deriveIpnsName.
const IPNS_EXPECTED_NAME: &str =
    "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgq";

#[test]
fn ipns_name_cross_language() {
    let public_key = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let pk: [u8; 32] = public_key.try_into().unwrap();

    let name = ipns::derive_ipns_name(&pk).unwrap();
    assert_eq!(
        name, IPNS_EXPECTED_NAME,
        "Rust IPNS name must match TypeScript deriveIpnsName output"
    );
}

#[test]
fn ipns_name_is_deterministic() {
    let public_key = hex::decode(ED25519_TEST_PUBLIC_KEY).unwrap();
    let pk: [u8; 32] = public_key.try_into().unwrap();

    let name1 = ipns::derive_ipns_name(&pk).unwrap();
    let name2 = ipns::derive_ipns_name(&pk).unwrap();
    assert_eq!(name1, name2, "IPNS name derivation must be deterministic");
}

#[test]
fn ipns_name_starts_with_k51() {
    let (public_key, _) = ed25519::generate_ed25519_keypair();
    let pk: [u8; 32] = public_key.try_into().unwrap();

    let name = ipns::derive_ipns_name(&pk).unwrap();
    assert!(
        name.starts_with("k51"),
        "IPNS name should start with k51 (base36 CIDv1)"
    );
}

#[test]
fn ipns_name_different_keys_produce_different_names() {
    let (pk1, _) = ed25519::generate_ed25519_keypair();
    let (pk2, _) = ed25519::generate_ed25519_keypair();
    let pk1: [u8; 32] = pk1.try_into().unwrap();
    let pk2: [u8; 32] = pk2.try_into().unwrap();

    let name1 = ipns::derive_ipns_name(&pk1).unwrap();
    let name2 = ipns::derive_ipns_name(&pk2).unwrap();
    assert_ne!(name1, name2, "Different keys should produce different names");
}

// ============================================================
// Utility Tests
// ============================================================

#[test]
fn hex_roundtrip() {
    let original = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];
    let hex_str = utils::bytes_to_hex(&original);
    let decoded = utils::hex_to_bytes(&hex_str).unwrap();
    assert_eq!(decoded, original);
}

#[test]
fn generate_file_key_is_32_bytes() {
    let key = utils::generate_file_key();
    assert_eq!(key.len(), 32);
}

#[test]
fn generate_iv_is_12_bytes() {
    let iv = utils::generate_iv();
    assert_eq!(iv.len(), 12);
}

#[test]
fn generate_random_bytes_correct_length() {
    for len in [0, 1, 16, 32, 64, 1024] {
        let bytes = utils::generate_random_bytes(len);
        assert_eq!(bytes.len(), len);
    }
}

#[test]
fn clear_bytes_zeros_data() {
    let mut data = vec![0xff; 32];
    utils::clear_bytes(&mut data);
    assert!(data.iter().all(|&b| b == 0));
}

// ============================================================
// HKDF Derivation Tests
// ============================================================

/// A fixed 32-byte private key for HKDF tests.
const HKDF_TEST_KEY: [u8; 32] = [
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
    0x1f, 0x20,
];

#[test]
fn hkdf_vault_derivation_produces_k51_name() {
    let (priv_key, pub_key, ipns_name) = hkdf::derive_vault_ipns_keypair(&HKDF_TEST_KEY).unwrap();

    assert_eq!(priv_key.len(), 32, "Ed25519 private key should be 32 bytes");
    assert_eq!(pub_key.len(), 32, "Ed25519 public key should be 32 bytes");
    assert!(
        ipns_name.starts_with("k51"),
        "IPNS name should start with k51 (base36 CIDv1), got: {}",
        ipns_name
    );
}

#[test]
fn hkdf_vault_derivation_is_deterministic() {
    let (_, _, name1) = hkdf::derive_vault_ipns_keypair(&HKDF_TEST_KEY).unwrap();
    let (_, _, name2) = hkdf::derive_vault_ipns_keypair(&HKDF_TEST_KEY).unwrap();
    assert_eq!(name1, name2, "Same key should produce same IPNS name");
}

#[test]
fn hkdf_file_derivation_different_file_ids_produce_different_names() {
    let (_, _, name1) =
        hkdf::derive_file_ipns_keypair(&HKDF_TEST_KEY, "file-id-001-abcdef").unwrap();
    let (_, _, name2) =
        hkdf::derive_file_ipns_keypair(&HKDF_TEST_KEY, "file-id-002-ghijkl").unwrap();

    assert_ne!(name1, name2, "Different file IDs should produce different IPNS names");
    assert!(name1.starts_with("k51"));
    assert!(name2.starts_with("k51"));
}

#[test]
fn hkdf_file_derivation_same_file_id_is_deterministic() {
    let file_id = "test-file-id-1234567890";
    let (_, _, name1) = hkdf::derive_file_ipns_keypair(&HKDF_TEST_KEY, file_id).unwrap();
    let (_, _, name2) = hkdf::derive_file_ipns_keypair(&HKDF_TEST_KEY, file_id).unwrap();
    assert_eq!(name1, name2, "Same key + fileId should produce same IPNS name");
}

#[test]
fn hkdf_file_derivation_rejects_short_file_id() {
    let result = hkdf::derive_file_ipns_keypair(&HKDF_TEST_KEY, "short");
    assert!(result.is_err(), "File ID < 10 chars should fail");
}

#[test]
fn hkdf_registry_derivation_differs_from_vault() {
    let (_, _, vault_name) = hkdf::derive_vault_ipns_keypair(&HKDF_TEST_KEY).unwrap();
    let (_, _, registry_name) = hkdf::derive_registry_ipns_keypair(&HKDF_TEST_KEY).unwrap();

    assert_ne!(
        vault_name, registry_name,
        "Vault and registry should have different IPNS names (domain separation)"
    );
}

#[test]
fn hkdf_all_three_domains_produce_different_names() {
    let (_, _, vault_name) = hkdf::derive_vault_ipns_keypair(&HKDF_TEST_KEY).unwrap();
    let (_, _, file_name) =
        hkdf::derive_file_ipns_keypair(&HKDF_TEST_KEY, "file-id-001-abcdef").unwrap();
    let (_, _, registry_name) = hkdf::derive_registry_ipns_keypair(&HKDF_TEST_KEY).unwrap();

    assert_ne!(vault_name, file_name);
    assert_ne!(vault_name, registry_name);
    assert_ne!(file_name, registry_name);
}

// ============================================================
// AES-256-CTR Tests
// ============================================================

#[test]
fn aes_ctr_roundtrip() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = {
        let bytes = utils::generate_random_bytes(16);
        bytes.try_into().unwrap()
    };
    let plaintext = b"Hello, AES-256-CTR!";

    let ciphertext = aes_ctr::encrypt_aes_ctr(plaintext, &key, &iv).unwrap();
    assert_eq!(ciphertext.len(), plaintext.len(), "CTR output should be same size as input");

    let decrypted = aes_ctr::decrypt_aes_ctr(&ciphertext, &key, &iv).unwrap();
    assert_eq!(decrypted, plaintext);
}

#[test]
fn aes_ctr_roundtrip_large_data() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();
    let plaintext: Vec<u8> = (0..10_000).map(|i| (i % 256) as u8).collect();

    let ciphertext = aes_ctr::encrypt_aes_ctr(&plaintext, &key, &iv).unwrap();
    let decrypted = aes_ctr::decrypt_aes_ctr(&ciphertext, &key, &iv).unwrap();
    assert_eq!(decrypted, plaintext);
}

#[test]
fn aes_ctr_range_decrypt_start_zero() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();
    let plaintext: Vec<u8> = (0..256).map(|i| i as u8).collect();

    let ciphertext = aes_ctr::encrypt_aes_ctr(&plaintext, &key, &iv).unwrap();

    // Decrypt first 32 bytes
    let range_result =
        aes_ctr::decrypt_aes_ctr_range(&ciphertext, &key, &iv, 0, 31).unwrap();
    assert_eq!(range_result, &plaintext[0..32]);
}

#[test]
fn aes_ctr_range_decrypt_block_aligned() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();
    let plaintext: Vec<u8> = (0..256).map(|i| i as u8).collect();

    let ciphertext = aes_ctr::encrypt_aes_ctr(&plaintext, &key, &iv).unwrap();

    // Decrypt bytes 16..47 (block-aligned start)
    let range_result =
        aes_ctr::decrypt_aes_ctr_range(&ciphertext, &key, &iv, 16, 47).unwrap();
    assert_eq!(range_result, &plaintext[16..48]);
}

#[test]
fn aes_ctr_range_decrypt_mid_block() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();
    let plaintext: Vec<u8> = (0..256).map(|i| i as u8).collect();

    let ciphertext = aes_ctr::encrypt_aes_ctr(&plaintext, &key, &iv).unwrap();

    // Decrypt bytes 7..24 (mid-block start)
    let range_result =
        aes_ctr::decrypt_aes_ctr_range(&ciphertext, &key, &iv, 7, 24).unwrap();
    assert_eq!(range_result, &plaintext[7..25]);
}

#[test]
fn aes_ctr_range_decrypt_single_byte() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();
    let plaintext: Vec<u8> = (0..256).map(|i| i as u8).collect();

    let ciphertext = aes_ctr::encrypt_aes_ctr(&plaintext, &key, &iv).unwrap();

    // Decrypt single byte at offset 100
    let range_result =
        aes_ctr::decrypt_aes_ctr_range(&ciphertext, &key, &iv, 100, 100).unwrap();
    assert_eq!(range_result, &plaintext[100..101]);
}

#[test]
fn aes_ctr_range_decrypt_invalid_range_returns_error() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();
    let ciphertext = vec![0u8; 256];

    // start > end should fail
    let result = aes_ctr::decrypt_aes_ctr_range(&ciphertext, &key, &iv, 100, 50);
    assert!(result.is_err());
}

#[test]
fn aes_ctr_empty_data() {
    let key: [u8; 32] = utils::generate_file_key();
    let iv: [u8; 16] = utils::generate_random_bytes(16).try_into().unwrap();

    let ciphertext = aes_ctr::encrypt_aes_ctr(b"", &key, &iv).unwrap();
    assert!(ciphertext.is_empty(), "CTR of empty input should be empty");

    let decrypted = aes_ctr::decrypt_aes_ctr(&ciphertext, &key, &iv).unwrap();
    assert!(decrypted.is_empty());
}

// ============================================================
// v2 Folder Metadata Type Tests
// ============================================================

#[test]
fn v2_folder_metadata_deserialization_with_file_pointers() {
    let json = r#"{
        "version": "v2",
        "children": [
            {
                "type": "folder",
                "id": "folder-001",
                "name": "documents",
                "ipnsName": "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgq",
                "folderKeyEncrypted": "cafebabe",
                "ipnsPrivateKeyEncrypted": "abcd1234",
                "createdAt": 1700000000000,
                "modifiedAt": 1700000000000
            },
            {
                "type": "file",
                "id": "file-001",
                "name": "photo.jpg",
                "fileMetaIpnsName": "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgx",
                "createdAt": 1700000000000,
                "modifiedAt": 1700000000000
            }
        ]
    }"#;

    let metadata: FolderMetadataV2 = serde_json::from_str(json).unwrap();
    assert_eq!(metadata.version, "v2");
    assert_eq!(metadata.children.len(), 2);

    match &metadata.children[0] {
        FolderChildV2::Folder(f) => assert_eq!(f.name, "documents"),
        _ => panic!("First child should be a folder"),
    }
    match &metadata.children[1] {
        FolderChildV2::File(fp) => {
            assert_eq!(fp.name, "photo.jpg");
            assert_eq!(
                fp.file_meta_ipns_name,
                "k51qzi5uqu5dljtg5upm7x7ugan9lql3ewyknv4r4mhhkwzn8n7cnbd1unfwgx"
            );
        }
        _ => panic!("Second child should be a file pointer"),
    }
}

#[test]
fn file_pointer_camel_case_serialization() {
    let fp = FilePointer {
        id: "fp-001".to_string(),
        name: "test.mp4".to_string(),
        file_meta_ipns_name: "k51abc".to_string(),
        created_at: 1000,
        modified_at: 2000,
    };

    let json = serde_json::to_string(&fp).unwrap();
    assert!(json.contains("fileMetaIpnsName"), "Must use camelCase: fileMetaIpnsName");
    assert!(json.contains("createdAt"), "Must use camelCase: createdAt");
    assert!(!json.contains("file_meta_ipns_name"), "Should NOT contain snake_case");
}

#[test]
fn file_metadata_deserialization_with_encryption_mode() {
    let json = r#"{
        "version": "v1",
        "cid": "bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4",
        "fileKeyEncrypted": "deadbeef",
        "fileIv": "aabbccdd",
        "size": 1024,
        "mimeType": "video/mp4",
        "encryptionMode": "CTR",
        "createdAt": 1700000000000,
        "modifiedAt": 1700000000000
    }"#;

    let metadata: FileMetadata = serde_json::from_str(json).unwrap();
    assert_eq!(metadata.version, "v1");
    assert_eq!(metadata.cid, "bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4");
    assert_eq!(metadata.encryption_mode, "CTR");
    assert_eq!(metadata.mime_type, "video/mp4");
    assert_eq!(metadata.size, 1024);
}

#[test]
fn file_metadata_deserialization_without_encryption_mode_defaults_gcm() {
    let json = r#"{
        "version": "v1",
        "cid": "bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4",
        "fileKeyEncrypted": "deadbeef",
        "fileIv": "aabbccdd",
        "size": 512,
        "mimeType": "image/png",
        "createdAt": 1700000000000,
        "modifiedAt": 1700000000000
    }"#;

    let metadata: FileMetadata = serde_json::from_str(json).unwrap();
    assert_eq!(
        metadata.encryption_mode, "GCM",
        "Missing encryptionMode should default to GCM"
    );
}

#[test]
fn any_folder_metadata_dispatch_v1() {
    let key = utils::generate_file_key();
    let v1 = FolderMetadata {
        version: "v1".to_string(),
        children: vec![],
    };

    let sealed = encrypt_folder_metadata(&v1, &key).unwrap();
    let any = decrypt_any_folder_metadata(&sealed, &key).unwrap();

    match any {
        AnyFolderMetadata::V1(m) => assert_eq!(m.version, "v1"),
        AnyFolderMetadata::V2(_) => panic!("Should dispatch to V1"),
    }
}

#[test]
fn any_folder_metadata_dispatch_v2() {
    let key = utils::generate_file_key();

    // Manually create and encrypt v2 metadata
    let v2 = FolderMetadataV2 {
        version: "v2".to_string(),
        children: vec![FolderChildV2::File(FilePointer {
            id: "file-001".to_string(),
            name: "test.txt".to_string(),
            file_meta_ipns_name: "k51abc".to_string(),
            created_at: 1700000000000,
            modified_at: 1700000000000,
        })],
    };

    let mut json = serde_json::to_vec(&v2).unwrap();
    let sealed = aes::seal_aes_gcm(&json, &key).unwrap();
    json.fill(0);

    let any = decrypt_any_folder_metadata(&sealed, &key).unwrap();

    match any {
        AnyFolderMetadata::V1(_) => panic!("Should dispatch to V2"),
        AnyFolderMetadata::V2(m) => {
            assert_eq!(m.version, "v2");
            assert_eq!(m.children.len(), 1);
        }
    }
}

#[test]
fn file_metadata_encrypt_decrypt_roundtrip() {
    let key = utils::generate_file_key();
    let metadata = FileMetadata {
        version: "v1".to_string(),
        cid: "bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4".to_string(),
        file_key_encrypted: "deadbeef".to_string(),
        file_iv: "aabbccdd".to_string(),
        size: 2048,
        mime_type: "video/mp4".to_string(),
        encryption_mode: "CTR".to_string(),
        created_at: 1700000000000,
        modified_at: 1700000000000,
    };

    let sealed = encrypt_file_metadata(&metadata, &key).unwrap();
    let decrypted = decrypt_file_metadata(&sealed, &key).unwrap();

    assert_eq!(decrypted.version, "v1");
    assert_eq!(decrypted.cid, metadata.cid);
    assert_eq!(decrypted.encryption_mode, "CTR");
    assert_eq!(decrypted.mime_type, "video/mp4");
    assert_eq!(decrypted.size, 2048);
}

#[test]
fn file_metadata_wrong_key_fails() {
    let key1 = utils::generate_file_key();
    let key2 = utils::generate_file_key();
    let metadata = FileMetadata {
        version: "v1".to_string(),
        cid: "bafytest".to_string(),
        file_key_encrypted: "aa".to_string(),
        file_iv: "bb".to_string(),
        size: 100,
        mime_type: "text/plain".to_string(),
        encryption_mode: "GCM".to_string(),
        created_at: 1000,
        modified_at: 2000,
    };

    let sealed = encrypt_file_metadata(&metadata, &key1).unwrap();
    let result = decrypt_file_metadata(&sealed, &key2);
    assert!(result.is_err(), "Wrong key should fail decryption");
}

#[test]
fn file_metadata_camel_case_serialization() {
    let metadata = FileMetadata {
        version: "v1".to_string(),
        cid: "bafytest".to_string(),
        file_key_encrypted: "aa".to_string(),
        file_iv: "bb".to_string(),
        size: 100,
        mime_type: "video/mp4".to_string(),
        encryption_mode: "CTR".to_string(),
        created_at: 1000,
        modified_at: 2000,
    };

    let json = serde_json::to_string(&metadata).unwrap();
    assert!(json.contains("fileKeyEncrypted"), "Must use camelCase: fileKeyEncrypted");
    assert!(json.contains("fileIv"), "Must use camelCase: fileIv");
    assert!(json.contains("mimeType"), "Must use camelCase: mimeType");
    assert!(json.contains("encryptionMode"), "Must use camelCase: encryptionMode");
    assert!(!json.contains("file_key_encrypted"), "Should NOT contain snake_case");
    assert!(!json.contains("mime_type"), "Should NOT contain snake_case");
}
