---
phase: 12.2-encrypted-device-registry
plan: 03
type: execute
wave: 3
depends_on: ['12.2-02']
files_modified:
  - apps/web/src/stores/device-registry.store.ts
  - apps/web/src/hooks/useDeviceRegistrySync.ts
  - apps/web/src/hooks/useAuth.ts
autonomous: true

must_haves:
  truths:
    - 'Device registry is initialized non-blocking after vault keys are loaded during login'
    - 'Registry state is available in Zustand store for UI consumption'
    - 'Registry polls for remote changes on ~60s interval (independent from vault sync)'
    - 'Polling pauses when tab is backgrounded or offline'
    - 'Device registry state is cleared on logout (memory zeroed)'
    - 'Login never blocks or fails due to registry errors'
  artifacts:
    - path: 'apps/web/src/stores/device-registry.store.ts'
      provides: 'Zustand store for device registry state'
      exports: ['useDeviceRegistryStore']
    - path: 'apps/web/src/hooks/useDeviceRegistrySync.ts'
      provides: 'Polling hook for registry changes'
      exports: ['useDeviceRegistrySync']
    - path: 'apps/web/src/hooks/useAuth.ts'
      provides: 'Updated auth hook with non-blocking registry init'
      contains: 'initializeOrSyncRegistry'
  key_links:
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/services/device-registry.service.ts'
      via: 'fire-and-forget call to initializeOrSyncRegistry after vault load'
      pattern: 'initializeOrSyncRegistry'
    - from: 'apps/web/src/hooks/useDeviceRegistrySync.ts'
      to: 'apps/web/src/services/device-registry.service.ts'
      via: 'loadRegistry for polling'
      pattern: 'loadRegistry'
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/stores/device-registry.store.ts'
      via: 'clearRegistry on logout'
      pattern: 'clearRegistry|useDeviceRegistryStore'
---

<objective>
Wire the device registry into the application lifecycle: Zustand store for state management, non-blocking initialization in the auth flow, periodic polling for remote changes, and cleanup on logout.

Purpose: This completes the device registry feature by integrating it into the existing app architecture. After this plan, authenticated devices are automatically tracked in the encrypted registry.
Output: Working end-to-end device registry that initializes on login, syncs periodically, and clears on logout.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.2-encrypted-device-registry/12.2-CONTEXT.md
@.planning/phases/12.2-encrypted-device-registry/12.2-RESEARCH.md
@.planning/phases/12.2-encrypted-device-registry/12.2-01-SUMMARY.md
@.planning/phases/12.2-encrypted-device-registry/12.2-02-SUMMARY.md

Key existing files to reference:
@apps/web/src/hooks/useAuth.ts -- auth hook to modify (add registry init after vault load)
@apps/web/src/hooks/useSyncPolling.ts -- polling pattern to mirror for registry sync
@apps/web/src/hooks/useInterval.ts -- reuse for registry polling
@apps/web/src/hooks/useVisibility.ts -- reuse for pause-when-backgrounded
@apps/web/src/hooks/useOnlineStatus.ts -- reuse for pause-when-offline
@apps/web/src/stores/vault.store.ts -- pattern for Zustand store with memory clearing
@apps/web/src/stores/auth.store.ts -- derivedKeypair (source of user keys for registry ops)
@apps/web/src/stores/sync.store.ts -- pattern for sync state management
</context>

<tasks>

<task type="auto">
<name>Task 1: Zustand store and polling hook</name>
<files>
apps/web/src/stores/device-registry.store.ts
apps/web/src/hooks/useDeviceRegistrySync.ts
</files>
<action>
Create `apps/web/src/stores/device-registry.store.ts`:

Zustand store for device registry state. Pattern follows vault.store.ts and sync.store.ts.

State fields: `registry: DeviceRegistry | null` (the decrypted registry), `currentDeviceId: string | null` (this device's ID for highlighting in UI), `registryIpnsName: string | null` (for display/debug), `lastSyncedAt: number | null` (Unix ms of last successful sync), `syncError: string | null` (last error message, null = no error), `isInitialized: boolean` (true after first successful load/create).

Actions: `setRegistry(registry: DeviceRegistry, ipnsName: string, deviceId: string)` sets registry, ipnsName, currentDeviceId, clears syncError, sets isInitialized true, updates lastSyncedAt. `updateRegistry(registry: DeviceRegistry)` updates registry only (for polling updates), updates lastSyncedAt. `setSyncError(error: string)` sets syncError. `clearRegistry()` zeros all state, sets isInitialized false. SECURITY NOTE: No sensitive key material in this store (registry contains only hex-encoded public keys and metadata), but still set everything to null for clean state.

Export `useDeviceRegistryStore` (create from zustand).

Create `apps/web/src/hooks/useDeviceRegistrySync.ts`:

Polling hook for remote registry changes. Runs independently from vault sync (different interval, different IPNS name).

Use REGISTRY_SYNC_INTERVAL_MS = 60000 (60 seconds per CONTEXT.md suggestion).

Follow the pattern in `useSyncPolling.ts` but simplified: Use `useInterval` from existing hooks. Use `useVisibility` and `useOnlineStatus` to pause when backgrounded/offline. Use a `isSyncingRef` to guard against concurrent runs.

The sync callback: (1) Get userPrivateKey from `useAuthStore.getState().derivedKeypair?.privateKey`. (2) If no privateKey, skip (not logged in). (3) Call `loadRegistry(userPrivateKey)` from device-registry.service. (4) If result and result.registry.sequenceNumber > current store's sequenceNumber, call `useDeviceRegistryStore.getState().updateRegistry(result.registry)`. (5) On error: `useDeviceRegistryStore.getState().setSyncError(error.message)`, don't throw.

Only start polling when `useDeviceRegistryStore.getState().isInitialized` is true. No initial sync on mount -- Task 2 handles the initial load via initializeOrSyncRegistry in the auth flow. The polling hook only handles subsequent periodic checks.

IMPORTANT (from MEMORY.md): Use `useAuthStore.getState()` inside async callbacks to read fresh state, not hook selectors that capture stale closures.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter web typecheck` -- no type errors.
Verify the store follows the same patterns as vault.store.ts (create from zustand, typed state + actions).
Verify the polling hook uses useInterval/useVisibility/useOnlineStatus from existing hooks.
</verify>
<done>
Zustand store manages registry state with proper initialization tracking and error state. Polling hook checks for remote changes every 60s, pauses when backgrounded/offline, and guards against concurrent runs.
</done>
</task>

<task type="auto">
<name>Task 2: Wire registry into auth flow and logout</name>
<files>
apps/web/src/hooks/useAuth.ts
</files>
<action>
Modify `apps/web/src/hooks/useAuth.ts` to integrate device registry initialization.

**Add imports:** `import { getOrCreateDeviceIdentity } from '../lib/device/identity'`, `import { detectDeviceInfo } from '../lib/device/info'`, `import { initializeOrSyncRegistry } from '../services/device-registry.service'`, `import { useDeviceRegistryStore } from '../stores/device-registry.store'`.

**Modify `initializeOrLoadVault` callback:** After the vault is loaded/initialized (after `setVaultKeys` is called), add a NON-BLOCKING device registry initialization. This is a fire-and-forget call -- never awaited.

Place a `void (async () => { ... })()` IIFE after the `setVaultKeys()` call in the `initializeOrLoadVault` function. Inside the IIFE: get device identity via `getOrCreateDeviceIdentity()`, get device info via `detectDeviceInfo()`, call `initializeOrSyncRegistry({ userPrivateKey: userKeypair.privateKey, userPublicKey: userKeypair.publicKey, deviceKeypair, deviceInfo: { ...deviceInfo, ipHash: '' } })`, and if result is non-null, call `useDeviceRegistryStore.getState().setRegistry(result.registry, result.ipnsName, deviceKeypair.deviceId)`. Wrap the entire IIFE body in try/catch with `console.error('[Auth] Device registry init failed (non-blocking):', error)`.

The `userKeypair` variable is already available in scope from the beginning of `initializeOrLoadVault`. The IIFE must be OUTSIDE the try/catch for vault operations so vault errors and registry errors don't interfere with each other. Place it in BOTH the existing-vault branch (after setVaultKeys for loaded vault) and the new-vault branch (after setVaultKeys for newly created vault). Alternatively, place it once AFTER the entire try/catch block in initializeOrLoadVault, since userKeypair is available at that scope level.

The ipHash field is set to empty string '' for now -- the backend endpoint to return client IP doesn't exist yet. This is noted in RESEARCH.md open questions.

**Modify `logout` callback:** Add device registry store cleanup alongside the existing store clears. Add `useDeviceRegistryStore.getState().clearRegistry()` in BOTH the success and error paths of logout (same pattern as the existing `useFolderStore.getState().clearFolders()`, `useVaultStore.getState().clearVaultKeys()`, `useSyncStore.getState().reset()` calls).

**Do NOT modify the login functions** (loginWithGoogle, loginWithEmail). They already call `completeBackendAuth` which calls `initializeOrLoadVault`, so registry init happens automatically.

**Do NOT modify session restoration.** It already calls `initializeOrLoadVault`, so registry init happens on session restore too.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter web typecheck` -- no type errors.
Run `pnpm --filter web build` -- builds successfully (Vite build).
Verify that registry initialization is fire-and-forget (void async IIFE, not awaited).
Verify that logout clears the device registry store.
Verify no new dependencies added to apps/web/package.json.
</verify>
<done>
On login (Google or email) and session restore, device registry automatically initializes in the background. First device is auto-authorized, subsequent devices registered as pending. Polling runs every 60s to detect remote changes. Logout clears registry state. Registry errors never block login or vault access.
</done>
</task>

</tasks>

<verification>

1. `pnpm --filter web typecheck` passes
2. `pnpm --filter web build` succeeds
3. Login flow: after vault loads, device registry init fires in background (visible in console logs)
4. First-ever login: creates new registry with single authorized device, publishes to IPNS
5. Subsequent login from same device: updates lastSeenAt, republishes
6. Logout: registry store is cleared alongside vault and folder stores
7. If IPNS resolution fails: login succeeds anyway, console shows warning
8. Polling hook starts after registry is initialized, pauses when tab is backgrounded

</verification>

<success_criteria>

- Device registry initializes automatically on every login (fire-and-forget, non-blocking)
- First device is auto-authorized; subsequent devices are "pending"
- Registry is encrypted with ECIES, pinned to IPFS, published via IPNS
- Polling detects remote registry changes every ~60s
- Logout clears all registry state
- No login flow is blocked by registry failures
- All files typecheck and build cleanly

</success_criteria>

<output>
After completion, create `.planning/phases/12.2-encrypted-device-registry/12.2-03-SUMMARY.md`
</output>
