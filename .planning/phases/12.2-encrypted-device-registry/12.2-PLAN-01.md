---
phase: 12.2-encrypted-device-registry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/registry/types.ts
  - packages/crypto/src/registry/schema.ts
  - packages/crypto/src/registry/encrypt.ts
  - packages/crypto/src/registry/derive-ipns.ts
  - packages/crypto/src/registry/index.ts
  - packages/crypto/src/device/keygen.ts
  - packages/crypto/src/device/types.ts
  - packages/crypto/src/device/index.ts
  - packages/crypto/src/index.ts
  - packages/crypto/src/__tests__/registry.test.ts
autonomous: true

must_haves:
  truths:
    - "Registry IPNS keypair is deterministically derived from user's secp256k1 privateKey"
    - 'Same privateKey always produces the same IPNS name (k51...)'
    - "Registry can be encrypted with user's publicKey and decrypted with user's privateKey"
    - "Device ID is SHA-256 of device's Ed25519 public key"
    - 'Registry schema validation rejects malformed data'
  artifacts:
    - path: 'packages/crypto/src/registry/types.ts'
      provides: 'DeviceEntry, DeviceRegistry, DeviceAuthStatus, DevicePlatform types'
      contains: 'DeviceRegistry'
    - path: 'packages/crypto/src/registry/derive-ipns.ts'
      provides: 'Deterministic IPNS keypair derivation from user privateKey'
      exports: ['deriveRegistryIpnsKeypair']
    - path: 'packages/crypto/src/registry/encrypt.ts'
      provides: 'ECIES encryption/decryption for registry blob'
      exports: ['encryptRegistry', 'decryptRegistry']
    - path: 'packages/crypto/src/registry/schema.ts'
      provides: 'Runtime validation for DeviceRegistry JSON'
      exports: ['validateDeviceRegistry']
    - path: 'packages/crypto/src/device/keygen.ts'
      provides: 'Ed25519 device keypair generation and device ID derivation'
      exports: ['generateDeviceKeypair', 'deriveDeviceId']
    - path: 'packages/crypto/src/__tests__/registry.test.ts'
      provides: 'Tests for registry crypto operations'
      min_lines: 50
  key_links:
    - from: 'packages/crypto/src/registry/derive-ipns.ts'
      to: 'packages/crypto/src/keys/derive.ts'
      via: 'deriveKey() for HKDF'
      pattern: "deriveKey\\("
    - from: 'packages/crypto/src/registry/encrypt.ts'
      to: 'packages/crypto/src/ecies/'
      via: 'wrapKey/unwrapKey for ECIES'
      pattern: "(wrapKey|unwrapKey)\\("
    - from: 'packages/crypto/src/index.ts'
      to: 'packages/crypto/src/registry/'
      via: 're-export registry types and functions'
      pattern: 'from.*registry'
---

<objective>
Create the crypto primitives for the encrypted device registry: types, deterministic IPNS derivation, ECIES encryption/decryption, device keypair generation, and runtime schema validation.

Purpose: These are the pure cryptographic building blocks that Plan 02 and Plan 03 compose into the full registry lifecycle. All operations are side-effect-free and testable in isolation.
Output: New `registry/` and `device/` modules in `@cipherbox/crypto`, exported from the package barrel, with unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.2-encrypted-device-registry/12.2-CONTEXT.md
@.planning/phases/12.2-encrypted-device-registry/12.2-RESEARCH.md

Key existing files to reference:
@packages/crypto/src/keys/derive.ts -- deriveKey() with HKDF-SHA256 (reuse for IPNS derivation)
@packages/crypto/src/ecies/index.ts -- wrapKey/unwrapKey (reuse for registry encryption)
@packages/crypto/src/ed25519/keygen.ts -- generateEd25519Keypair pattern (mirror for device keygen)
@packages/crypto/src/ipns/derive-name.ts -- deriveIpnsName (reuse to get k51... from Ed25519 pubkey)
@packages/crypto/src/index.ts -- barrel exports (add new registry + device exports)
@packages/crypto/src/folder/types.ts -- FolderMetadata pattern (mirror for registry types)
@packages/crypto/src/folder/metadata.ts -- encryptFolderMetadata pattern (mirror for registry)
</context>

<tasks>

<task type="auto">
<name>Task 1: Registry and device crypto modules</name>
<files>
packages/crypto/src/registry/types.ts
packages/crypto/src/registry/schema.ts
packages/crypto/src/registry/encrypt.ts
packages/crypto/src/registry/derive-ipns.ts
packages/crypto/src/registry/index.ts
packages/crypto/src/device/keygen.ts
packages/crypto/src/device/types.ts
packages/crypto/src/device/index.ts
packages/crypto/src/index.ts
</files>
<action>
Create `packages/crypto/src/registry/types.ts`:

- Define `DeviceAuthStatus = 'pending' | 'authorized' | 'revoked'`
- Define `DevicePlatform = 'web' | 'macos' | 'linux' | 'windows'`
- Define `DeviceEntry` type with fields per RESEARCH.md code example: deviceId (string), publicKey (string/hex), name (string), platform (DevicePlatform), appVersion (string), deviceModel (string), ipHash (string), status (DeviceAuthStatus), createdAt (number/Unix ms), lastSeenAt (number/Unix ms), revokedAt (number | null), revokedBy (string | null)
- Define `DeviceRegistry` type: version ('v1' literal), sequenceNumber (number), devices (DeviceEntry[])

Create `packages/crypto/src/registry/schema.ts`:

- Export `validateDeviceRegistry(data: unknown): DeviceRegistry` that performs runtime validation
- Validate: version === 'v1', sequenceNumber is non-negative integer, devices is an array, each device has required string fields, status is one of the valid values, timestamps are numbers
- Throw `CryptoError` with code `'DECRYPTION_FAILED'` on validation failure (generic to avoid info leakage)
- Keep it simple -- manual checks, no external schema library (consistent with existing codebase)

Create `packages/crypto/src/registry/encrypt.ts`:

- Export `encryptRegistry(registry: DeviceRegistry, userPublicKey: Uint8Array): Promise<Uint8Array>` -- JSON.stringify the registry, TextEncoder.encode, then call `wrapKey(plaintext, userPublicKey)`. Import wrapKey from `../ecies/encrypt`.
- Export `decryptRegistry(encrypted: Uint8Array, userPrivateKey: Uint8Array): Promise<DeviceRegistry>` -- Call `unwrapKey(encrypted, userPrivateKey)`, TextDecoder.decode, JSON.parse, then `validateDeviceRegistry(parsed)`. Import unwrapKey from `../ecies/decrypt`.
- Add JSDoc noting that wrapKey handles arbitrary-length data (not just 32-byte keys) via eciesjs AES-GCM internally. ~97 byte overhead.

Create `packages/crypto/src/registry/derive-ipns.ts`:

- Export `deriveRegistryIpnsKeypair(userPrivateKey: Uint8Array): Promise<{ privateKey: Uint8Array; publicKey: Uint8Array; ipnsName: string }>`
- Use `deriveKey()` from `../keys/derive` with: inputKey = userPrivateKey (32-byte secp256k1), salt = TextEncoder.encode('CipherBox-v1'), info = TextEncoder.encode('cipherbox-device-registry-ipns-v1'), outputLength = 32
- Derive Ed25519 public key from the 32-byte seed using `ed.getPublicKey(seed)` (import \* as ed from '@noble/ed25519')
- Call `deriveIpnsName(publicKey)` from `../ipns/derive-name` to get the k51... string
- Return { privateKey: seed, publicKey, ipnsName }
- Validate input is 32 bytes, throw CryptoError if not

Create `packages/crypto/src/registry/index.ts`:

- Re-export everything from types, schema, encrypt, derive-ipns

Create `packages/crypto/src/device/types.ts`:

- Define `DeviceKeypair = { publicKey: Uint8Array; privateKey: Uint8Array; deviceId: string }`

Create `packages/crypto/src/device/keygen.ts`:

- Export `generateDeviceKeypair(): DeviceKeypair` -- Call `generateEd25519Keypair()` from `../ed25519/keygen`, compute deviceId = bytesToHex(sha256(keypair.publicKey)) using sha256 from `@noble/hashes/sha256` and bytesToHex from `../utils/encoding`, return { publicKey, privateKey, deviceId }
- Export `deriveDeviceId(publicKey: Uint8Array): string` -- Compute and return SHA-256 hex of the public key. Useful when loading existing keypair from IndexedDB.

Create `packages/crypto/src/device/index.ts`:

- Re-export from types and keygen

Update `packages/crypto/src/index.ts`:

- Add exports for registry module: encryptRegistry, decryptRegistry, deriveRegistryIpnsKeypair, validateDeviceRegistry, and all types (DeviceEntry, DeviceRegistry, DeviceAuthStatus, DevicePlatform)
- Add exports for device module: generateDeviceKeypair, deriveDeviceId, type DeviceKeypair
- Follow the existing export grouping pattern with comments
  </action>
  <verify>
  Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto build` -- should compile with no errors.
  Run `pnpm --filter @cipherbox/crypto typecheck` (or `tsc --noEmit`) -- should have no type errors.
  </verify>
  <done>
  All new modules compile. Types are exported from package barrel. deriveRegistryIpnsKeypair, encryptRegistry, decryptRegistry, generateDeviceKeypair, deriveDeviceId are all exported and importable.
  </done>
  </task>

<task type="auto">
<name>Task 2: Unit tests for registry crypto operations</name>
<files>
packages/crypto/src/__tests__/registry.test.ts
</files>
<action>
Create `packages/crypto/src/__tests__/registry.test.ts` following the pattern of existing test files (e.g., `ecies.test.ts`, `ipns.test.ts`).

Test suite groups:

**deriveRegistryIpnsKeypair:** Given a known 32-byte secp256k1 private key, derives an IPNS name starting with 'k51'. Same privateKey always produces the same IPNS name (determinism). Different privateKeys produce different IPNS names. Throws CryptoError for invalid key length (not 32 bytes).

**encryptRegistry / decryptRegistry:** Round-trip: create a DeviceRegistry with 1 device entry, encrypt with publicKey, decrypt with privateKey, assert equality. Decrypt with wrong privateKey throws CryptoError. Encrypted output is different from plaintext (sanity check). Encrypted output is larger than plaintext by approximately ~97 bytes (ECIES overhead).

**validateDeviceRegistry:** Valid registry passes validation. Missing 'version' field throws. Invalid status value throws. Non-array 'devices' field throws. Missing required DeviceEntry fields throw.

**generateDeviceKeypair / deriveDeviceId:** Generates keypair with 32-byte public and private keys. deviceId is hex string (64 chars = SHA-256 hex). deriveDeviceId(keypair.publicKey) === keypair.deviceId. Two generated keypairs have different deviceIds.

For test keys: Use `generateEd25519Keypair()` from the ed25519 module for device keys. For the secp256k1 keypair needed by ECIES/IPNS tests, generate a random 32-byte private key and derive the public key using `@noble/secp256k1` `getPublicKey(privateKey, false)` (uncompressed, 65 bytes) -- follow the pattern in the existing `ecies.test.ts`.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto test -- --run registry` -- all tests pass.
</verify>
<done>
All registry and device crypto tests pass. Round-trip encrypt/decrypt works. Deterministic IPNS derivation confirmed. Schema validation catches invalid data.
</done>
</task>

</tasks>

<verification>

1. `pnpm --filter @cipherbox/crypto build` succeeds with no errors
2. `pnpm --filter @cipherbox/crypto test -- --run registry` -- all tests pass
3. In the barrel export (`packages/crypto/src/index.ts`), all new types and functions are exported
4. `deriveRegistryIpnsKeypair` produces a deterministic IPNS name for a given privateKey
5. `encryptRegistry` + `decryptRegistry` round-trips without data loss
6. `generateDeviceKeypair` produces unique device IDs

</verification>

<success_criteria>

- New `registry/` and `device/` modules exist in packages/crypto/src/
- All functions are exported from the @cipherbox/crypto barrel
- Unit tests cover determinism, round-trip encryption, validation, and edge cases
- Build passes with no TypeScript errors
- Tests pass

</success_criteria>

<output>
After completion, create `.planning/phases/12.2-encrypted-device-registry/12.2-01-SUMMARY.md`
</output>
