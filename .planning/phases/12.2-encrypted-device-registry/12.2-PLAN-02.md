---
phase: 12.2-encrypted-device-registry
plan: 02
type: execute
wave: 2
depends_on: ['12.2-01']
files_modified:
  - apps/web/src/lib/device/identity.ts
  - apps/web/src/lib/device/info.ts
  - apps/web/src/services/device-registry.service.ts
autonomous: true

must_haves:
  truths:
    - 'Device keypair is persisted in IndexedDB and survives page refresh'
    - 'Device info (name, platform, model) is auto-detected from browser environment'
    - 'Registry can be created for a first device (auto-authorized)'
    - 'Registry can be updated when an existing device logs in (lastSeenAt updated)'
    - "New devices are registered as 'pending' in an existing registry"
    - 'Registry changes are encrypted, pinned to IPFS, and published via IPNS'
    - 'Registry operations never block -- errors are caught and logged'
  artifacts:
    - path: 'apps/web/src/lib/device/identity.ts'
      provides: 'IndexedDB persistence for device Ed25519 keypair'
      exports: ['getOrCreateDeviceIdentity']
    - path: 'apps/web/src/lib/device/info.ts'
      provides: 'Auto-detection of device name, platform, model'
      exports: ['detectDeviceInfo']
    - path: 'apps/web/src/services/device-registry.service.ts'
      provides: 'Registry CRUD: create, load, register device, update lastSeen, publish'
      exports: ['initializeOrSyncRegistry']
  key_links:
    - from: 'apps/web/src/lib/device/identity.ts'
      to: '@cipherbox/crypto'
      via: 'generateDeviceKeypair, deriveDeviceId'
      pattern: 'generateDeviceKeypair|deriveDeviceId'
    - from: 'apps/web/src/services/device-registry.service.ts'
      to: '@cipherbox/crypto'
      via: 'deriveRegistryIpnsKeypair, encryptRegistry, decryptRegistry'
      pattern: 'deriveRegistryIpnsKeypair|encryptRegistry|decryptRegistry'
    - from: 'apps/web/src/services/device-registry.service.ts'
      to: 'apps/web/src/services/ipns.service.ts'
      via: 'createAndPublishIpnsRecord, resolveIpnsRecord'
      pattern: 'createAndPublishIpnsRecord|resolveIpnsRecord'
    - from: 'apps/web/src/services/device-registry.service.ts'
      to: 'apps/web/src/lib/api/ipfs.ts'
      via: 'addToIpfs, fetchFromIpfs'
      pattern: 'addToIpfs|fetchFromIpfs'
---

<objective>
Build the device identity persistence layer and the registry service that handles the full CRUD lifecycle: create registry for first device, load existing registry, register new devices, update heartbeats, encrypt, pin to IPFS, and publish via IPNS.

Purpose: This is the core application-level logic that composes the crypto primitives from Plan 01 with the existing IPFS/IPNS infrastructure. Plan 03 will wire this into the auth flow and add the Zustand store + polling.
Output: Device identity module (IndexedDB), device info detection, and a complete registry service.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.2-encrypted-device-registry/12.2-CONTEXT.md
@.planning/phases/12.2-encrypted-device-registry/12.2-RESEARCH.md
@.planning/phases/12.2-encrypted-device-registry/12.2-01-SUMMARY.md

Key existing files to reference:
@apps/web/src/services/ipns.service.ts -- createAndPublishIpnsRecord, resolveIpnsRecord (reuse directly)
@apps/web/src/lib/api/ipfs.ts -- addToIpfs, fetchFromIpfs (reuse directly)
@apps/web/src/stores/auth.store.ts -- useAuthStore for teeKeys (needed for TEE republishing enrollment)
@apps/web/src/services/folder.service.ts -- pattern for IPFS/IPNS operations (load, update, publish flow)
@apps/web/CLAUDE.md -- coding guidelines (never use .buffer on Uint8Array for Blob)
</context>

<tasks>

<task type="auto">
<name>Task 1: Device identity persistence and info detection</name>
<files>
apps/web/src/lib/device/identity.ts
apps/web/src/lib/device/info.ts
</files>
<action>
Create `apps/web/src/lib/device/identity.ts`:

IndexedDB persistence for the device's Ed25519 keypair. This keypair is unique per physical device/browser and cannot be re-derived (unlike the user's vault key).

Use DB_NAME = 'cipherbox-device', DB_VERSION = 1, STORE_NAME = 'keys', KEYPAIR_KEY = 'device-ed25519'.

Private helper `openDB(): Promise<IDBDatabase>` that opens/upgrades the database with a single object store.

Private helper `loadDeviceKeypair()` that reads from IndexedDB, returns `{ publicKey: Uint8Array, privateKey: Uint8Array } | null`. Store keys as plain number arrays in IDB (Uint8Array doesn't serialize reliably across browsers). On read, convert back: `new Uint8Array(val.publicKey)`, `new Uint8Array(val.privateKey)`. Wrap in try/catch -- return null if IndexedDB is unavailable (incognito, etc.).

Private helper `saveDeviceKeypair(keypair)` that writes to IndexedDB. Convert to `{ publicKey: Array.from(...), privateKey: Array.from(...) }` before storing.

Export `getOrCreateDeviceIdentity(): Promise<DeviceKeypair>` (DeviceKeypair from @cipherbox/crypto). Try loadDeviceKeypair first. If found, compute deviceId via `deriveDeviceId(publicKey)` and return. If not found, call `generateDeviceKeypair()` from @cipherbox/crypto, saveDeviceKeypair, return. IMPORTANT: The returned DeviceKeypair includes deviceId (SHA-256 hex of public key).

Create `apps/web/src/lib/device/info.ts`:

Auto-detect device metadata from browser environment.

Export `detectDeviceInfo(): { name: string; platform: DevicePlatform; appVersion: string; deviceModel: string }`. Platform detection: Check `navigator.userAgent` for macOS/Windows/Linux, default to 'web'. Device model: Extract browser name + OS from userAgent (e.g., "Chrome 123 on macOS 15.2"). Device name: `${browserName} on ${osName}` (e.g., "Chrome on macOS"). Keep it simple -- users can rename in Phase 12.4. App version: Import from package.json version or use a hardcoded constant matching the current version. Prefer `import.meta.env.VITE_APP_VERSION` if available, otherwise fall back to CRYPTO_VERSION from @cipherbox/crypto.

Export `computeIpHash(ipAddress: string): string` -- SHA-256 hash of IP string, hex-encoded. Uses sha256 from @noble/hashes/sha256 and bytesToHex from @cipherbox/crypto. Note: the actual IP is obtained from the backend; this function just hashes it locally.

NOTE: DevicePlatform type comes from @cipherbox/crypto (added in Plan 01).
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter web typecheck` -- no type errors in new files.
Manually verify that `identity.ts` and `info.ts` import only from established packages.
</verify>
<done>
getOrCreateDeviceIdentity persists to IndexedDB and returns a DeviceKeypair. detectDeviceInfo returns platform-appropriate metadata. computeIpHash produces a hex SHA-256 hash.
</done>
</task>

<task type="auto">
<name>Task 2: Device registry service (CRUD + IPFS/IPNS)</name>
<files>
apps/web/src/services/device-registry.service.ts
</files>
<action>
Create `apps/web/src/services/device-registry.service.ts`:

This service handles the full registry lifecycle. It follows the same pattern as folder.service.ts for IPFS/IPNS operations.

**Imports from @cipherbox/crypto:** deriveRegistryIpnsKeypair, encryptRegistry, decryptRegistry, bytesToHex, hexToBytes, wrapKey, type DeviceRegistry, type DeviceEntry, type DeviceKeypair, type DevicePlatform

**Imports from local:** addToIpfs, fetchFromIpfs (from lib/api/ipfs), createAndPublishIpnsRecord, resolveIpnsRecord (from services/ipns.service), useAuthStore (for teeKeys + derivedKeypair)

Export `initializeOrSyncRegistry(params: { userPrivateKey: Uint8Array; userPublicKey: Uint8Array; deviceKeypair: DeviceKeypair; deviceInfo: { name: string; platform: DevicePlatform; appVersion: string; deviceModel: string; ipHash: string }; }): Promise<{ registry: DeviceRegistry; ipnsName: string } | null>`

Implementation steps:

1. `const registryIpns = await deriveRegistryIpnsKeypair(userPrivateKey)` -- deterministic
2. Try to resolve existing registry via `resolveIpnsRecord(registryIpns.ipnsName)`
3. If resolved: (a) `fetchFromIpfs(resolved.cid)` to get encrypted bytes, (b) `decryptRegistry(encryptedBytes, userPrivateKey)` to get DeviceRegistry, (c) Check if current device exists by deviceId -- if exists: update lastSeenAt to Date.now(), update appVersion, update deviceModel; if not: push new DeviceEntry with status 'pending', createdAt/lastSeenAt = Date.now(). (d) Check if the registry actually changed (compare JSON before/after to avoid unnecessary republish per Pitfall 1 in RESEARCH.md). If only lastSeenAt changed and the difference is less than 5 minutes, skip republish to save rate limit.
4. If NOT resolved (first device): Create new DeviceRegistry with version 'v1', sequenceNumber 0, devices array containing current device with status 'authorized'
5. Increment sequenceNumber
6. `encryptRegistry(registry, userPublicKey)` to get encryptedBytes
7. `addToIpfs(new Blob([encryptedBytes]))` to get { cid } (NOTE: pass Uint8Array directly to Blob, never use .buffer per CLAUDE.md)
8. Publish IPNS: Get teeKeys from `useAuthStore.getState().teeKeys`. If teeKeys available, ECIES-wrap the registry IPNS private key with TEE public key for republishing enrollment: `const encryptedIpnsKey = bytesToHex(await wrapKey(registryIpns.privateKey, hexToBytes(teeKeys.currentPublicKey)))`. Call `createAndPublishIpnsRecord({ ipnsPrivateKey: registryIpns.privateKey, ipnsName: registryIpns.ipnsName, metadataCid: cid, sequenceNumber: BigInt(registry.sequenceNumber), encryptedIpnsPrivateKey: encryptedIpnsKey, keyEpoch: teeKeys?.currentEpoch })`
9. Return { registry, ipnsName: registryIpns.ipnsName }

The entire function body should be wrapped in try/catch. On error: `console.error('[DeviceRegistry] Failed to sync registry:', error)` and return null. Registry failures must NEVER block login (per CONTEXT.md + RESEARCH.md Pitfall 5).

Export `loadRegistry(userPrivateKey: Uint8Array): Promise<{ registry: DeviceRegistry; ipnsName: string; sequenceNumber: bigint } | null>` -- Derive IPNS, resolve, fetch, decrypt. Return null on any failure. Used by the polling hook (Plan 03) to check for remote changes.

Export `createEmptyDeviceEntry(params: { deviceKeypair: DeviceKeypair; deviceInfo: { name: string; platform: DevicePlatform; appVersion: string; deviceModel: string; ipHash: string }; status: 'authorized' | 'pending'; }): DeviceEntry` -- Helper that constructs a DeviceEntry object with all fields populated. publicKey = bytesToHex(deviceKeypair.publicKey). createdAt = lastSeenAt = Date.now(). revokedAt = null, revokedBy = null.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter web typecheck` -- no type errors.
Verify that the service imports only from established modules (no new dependencies).
Verify that all IPFS/IPNS calls follow existing patterns from folder.service.ts and ipns.service.ts.
</verify>
<done>
initializeOrSyncRegistry handles the complete lifecycle: derive IPNS, resolve-or-create registry, add/update device entry, encrypt, pin to IPFS, publish IPNS with TEE enrollment. All operations are non-blocking (errors caught and logged). loadRegistry provides read-only access for polling.
</done>
</task>

</tasks>

<verification>

1. `pnpm --filter web typecheck` passes with no errors
2. `device-registry.service.ts` follows the same IPFS/IPNS patterns as `folder.service.ts`
3. Device identity persists to IndexedDB (Uint8Array stored as plain arrays)
4. Registry service never throws -- all errors caught and logged, returns null on failure
5. TEE republishing enrollment included when teeKeys are available
6. No new npm dependencies added

</verification>

<success_criteria>

- getOrCreateDeviceIdentity creates and persists device keypair in IndexedDB
- detectDeviceInfo returns appropriate platform/browser metadata
- initializeOrSyncRegistry handles both first-device creation and subsequent-device registration
- Registry operations are non-blocking (never throw, errors logged)
- IPNS publish includes TEE key wrapping for auto-republishing
- All files typecheck cleanly

</success_criteria>

<output>
After completion, create `.planning/phases/12.2-encrypted-device-registry/12.2-02-SUMMARY.md`
</output>
