# Phase 12.2: Encrypted Device Registry - Research

**Researched:** 2026-02-13
**Domain:** Client-side encrypted device registry with IPFS/IPNS persistence
**Confidence:** HIGH

## Summary

This phase introduces an encrypted device registry stored on IPFS and published via a dedicated IPNS name, independent of the vault's IPNS. The registry tracks authenticated devices with rich metadata and supports future cross-device approval (Phase 12.4). The existing codebase provides all the crypto primitives needed: HKDF key derivation, ECIES encryption, Ed25519 key generation, IPNS record creation/publishing, and IPFS pinning via the backend. No new libraries are required.

The critical new pattern is **deterministic IPNS key derivation**: using HKDF to derive an Ed25519 keypair from the user's secp256k1 privateKey, enabling any authenticated session to discover the registry without backend assistance. This pattern does not exist in the codebase today (vault IPNS keys are random + stored server-side), but all building blocks are already present in `@cipherbox/crypto`.

**Primary recommendation:** Build registry operations as a new `registry` module in `packages/crypto` alongside a `device-registry.service.ts` in the web app, following the exact patterns established by the existing folder metadata encryption, IPNS publishing, and sync polling flows.

## Standard Stack

The established libraries/tools for this domain:

### Core (already in monorepo)

| Library             | Version       | Purpose                                         | Why Standard                              |
| ------------------- | ------------- | ----------------------------------------------- | ----------------------------------------- |
| `@cipherbox/crypto` | 0.2.0         | HKDF, ECIES, Ed25519, IPNS                      | Existing shared crypto module             |
| `@noble/ed25519`    | 2.3.0         | Ed25519 keypair from deterministic seed         | Already used for IPNS signing             |
| `@noble/hashes`     | 1.7.1         | SHA-256 (device ID), SHA-512 (Ed25519 internal) | Already a dependency                      |
| `eciesjs`           | 0.4.16        | ECIES encrypt/decrypt arbitrary-size data       | Already used for key wrapping             |
| `ipns`              | (client-side) | IPNS record creation, marshaling                | Already used for vault IPNS               |
| `@libp2p/crypto`    | (existing)    | Ed25519 key format conversion for IPNS          | Already used in create-record.ts          |
| `zustand`           | (existing)    | Device registry state management                | Already used for vault/auth/folder stores |

### Supporting (already in monorepo)

| Library                 | Version    | Purpose                       | When to Use                      |
| ----------------------- | ---------- | ----------------------------- | -------------------------------- |
| `@tanstack/react-query` | (existing) | Auto-generated API hooks      | If new API endpoints are created |
| `axios`                 | (existing) | IPFS upload via backend relay | Pinning encrypted registry blob  |

### Alternatives Considered

| Instead of                    | Could Use                          | Tradeoff                                                                                                                                                                                                  |
| ----------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ECIES for registry encryption | AES-GCM with derived symmetric key | ECIES is the established pattern for user-key encryption; AES-GCM requires managing a separate symmetric key. ECIES is simpler (one function, no key management) and consistent with folder key wrapping. |
| Separate IPNS for registry    | Reuse vault IPNS                   | Would cause write contention with file operations. Separate IPNS is decided per CONTEXT.md.                                                                                                               |
| Web Crypto HKDF               | @noble/hashes HKDF                 | Web Crypto HKDF is already used in `deriveKey()`. Reuse the existing pattern.                                                                                                                             |

**Installation:** No new dependencies needed. Everything is already in `packages/crypto/package.json`.

## Architecture Patterns

### Recommended Project Structure

```text
packages/crypto/src/
├── registry/              # NEW: Device registry crypto operations
│   ├── index.ts           # Exports
│   ├── types.ts           # DeviceEntry, DeviceRegistry, EncryptedRegistry types
│   ├── schema.ts          # Registry JSON serialization/validation
│   ├── encrypt.ts         # encryptRegistry / decryptRegistry (ECIES with user publicKey)
│   └── derive-ipns.ts     # deriveRegistryIpnsKeypair (HKDF from user privateKey)
├── device/                # NEW: Device identity (Ed25519 per-device keypair)
│   ├── index.ts
│   ├── keygen.ts          # generateDeviceKeypair, deriveDeviceId (SHA-256 of pubkey)
│   └── types.ts           # DeviceKeypair type
└── (existing modules unchanged)

apps/web/src/
├── services/
│   └── device-registry.service.ts  # NEW: Registry CRUD, IPNS publish, sync
├── stores/
│   └── device-registry.store.ts    # NEW: Zustand store for device registry state
├── hooks/
│   └── useDeviceRegistrySync.ts    # NEW: Registry polling (independent from vault sync)
└── lib/
    └── device/
        └── identity.ts             # NEW: Device keypair generation + IndexedDB persistence

apps/api/src/
└── (minimal changes - reuse existing IPNS publish/resolve endpoints)
```

### Pattern 1: Deterministic IPNS Key Derivation

**What:** Derive Ed25519 IPNS keypair from user's secp256k1 privateKey using HKDF so any session can independently discover the registry.

**When to use:** Every time the user logs in, to compute the registry IPNS name without querying the backend.

**Example:**

```typescript
// packages/crypto/src/registry/derive-ipns.ts
import { deriveKey } from '../keys/derive';
import * as ed from '@noble/ed25519';
import { deriveIpnsName } from '../ipns/derive-name';

const REGISTRY_HKDF_SALT = new TextEncoder().encode('CipherBox-v1');
const REGISTRY_HKDF_INFO = new TextEncoder().encode('cipherbox-device-registry-ipns-v1');

/**
 * Derive the deterministic Ed25519 IPNS keypair for the device registry.
 *
 * secp256k1 privateKey (32 bytes)
 *   -> HKDF-SHA256(salt="CipherBox-v1", info="cipherbox-device-registry-ipns-v1")
 *   -> 32-byte Ed25519 seed
 *   -> Ed25519 keypair
 *   -> IPNS name (k51...)
 */
export async function deriveRegistryIpnsKeypair(userPrivateKey: Uint8Array): Promise<{
  privateKey: Uint8Array;
  publicKey: Uint8Array;
  ipnsName: string;
}> {
  // 1. HKDF: secp256k1 privateKey -> 32-byte Ed25519 seed
  const ed25519Seed = await deriveKey({
    inputKey: userPrivateKey,
    salt: REGISTRY_HKDF_SALT,
    info: REGISTRY_HKDF_INFO,
    outputLength: 32,
  });

  // 2. Derive Ed25519 public key from seed (deterministic)
  const ed25519PublicKey = ed.getPublicKey(ed25519Seed);

  // 3. Derive IPNS name from Ed25519 public key
  const ipnsName = await deriveIpnsName(ed25519PublicKey);

  return {
    privateKey: ed25519Seed,
    publicKey: ed25519PublicKey,
    ipnsName,
  };
}
```

**Key insight:** The `deriveKey()` function already exists in `packages/crypto/src/keys/derive.ts`. It uses Web Crypto HKDF-SHA256 with configurable salt/info. The Ed25519 seed is just the 32-byte HKDF output, and `@noble/ed25519` `getPublicKey()` deterministically derives the public key.

### Pattern 2: Registry Encryption with ECIES

**What:** Encrypt the entire registry JSON blob with the user's secp256k1 publicKey via ECIES, so only the user can read it.

**When to use:** Before uploading to IPFS (encrypt) and after fetching from IPFS (decrypt).

**Example:**

```typescript
// packages/crypto/src/registry/encrypt.ts
import { wrapKey, unwrapKey } from '../ecies';
import type { DeviceRegistry, EncryptedDeviceRegistry } from './types';

/**
 * Encrypt the device registry for IPFS storage.
 * Uses ECIES with user's secp256k1 publicKey.
 *
 * Note: wrapKey accepts arbitrary-length data (eciesjs uses AES-GCM internally).
 * Overhead is ~97 bytes (65 ephemeral pubkey + 16 nonce + 16 tag).
 * A 10KB registry produces ~10.1KB ciphertext.
 */
export async function encryptRegistry(
  registry: DeviceRegistry,
  userPublicKey: Uint8Array
): Promise<Uint8Array> {
  const plaintext = new TextEncoder().encode(JSON.stringify(registry));
  return wrapKey(plaintext, userPublicKey);
}

export async function decryptRegistry(
  encrypted: Uint8Array,
  userPrivateKey: Uint8Array
): Promise<DeviceRegistry> {
  const plaintext = await unwrapKey(encrypted, userPrivateKey);
  const json = new TextDecoder().decode(plaintext);
  const parsed = JSON.parse(json);
  return validateDeviceRegistry(parsed); // Runtime validation
}
```

**Key insight:** The existing `wrapKey`/`unwrapKey` functions (which call `eciesjs` `encrypt`/`decrypt`) handle arbitrary-length data, not just 32-byte keys. The "wrapKey" name is from its original use case, but it encrypts any `Uint8Array`. The ~97 byte overhead is negligible for a <10KB registry.

### Pattern 3: Device Identity (Per-Device Ed25519 Keypair)

**What:** Generate a unique Ed25519 keypair per device, stored persistently in IndexedDB (web) or OS keychain (desktop).

**When to use:** Once per device, on first login from that device.

**Example:**

```typescript
// apps/web/src/lib/device/identity.ts
import { generateEd25519Keypair, bytesToHex, hexToBytes } from '@cipherbox/crypto';
import { sha256 } from '@noble/hashes/sha256';

const DB_NAME = 'cipherbox-device';
const STORE_NAME = 'keys';
const KEY_ID = 'device-keypair';

export async function getOrCreateDeviceKeypair(): Promise<{
  publicKey: Uint8Array;
  privateKey: Uint8Array;
  deviceId: string; // SHA-256 hex of public key
}> {
  // Try loading from IndexedDB
  const stored = await loadFromIndexedDB();
  if (stored) return stored;

  // Generate new keypair
  const keypair = generateEd25519Keypair();
  const deviceId = bytesToHex(sha256(keypair.publicKey));

  // Persist to IndexedDB
  await saveToIndexedDB(keypair);

  return { ...keypair, deviceId };
}
```

**Key insight:** The device keypair is Ed25519, not secp256k1 -- it serves a different purpose (device identity in the registry) than the user's vault key (secp256k1 from Web3Auth). The device ID is the SHA-256 hash of the device's Ed25519 public key, providing deterministic, verifiable identity.

### Pattern 4: Registry CRUD Flow (Following Folder Metadata Pattern)

**What:** The full create/read/update cycle for the registry, following the established folder metadata pattern.

**When to use:** On every login (read or create) and when registering a new device (update).

**Example flow:** Read existing registry

```text
1. deriveRegistryIpnsKeypair(userPrivateKey) -> { ipnsKeypair, ipnsName }
2. resolveIpnsRecord(ipnsName) -> { cid, sequenceNumber } | null
3. If null: registry doesn't exist yet (first device)
4. If CID: fetchFromIpfs(cid) -> encryptedBytes
5. decryptRegistry(encryptedBytes, userPrivateKey) -> DeviceRegistry
```

**Example flow:** Create/update registry

```text
1. Modify registry (add device, update lastSeen, etc.)
2. encryptRegistry(registry, userPublicKey) -> encryptedBytes
3. addToIpfs(new Blob([encryptedBytes])) -> { cid }
4. createAndPublishIpnsRecord({
     ipnsPrivateKey: registryIpnsKeypair.privateKey,
     ipnsName: registryIpnsName,
     metadataCid: cid,
     sequenceNumber: registry.sequenceNumber + 1n,
   })
```

This exactly mirrors the flow in `updateFolderMetadata()` from `apps/web/src/services/folder.service.ts`.

### Anti-Patterns to Avoid

- **Storing registry IPNS name in the backend database as source of truth:** The backend should NOT be required for registry discovery. The whole point of deterministic derivation is that any session with the user's privateKey can derive the IPNS name independently. The backend may cache it for performance, but the client must not depend on it.

- **Using AES-GCM instead of ECIES for registry encryption:** ECIES is the correct choice because: (a) it's the established pattern for user-key-encrypted data in CipherBox, (b) it avoids needing to derive/manage a separate symmetric key, (c) any session with the user's publicKey can encrypt but only privateKey holders can decrypt.

- **Putting device private keys in memory-only stores:** Device keypairs must survive page refreshes and app restarts. They MUST be persisted (IndexedDB for web, keychain for desktop). Unlike the user's vault privateKey (which is re-derived from Web3Auth on each login), device keypairs are unique to each physical device and cannot be re-derived.

- **Blocking login on registry sync:** Registry operations should not block the main login flow. If IPNS resolution fails (network issue, first-ever publish not propagated yet), the user should still be able to access their vault. Registry sync can retry in the background.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem                | Don't Build                     | Use Instead                                                                                         | Why                                                                         |
| ---------------------- | ------------------------------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| HKDF key derivation    | Custom HKDF implementation      | `deriveKey()` from `packages/crypto/src/keys/derive.ts`                                             | Already uses Web Crypto HKDF-SHA256, handles buffer copying edge cases      |
| ECIES encryption       | Custom encrypt/decrypt          | `wrapKey()`/`unwrapKey()` from `packages/crypto/src/ecies/`                                         | Handles ephemeral key, ECDH, HKDF, AES-GCM internally via eciesjs           |
| Ed25519 key generation | Custom keygen                   | `generateEd25519Keypair()` from `packages/crypto/src/ed25519/keygen.ts`                             | Already configured with sha512Sync for @noble/ed25519 v2                    |
| IPNS record creation   | Custom protobuf encoding        | `createIpnsRecord()` from `packages/crypto/src/ipns/create-record.ts`                               | Handles libp2p key format conversion, V1+V2 signatures                      |
| IPNS name derivation   | Custom CID generation           | `deriveIpnsName()` from `packages/crypto/src/ipns/derive-name.ts`                                   | Handles PeerId, CIDv1, base36 encoding                                      |
| IPNS publish/resolve   | Direct delegated-ipfs.dev calls | `createAndPublishIpnsRecord()` / `resolveIpnsRecord()` from `apps/web/src/services/ipns.service.ts` | Handles backend relay, base64 encoding, signature verification, retry logic |
| IPFS upload/fetch      | Direct Pinata API calls         | `addToIpfs()` / `fetchFromIpfs()` from `apps/web/src/lib/api/ipfs.ts`                               | Handles auth token injection, progress tracking, backend relay              |
| Sync polling           | Custom setInterval              | `useSyncPolling()` pattern from `apps/web/src/hooks/useSyncPolling.ts`                              | Handles visibility, online status, concurrent execution guard, initial sync |
| SHA-256 hashing        | Web Crypto SHA-256              | `sha256()` from `@noble/hashes/sha256`                                                              | Synchronous, no async overhead, consistent with noble ecosystem             |
| Hex encoding/decoding  | Manual hex conversion           | `bytesToHex()` / `hexToBytes()` from `packages/crypto/src/utils/encoding.ts`                        | Already handles 0x prefix, validation                                       |

**Key insight:** Every crypto operation needed for the device registry already has an implementation in the codebase. The new code is primarily _composition_ -- combining existing primitives in the right order for the registry use case.

## Common Pitfalls

### Pitfall 1: ECIES Nondeterminism

**What goes wrong:** Each ECIES encryption produces different ciphertext due to ephemeral key generation. Content-addressing (CID) changes on every re-encryption even if the registry data hasn't changed.
**Why it happens:** ECIES generates a new ephemeral keypair per encryption call. This is by design for security (prevents ciphertext comparison attacks).
**How to avoid:** Accept that every registry update produces a new CID. Only re-encrypt and re-publish when the registry data actually changes. Use the sequence counter as the authoritative version, not CID comparison.
**Warning signs:** Unnecessary IPNS publishes when nothing changed (wasted rate limit).

### Pitfall 2: IPNS Resolution Failure on First Bootstrap

**What goes wrong:** First device creates registry and publishes IPNS, but the second device (logging in concurrently or moments later) tries to resolve IPNS and gets 404 because the record hasn't propagated through the delegated routing network yet.
**Why it happens:** IPNS record propagation via delegated-ipfs.dev is not instant. Can take 10-60 seconds for a new record to become resolvable.
**How to avoid:** When IPNS resolution returns null:

1. Check DB fallback (the backend caches the latest CID in the `folder_ipns` table already).
2. If DB also returns null, treat this as "registry doesn't exist yet" and create a new one with just the current device.
3. On the next sync poll (60s), re-resolve and merge if a newer registry appears.
   **Warning signs:** Two devices each creating their own "first device" registry, leading to one overwriting the other.

### Pitfall 3: Race Condition on Concurrent Device Registration

**What goes wrong:** Two devices register simultaneously, each reads the registry, adds themselves, and publishes. The second publish overwrites the first, losing one device entry.
**Why it happens:** Last-write-wins with no merge logic.
**How to avoid:** Per CONTEXT.md, this is an accepted trade-off since concurrent device registration is extremely rare (every few months). The sequence counter ensures ordering. If this becomes a real problem, a simple CRDT merge (union of entries, newer timestamp wins per device ID) can be added later (~50 lines per CONTEXT.md). For now, the lost entry will re-register on next login from that device.
**Warning signs:** Device appears as "pending" that was previously "authorized" (overwritten by stale read).

### Pitfall 4: Device Keypair Persistence Across Browser Contexts

**What goes wrong:** IndexedDB storage for the device keypair is origin-scoped and can be cleared by browser "Clear site data" or incognito mode.
**Why it happens:** IndexedDB follows same-origin policy and is not persistent across contexts.
**How to avoid:** Treat device keypair loss gracefully. If the stored keypair is gone, generate a new one. This creates a new device entry in the registry (the old one becomes orphaned). Orphan cleanup can be done manually or via the Phase 12.4 device management UI.
**Warning signs:** Same physical device showing up multiple times in the registry with different IDs.

### Pitfall 5: Blocking Login on Registry Operations

**What goes wrong:** Registry IPNS resolution or IPFS fetch fails (network issue), blocking the entire login flow and preventing the user from accessing their vault.
**Why it happens:** Registry operations depend on external services (delegated-ipfs.dev, Pinata) that can be slow or unavailable.
**How to avoid:** Registry initialization must be non-blocking. Fire it after vault keys are set, use try/catch, and log errors rather than throwing. The user should always be able to access their vault even if registry operations fail. Retry in the background via the polling loop.
**Warning signs:** Login hangs for 30+ seconds when IPNS network is slow.

### Pitfall 6: Using `wrapKey` Name Misleadingly

**What goes wrong:** Code review confusion because `wrapKey` sounds like it only wraps 32-byte keys, but it actually encrypts arbitrary data via ECIES.
**Why it happens:** The function was originally created for key wrapping (32-byte AES keys), but eciesjs internally uses AES-256-GCM for the symmetric portion, so any length data works.
**How to avoid:** Create a registry-specific wrapper function (`encryptRegistry` / `decryptRegistry`) that calls `wrapKey`/`unwrapKey` internally. This makes the intent clear without touching the existing API.

## Code Examples

### Device Registry Schema

```typescript
// packages/crypto/src/registry/types.ts

/** Authorization status for a device */
export type DeviceAuthStatus = 'pending' | 'authorized' | 'revoked';

/** Platform identifier */
export type DevicePlatform = 'web' | 'macos' | 'linux' | 'windows';

/** Individual device entry in the registry */
export type DeviceEntry = {
  /** SHA-256 hash of device's Ed25519 public key (hex) */
  deviceId: string;
  /** Device's Ed25519 public key (hex) - for future key exchange in Phase 12.4 */
  publicKey: string;
  /** Human-readable device name (e.g., "Michael's MacBook Pro") */
  name: string;
  /** Platform identifier */
  platform: DevicePlatform;
  /** App version string (e.g., "0.2.0") */
  appVersion: string;
  /** Device model or OS version (e.g., "macOS 15.2", "Chrome 123") */
  deviceModel: string;
  /** SHA-256 hash of IP address at registration (hex, privacy-preserving) */
  ipHash: string;
  /** Authorization status */
  status: DeviceAuthStatus;
  /** When device was first registered (Unix ms) */
  createdAt: number;
  /** Last time device synced with registry (Unix ms) */
  lastSeenAt: number;
  /** When device was revoked (Unix ms, null if not revoked) */
  revokedAt: number | null;
  /** Device ID of the device that performed revocation (null if not revoked) */
  revokedBy: string | null;
};

/** The full device registry */
export type DeviceRegistry = {
  /** Schema version for future migrations */
  version: 'v1';
  /** Monotonically increasing update counter */
  sequenceNumber: number;
  /** Array of all device entries (including revoked) */
  devices: DeviceEntry[];
};
```

### Deterministic IPNS Derivation Integration

```typescript
// Usage in login flow (apps/web/src/hooks/useAuth.ts)

// After vault keys are loaded...
const registryIpns = await deriveRegistryIpnsKeypair(userKeypair.privateKey);
// registryIpns.ipnsName is the same on every device for the same user
// registryIpns.privateKey can sign IPNS records for the registry
// registryIpns.publicKey is used to derive the IPNS name
```

### Device Registration Flow

```typescript
// apps/web/src/services/device-registry.service.ts

export async function registerDevice(params: {
  userPrivateKey: Uint8Array;
  userPublicKey: Uint8Array;
  deviceKeypair: { publicKey: Uint8Array; privateKey: Uint8Array };
  registryIpns: { privateKey: Uint8Array; ipnsName: string };
  deviceInfo: { name: string; platform: DevicePlatform; appVersion: string; deviceModel: string };
}): Promise<DeviceRegistry> {
  const { sha256 } = await import('@noble/hashes/sha256');
  const deviceId = bytesToHex(sha256(params.deviceKeypair.publicKey));

  // 1. Try to load existing registry
  let registry: DeviceRegistry | null = null;
  let currentSeq = 0n;

  const resolved = await resolveIpnsRecord(params.registryIpns.ipnsName);
  if (resolved) {
    const encryptedBytes = await fetchFromIpfs(resolved.cid);
    // fetchFromIpfs returns Uint8Array, pass directly to decryptRegistry
    registry = await decryptRegistry(encryptedBytes, params.userPrivateKey);
    currentSeq = resolved.sequenceNumber;
  }

  // 2. Create or update registry
  const now = Date.now();
  if (!registry) {
    // First device - create new registry, auto-authorized
    registry = {
      version: 'v1',
      sequenceNumber: 0,
      devices: [
        {
          deviceId,
          publicKey: bytesToHex(params.deviceKeypair.publicKey),
          name: params.deviceInfo.name,
          platform: params.deviceInfo.platform,
          appVersion: params.deviceInfo.appVersion,
          deviceModel: params.deviceInfo.deviceModel,
          ipHash: '', // Computed separately
          status: 'authorized',
          createdAt: now,
          lastSeenAt: now,
          revokedAt: null,
          revokedBy: null,
        },
      ],
    };
  } else {
    // Check if device already exists
    const existing = registry.devices.find((d) => d.deviceId === deviceId);
    if (existing) {
      existing.lastSeenAt = now;
      existing.appVersion = params.deviceInfo.appVersion;
    } else {
      // New device - register as pending
      registry.devices.push({
        deviceId,
        publicKey: bytesToHex(params.deviceKeypair.publicKey),
        name: params.deviceInfo.name,
        platform: params.deviceInfo.platform,
        appVersion: params.deviceInfo.appVersion,
        deviceModel: params.deviceInfo.deviceModel,
        ipHash: '',
        status: 'pending', // Non-blocking in Phase 12.2
        createdAt: now,
        lastSeenAt: now,
        revokedAt: null,
        revokedBy: null,
      });
    }
  }

  // 3. Increment sequence and publish
  registry.sequenceNumber++;
  const encryptedBlob = await encryptRegistry(registry, params.userPublicKey);
  const { cid } = await addToIpfs(new Blob([encryptedBlob]));

  await createAndPublishIpnsRecord({
    ipnsPrivateKey: params.registryIpns.privateKey,
    ipnsName: params.registryIpns.ipnsName,
    metadataCid: cid,
    sequenceNumber: BigInt(registry.sequenceNumber),
  });

  return registry;
}
```

### IndexedDB Device Keypair Persistence (Web)

```typescript
// apps/web/src/lib/device/identity.ts

const DB_NAME = 'cipherbox-device';
const DB_VERSION = 1;
const STORE_NAME = 'keys';
const KEYPAIR_KEY = 'device-ed25519';

function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onupgradeneeded = () => {
      request.result.createObjectStore(STORE_NAME);
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

export async function loadDeviceKeypair(): Promise<{
  publicKey: Uint8Array;
  privateKey: Uint8Array;
} | null> {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    return new Promise((resolve, reject) => {
      const request = store.get(KEYPAIR_KEY);
      request.onsuccess = () => {
        const val = request.result;
        if (val && val.publicKey && val.privateKey) {
          resolve({
            publicKey: new Uint8Array(val.publicKey),
            privateKey: new Uint8Array(val.privateKey),
          });
        } else {
          resolve(null);
        }
      };
      request.onerror = () => reject(request.error);
    });
  } catch {
    return null; // IndexedDB unavailable (incognito, etc.)
  }
}

export async function saveDeviceKeypair(keypair: {
  publicKey: Uint8Array;
  privateKey: Uint8Array;
}): Promise<void> {
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readwrite');
  const store = tx.objectStore(STORE_NAME);
  // Store as plain arrays (Uint8Array doesn't serialize well in IDB)
  store.put(
    {
      publicKey: Array.from(keypair.publicKey),
      privateKey: Array.from(keypair.privateKey),
    },
    KEYPAIR_KEY
  );
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
```

## State of the Art

| Old Approach (vault IPNS)                                                                            | New Approach (registry IPNS)                                            | When Changed            | Impact                                                                                                  |
| ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------- |
| Random Ed25519 keypair generated on server, ECIES-wrapped with user publicKey, stored in vault table | Deterministic Ed25519 keypair derived from user's privateKey via HKDF   | Phase 12.2 (this phase) | Registry IPNS is discoverable from privateKey alone, no backend dependency for discovery                |
| Single IPNS name per user (root folder)                                                              | Multiple IPNS names per user (root folder + registry, potentially more) | Phase 12.2 (this phase) | Existing IPNS publish/resolve endpoints handle this transparently (they don't enforce single-name)      |
| Vault IPNS key stored in backend DB                                                                  | Registry IPNS key derived client-side, never touches backend            | Phase 12.2 (this phase) | True self-sovereign recovery for registry (recovery phrase -> privateKey -> derive IPNS key -> resolve) |

**Note:** The vault's existing IPNS keys remain random/server-stored. Migrating them to deterministic derivation is a deferred idea per CONTEXT.md.

## Backend Changes Assessment

### Minimal Backend Changes Needed

The existing backend IPNS endpoints (`POST /ipns/publish` and `GET /ipns/resolve`) already support arbitrary IPNS names. No changes to the IPNS controller or service are needed -- the registry's IPNS name is just another k51... string.

The existing IPFS upload endpoint (`POST /ipfs/upload`) already supports arbitrary encrypted blobs. No changes needed.

**What IS needed (minimal):**

1. **No new API endpoints required.** The existing IPNS publish/resolve and IPFS upload/fetch endpoints handle the registry transparently.

2. **The `folder_ipns` table will track the registry IPNS** via the existing upsert logic in `IpnsService.publishRecord()`. The registry entry will have `isRoot: false` like subfolder IPNS entries. No schema change needed.

3. **TEE republishing consideration:** The registry IPNS record needs republishing like any other IPNS record. The existing TEE integration already handles this -- when `encryptedIpnsPrivateKey` and `keyEpoch` are provided in the publish request, the backend auto-enrolls for TEE republishing. However, for the deterministic IPNS key, we need to ECIES-wrap it with the TEE public key before sending. This follows the exact same pattern as subfolder IPNS keys.

4. **Rate limiting:** The existing rate limits (10 publishes/min, 30 resolves/min per user) are sufficient. Registry updates are infrequent (login events, ~1/day).

### Desktop App Integration

The desktop app (`apps/desktop`) currently gets its key material from the webview via Tauri IPC commands (`handle_auth_complete`). The webview passes the user's privateKey (from Web3Auth Core Kit) to the Rust backend, which stores it in `AppState`.

For device registration:

- **Web app:** Generates device keypair, stores in IndexedDB, handles registry operations directly.
- **Desktop app:** The webview portion handles registry operations (same TypeScript code). The Rust backend doesn't need to know about the registry. Device keypair for desktop can be stored in the macOS keychain via the existing `keyring` crate pattern.

## Open Questions

Things that couldn't be fully resolved:

1. **Device name auto-detection**
   - What we know: Web can use `navigator.userAgent` for browser info, `navigator.platform` for OS. Desktop (Tauri) has `os.platform()` and hostname.
   - What's unclear: Exact format for human-readable device names across platforms. Should it be "Michael's MacBook Pro - Chrome" or "Chrome on macOS"?
   - Recommendation: Use a simple format like `${browserOrAppName} on ${osName}` for web, `CipherBox Desktop on ${hostname}` for desktop. Let users rename devices in Phase 12.4.

2. **IP hash for device registration**
   - What we know: CONTEXT.md specifies `ipHash` (SHA-256 of IP address) for "was this you?" prompts in Phase 12.4.
   - What's unclear: How to get the client's IP on the client side. The client doesn't know its own public IP. Would need to call the backend or an external service.
   - Recommendation: Have the backend return the client's IP in a new field on an existing endpoint (e.g., in the auth login response or a dedicated `/whoami` endpoint). Client hashes it locally before storing in registry.

3. **Registry size growth over time**
   - What we know: 2-10 devices per user, <10KB total per CONTEXT.md. Revoked devices stay for audit trail.
   - What's unclear: At what point (if ever) should old revoked devices be pruned?
   - Recommendation: No pruning in Phase 12.2. If a user somehow accumulates 100+ revoked devices, the registry would still be <100KB, well within ECIES and IPFS limits.

4. **Desktop device keypair storage specifics**
   - What we know: macOS keychain via `keyring` crate is used for refresh tokens. Same pattern works for device keypair.
   - What's unclear: Exact keychain entry format for Ed25519 keypair (single entry with both keys? Two entries?)
   - Recommendation: Store as a single keychain entry with hex-encoded `privateKey:publicKey` (64+64=128 hex chars). Parse on read.

## Sources

### Primary (HIGH confidence)

- Existing `packages/crypto/src/` source code -- verified all HKDF, ECIES, Ed25519, IPNS functions
- Existing `apps/web/src/services/` source code -- verified folder metadata and IPNS publish patterns
- Existing `apps/api/src/ipns/` source code -- verified backend IPNS publish/resolve accept arbitrary names
- `eciesjs` v0.4.16 source and [npm docs](https://www.npmjs.com/package/eciesjs) -- verified arbitrary-length payload support
- `@noble/ed25519` v2.3.0 source -- verified deterministic key derivation from 32-byte seed
- `@noble/hashes` v1.7.1 -- verified SHA-256 availability at `@noble/hashes/sha256`

### Secondary (MEDIUM confidence)

- [eciesjs GitHub](https://github.com/ecies/js) -- payload format: 65 bytes ephemeral pubkey + 16 nonce + 16 tag + ciphertext
- [noble-ed25519 GitHub](https://github.com/paulmillr/noble-ed25519) -- getPublicKey() from 32-byte seed is deterministic

### Tertiary (LOW confidence)

- None. All findings verified against codebase and official sources.

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - all libraries already in the monorepo, versions verified
- Architecture: HIGH - patterns directly mirror existing folder metadata / IPNS flows
- Crypto operations: HIGH - all primitives exist, verified API compatibility (wrapKey handles arbitrary data, HKDF produces 32-byte Ed25519 seeds, deriveIpnsName works with any Ed25519 public key)
- Pitfalls: HIGH - based on real codebase analysis and known IPNS propagation behavior
- Desktop integration: MEDIUM - keychain pattern is established but device keypair storage specifics are estimated

**Research date:** 2026-02-13
**Valid until:** 2026-03-15 (stable - no fast-moving dependencies)
