# Phase 9.1: Environment Changes, DevOps & Staging Deployment - Research

**Researched:** 2026-02-09
**Domain:** CI/CD, Docker, IPFS hosting, VPS deployment, environment configuration
**Confidence:** HIGH (based on codebase analysis, existing workflows, official documentation)

## Summary

This research investigates what is needed to deploy CipherBox to a staging environment on a Hostinger VPS, with the web app hosted on IPFS via Pinata and served through Cloudflare. The project already has a functional CI pipeline (lint, test, build, E2E) and Docker Compose for local infrastructure (Postgres, Kubo, Redis, mock-IPNS-routing). What is missing: Dockerfiles for the API and TEE worker, a staging Docker Compose file, a deployment workflow triggered by git tags, Pinata-based web hosting, Cloudflare DNS/SSL configuration, and environment-specific configuration.

A critical finding is that IPNS keypairs are currently randomly generated (not HKDF-derived from user keys), which means environment isolation already works naturally when databases are separate. The `CIPHERBOX_ENVIRONMENT` env var is still needed for the TEE worker mode and delegated routing URL selection, but the HKDF environment salt for IPNS key derivation described in ENVIRONMENTS.md is NOT needed yet. The planner should add the environment variables without implementing the HKDF derivation change, and add a comment noting it is deferred until a future phase where IPNS keys switch to derived keys.

**Primary recommendation:** Focus on Dockerizing the API, creating a staging Docker Compose, building a tag-triggered deployment workflow, and setting up Pinata + Cloudflare for the web app. The environment salt HKDF change should be deferred since it is not needed with separate databases per environment.

## Standard Stack

The established tools for this deployment domain:

### Core

| Tool                             | Version   | Purpose                       | Why Standard                                            |
| -------------------------------- | --------- | ----------------------------- | ------------------------------------------------------- |
| Docker                           | 24+       | Container runtime             | Industry standard for app deployment                    |
| Docker Compose                   | v2        | Multi-container orchestration | Already used in project for local infra                 |
| GitHub Actions                   | N/A       | CI/CD pipeline                | Already in use, 3 existing workflows                    |
| GHCR (GitHub Container Registry) | N/A       | Docker image storage          | Free for public repos, integrated with GH Actions       |
| Cloudflare                       | N/A       | DNS, SSL, CDN                 | User already has domain registered with CF              |
| Pinata                           | Free tier | IPFS pinning for web app      | Already used for file storage, has directory upload API |

### Supporting

| Tool                       | Purpose                              | When to Use                                                    |
| -------------------------- | ------------------------------------ | -------------------------------------------------------------- |
| Caddy                      | Reverse proxy on VPS                 | Route API traffic with automatic TLS from Cloudflare Origin CA |
| `appleboy/ssh-action`      | GitHub Action for SSH commands       | Execute docker compose commands on VPS                         |
| `docker/login-action`      | GitHub Action for GHCR auth          | Authenticate before pushing images                             |
| `docker/build-push-action` | GitHub Action for building + pushing | Multi-platform Docker builds                                   |

### Alternatives Considered

| Instead of | Could Use  | Tradeoff                                                                               |
| ---------- | ---------- | -------------------------------------------------------------------------------------- |
| Caddy      | Nginx      | Caddy has automatic HTTPS and simpler config; Nginx is more mature but verbose         |
| SSH deploy | Watchtower | Watchtower auto-pulls but less control over when; SSH is explicit and auditable        |
| GHCR       | Docker Hub | GHCR is free for GitHub users and integrates natively; Docker Hub has pull rate limits |

## Architecture Patterns

### Recommended Staging Architecture on VPS

```text
Internet
    |
Cloudflare (SSL termination + CDN)
    |
    +-- app.staging.cipherbox.cc --> Cloudflare IPFS Gateway (DNSLink)
    |                               TXT _dnslink.app.staging.cipherbox.cc = dnslink=/ipfs/<CID>
    |
    +-- api.staging.cipherbox.cc --> VPS:443 (Caddy reverse proxy)
                              |
                              +-- localhost:3000 (API container)
                              +-- localhost:5432 (Postgres container)
                              +-- localhost:6379 (Redis container)
                              +-- localhost:5001 (Kubo IPFS container)
                              +-- localhost:3001 (TEE worker container)
```

### Recommended Docker Image Structure

The API is a pnpm monorepo app. It does NOT depend on `@cipherbox/crypto` (crypto is client-side only). The API can be built as a standalone Docker image.

The TEE worker already has a Dockerfile and is standalone (not a pnpm workspace member).

```text
API Dockerfile (apps/api/Dockerfile):
  Stage 1: Install dependencies (pnpm, node_modules)
  Stage 2: Build (nest build -> dist/)
  Stage 3: Production (copy dist + node_modules, run node dist/main.js)

TEE Worker Dockerfile (tee-worker/Dockerfile):
  Already exists - builds with npm, runs dist/index.js
  Needs minor update: TEE_MODE=simulator for staging (not CVM)

Web App:
  No Dockerfile needed - built locally by CI, uploaded to Pinata as static files
```

### Recommended Docker Compose for Staging

```yaml
# docker/docker-compose.staging.yml
services:
  api:
    image: ghcr.io/<owner>/cipherbox-api:${TAG:-latest}
    restart: unless-stopped
    env_file: .env.staging
    ports:
      - '127.0.0.1:3000:3000'
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DB_USERNAME}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: cipherbox_staging
    volumes:
      - postgres_staging:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    ports:
      - '127.0.0.1:6379:6379'
    volumes:
      - redis_staging:/data
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 5s
      retries: 5

  ipfs:
    image: ipfs/kubo:v0.34.0
    restart: unless-stopped
    environment:
      IPFS_PROFILE: server
    ports:
      - '4001:4001/tcp'
      - '4001:4001/udp'
      - '127.0.0.1:5001:5001'
      - '127.0.0.1:8080:8080'
    volumes:
      - ipfs_staging:/data/ipfs
    healthcheck:
      test: ['CMD-SHELL', 'ipfs id || exit 1']
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'

  tee-worker:
    image: ghcr.io/<owner>/cipherbox-tee-worker:${TAG:-latest}
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 3001
      TEE_MODE: simulator
      TEE_WORKER_SECRET: ${TEE_WORKER_SECRET}
    ports:
      - '127.0.0.1:3001:3001'

  caddy:
    image: caddy:2-alpine
    restart: unless-stopped
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
      - ./certs:/etc/caddy/certs # Cloudflare Origin CA certs

volumes:
  postgres_staging:
  redis_staging:
  ipfs_staging:
  caddy_data:
  caddy_config:
```

### Tag-Based Deployment Workflow Pattern

```yaml
on:
  push:
    tags:
      - 'v*-staging*' # e.g., v1.0.0-staging.1
      - 'v*' # e.g., v1.0.0 (for future production)
```

The workflow should:

1. Build API Docker image + TEE worker Docker image
2. Push both to GHCR with tag-based naming
3. Build web app with staging env vars
4. Upload web app build to Pinata, get CID
5. Update Cloudflare DNSLink TXT record with new CID
6. SSH into VPS, pull new images, restart with `docker compose up -d`

### Anti-Patterns to Avoid

- **Hardcoded port 3000 in main.ts:** Make the port configurable via `PORT` env var for container flexibility
- **`synchronize: true` in staging:** Already handled -- `NODE_ENV=production` disables synchronize. But migrations must be run before starting the API
- **Storing .env files in the repo:** All secrets come from GitHub Secrets, CI generates .env and SCPs to VPS
- **Exposing Kubo API (5001) to the internet:** Always bind to 127.0.0.1 on VPS
- **Running containers as root:** Use non-root user in Dockerfiles

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem                 | Don't Build            | Use Instead                                                   | Why                                           |
| ----------------------- | ---------------------- | ------------------------------------------------------------- | --------------------------------------------- |
| SSH from GitHub Actions | Custom SSH scripts     | `appleboy/ssh-action@v1`                                      | Handles key management, known_hosts, timeouts |
| Docker build + push     | Manual docker commands | `docker/build-push-action@v5`                                 | Multi-platform, caching, provenance           |
| GHCR authentication     | Manual docker login    | `docker/login-action@v3`                                      | Handles token exchange with GITHUB_TOKEN      |
| Reverse proxy with TLS  | Manual nginx config    | Caddy (automatic HTTPS)                                       | Zero-config TLS, Cloudflare Origin CA support |
| Cloudflare DNS updates  | curl to CF API         | `cloudflare/cloudflare-go` or direct API with existing action | Well-tested, handles pagination/retry         |
| Pinata file upload      | curl to Pinata API     | `pinata/upload-action` or Pinata SDK/CLI                      | Handles directory uploads, retries            |

**Key insight:** The deployment pipeline has many moving parts (Docker, GHCR, SSH, Pinata, Cloudflare). Using established GitHub Actions for each step avoids subtle bugs in authentication, retries, and error handling.

## Common Pitfalls

### Pitfall 1: Database Migrations in Production Mode

**What goes wrong:** API starts with `NODE_ENV=production`, `synchronize` is disabled, but no migrations have been run. Tables don't exist, API crashes on first request.
**Why it happens:** In local dev, `synchronize: true` auto-creates tables. In staging/production, this is disabled for safety.
**How to avoid:** Run `pnpm --filter @cipherbox/api migration:run` (or equivalent in Docker) BEFORE starting the API container. The deployment script should generate a migration from the current entity state and run it. Alternatively, for initial staging setup, run `synchronize: true` once, then generate a migration that captures the full schema.
**Warning signs:** API container starts but returns 500 errors on all endpoints.

### Pitfall 2: Monorepo Docker Build Context

**What goes wrong:** The API is at `apps/api/` but needs the root `pnpm-workspace.yaml`, `pnpm-lock.yaml`, and potentially `packages/` for build. Setting Docker context to `apps/api/` alone fails.
**Why it happens:** pnpm monorepo apps resolve workspace dependencies during install.
**How to avoid:** Set Docker build context to the repo root, use `.dockerignore` to exclude unnecessary files, and reference the Dockerfile with `-f apps/api/Dockerfile`. Since the API does NOT depend on `@cipherbox/crypto` workspace package, the build is simpler -- it only needs its own source and dependencies. But pnpm still needs the workspace root for lockfile resolution.
**Warning signs:** `pnpm install --frozen-lockfile` fails inside Docker build.

### Pitfall 3: CORS Configuration for Staging

**What goes wrong:** Web app at `https://app.staging.cipherbox.cc` tries to call API at `https://api.staging.cipherbox.cc`, CORS blocks the request.
**Why it happens:** The API's `WEB_APP_URL` env var must include the staging frontend origin.
**How to avoid:** Set `WEB_APP_URL=https://app.staging.cipherbox.cc` in the staging environment. The CORS config already supports comma-separated origins.
**Warning signs:** Browser console shows CORS errors on API calls.

### Pitfall 4: TEE Worker Mode for Staging

**What goes wrong:** TEE worker starts with `TEE_MODE=cvm` on staging VPS, tries to access Phala dstack SDK, crashes because there is no CVM runtime.
**Why it happens:** The TEE worker was designed for Phala Cloud CVM. On a regular VPS, `TEE_MODE=simulator` must be used.
**How to avoid:** Set `TEE_MODE=simulator` in the staging docker-compose. The tee-keys.ts code already has a simulator path that uses HKDF with a fixed seed. Note: the code blocks `TEE_MODE=simulator` when `NODE_ENV=production` (line 30-33 of tee-keys.ts). This guard needs to be relaxed for staging, perhaps checking `CIPHERBOX_ENVIRONMENT` instead.
**Warning signs:** TEE worker container exits immediately with "TEE_MODE=simulator is not allowed in production" error.

### Pitfall 5: Cloudflare Proxy and WebSocket

**What goes wrong:** If future features need WebSocket connections, Cloudflare proxy can interfere.
**Why it happens:** Cloudflare proxied connections have different timeout behaviors.
**How to avoid:** Not a current issue (no WebSocket in CipherBox v1), but worth noting for future.

### Pitfall 6: Pinata Directory Upload for SPAs

**What goes wrong:** Direct navigation to `app.staging.cipherbox.cc/files/some-id` returns 404 because IPFS serves static files -- there is no server-side routing to redirect to `index.html`.
**Why it happens:** Vite SPA builds expect a server that serves `index.html` for all routes. IPFS gateway serves files literally by path.
**How to avoid:** Ensure the Vite build generates a proper SPA with hash-based routing, OR configure the Pinata gateway / Cloudflare Worker to serve `index.html` for all paths. CipherBox currently uses `react-router-dom` which likely uses browser history routing. This needs to switch to hash routing for IPFS hosting, or use a Cloudflare Worker/Pages Function to rewrite paths.
**Warning signs:** App loads on root URL but 404s on any nested route after page refresh.

### Pitfall 7: Redis Port Mismatch

**What goes wrong:** In the local Docker Compose, Redis maps host port 6380 to container port 6379. The API's default `REDIS_PORT` is 6379. If the staging compose maps differently, the API can't connect.
**How to avoid:** In the staging Docker Compose, the API container connects to Redis via Docker networking (not host ports). Use service names: `REDIS_HOST=redis` and `REDIS_PORT=6379`.
**Warning signs:** API logs show "ECONNREFUSED" for Redis.

## Code Examples

### API Dockerfile (Multi-Stage Build)

```dockerfile
# Stage 1: Install dependencies
FROM node:22-alpine AS deps
RUN corepack enable && corepack prepare pnpm@10 --activate
WORKDIR /app
COPY pnpm-lock.yaml pnpm-workspace.yaml package.json ./
COPY apps/api/package.json apps/api/
RUN pnpm install --frozen-lockfile --filter @cipherbox/api

# Stage 2: Build
FROM deps AS build
COPY apps/api/ apps/api/
COPY tsconfig.base.json ./
RUN pnpm --filter @cipherbox/api build

# Stage 3: Production
FROM node:22-alpine AS production
RUN addgroup -g 1001 -S appgroup && adduser -S appuser -u 1001 -G appgroup
WORKDIR /app
COPY --from=build /app/apps/api/dist ./dist
COPY --from=deps /app/node_modules ./node_modules
COPY --from=deps /app/apps/api/node_modules ./apps/api/node_modules
USER appuser
ENV NODE_ENV=production
ENV PORT=3000
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

**Note:** The above is a starting point. The actual Dockerfile may need adjustment for pnpm's hoisted vs non-hoisted node_modules structure. Testing the build is essential.

### Caddy Configuration for Staging

```text
# Caddyfile
{
    auto_https off  # Cloudflare handles TLS termination
}

:443 {
    tls /etc/caddy/certs/origin.pem /etc/caddy/certs/origin-key.pem

    reverse_proxy localhost:3000
}

:80 {
    redir https://{host}{uri} permanent
}
```

### Tag-Based Deployment Workflow (Skeleton)

```yaml
name: Deploy Staging

on:
  push:
    tags:
      - 'v*-staging*'

env:
  REGISTRY: ghcr.io
  API_IMAGE: ghcr.io/${{ github.repository_owner }}/cipherbox-api
  TEE_IMAGE: ghcr.io/${{ github.repository_owner }}/cipherbox-tee-worker

jobs:
  build-api:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/api/Dockerfile
          push: true
          tags: |
            ${{ env.API_IMAGE }}:${{ github.ref_name }}
            ${{ env.API_IMAGE }}:latest

  build-tee:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          context: ./tee-worker
          file: tee-worker/Dockerfile
          push: true
          tags: |
            ${{ env.TEE_IMAGE }}:${{ github.ref_name }}
            ${{ env.TEE_IMAGE }}:latest

  deploy-web:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
      - run: pnpm install --frozen-lockfile
      - run: pnpm --filter @cipherbox/crypto build
      - run: pnpm --filter @cipherbox/web build
        env:
          VITE_WEB3AUTH_CLIENT_ID: ${{ secrets.VITE_WEB3AUTH_CLIENT_ID }}
          VITE_API_URL: https://api.staging.cipherbox.cc
          VITE_PINATA_GATEWAY_URL: https://gateway.pinata.cloud/ipfs
          VITE_ENVIRONMENT: staging
      # Upload dist/ to Pinata, get CID
      # Update Cloudflare DNSLink TXT record

  deploy-vps:
    needs: [build-api, build-tee]
    runs-on: ubuntu-latest
    steps:
      - uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/cipherbox
            docker compose -f docker-compose.staging.yml pull
            docker compose -f docker-compose.staging.yml up -d
```

### Environment Variable Template for Staging

```bash
# Generated by CI from GitHub Secrets, SCP'd to VPS
NODE_ENV=production
CIPHERBOX_ENVIRONMENT=staging

# Database
DB_HOST=postgres        # Docker service name, not localhost
DB_PORT=5432
DB_USERNAME=cipherbox
DB_PASSWORD=<from-github-secrets>
DB_DATABASE=cipherbox_staging

# JWT
JWT_SECRET=<from-github-secrets>

# CORS
WEB_APP_URL=https://app.staging.cipherbox.cc

# IPFS
IPFS_PROVIDER=local
IPFS_LOCAL_API_URL=http://ipfs:5001     # Docker service name
IPFS_LOCAL_GATEWAY_URL=http://ipfs:8080 # Docker service name

# Delegated Routing
DELEGATED_ROUTING_URL=https://delegated-ipfs.dev

# Redis
REDIS_HOST=redis   # Docker service name
REDIS_PORT=6379

# TEE Worker
TEE_WORKER_URL=http://tee-worker:3001   # Docker service name
TEE_WORKER_SECRET=<from-github-secrets>
```

## Critical Findings

### Finding 1: IPNS Keys Are Random, Not HKDF-Derived (HIGH confidence)

**Current state:** IPNS keypairs are randomly generated via `generateEd25519Keypair()` (uses `ed25519.utils.randomPrivateKey()`), both for root vault IPNS keys (`initializeVault()` in `packages/crypto/src/vault/init.ts`) and subfolder IPNS keys (`createFolder()` in `apps/web/src/services/folder.service.ts`).

**ENVIRONMENTS.md assumption:** The environment isolation design assumes "The IPNS keypair is derived from the user's vault key" and proposes adding environment context to the HKDF `info` parameter. This derivation does not exist in the codebase.

**Impact:** Environment isolation already works naturally with separate databases per environment. Each environment gets different random IPNS keys, so there are no sequence number conflicts. The HKDF environment salt is NOT needed for staging deployment.

**Recommendation:** Add `CIPHERBOX_ENVIRONMENT` and `VITE_ENVIRONMENT` env vars for other purposes (TEE mode selection, API URL, future use) but defer the HKDF-based IPNS key derivation change. Document this as a future enhancement for when/if IPNS keys switch from random to derived.

### Finding 2: TEE Worker Blocks Simulator in Production (HIGH confidence)

In `tee-worker/src/services/tee-keys.ts`, lines 30-33:

```typescript
if (mode === 'simulator' && process.env.NODE_ENV === 'production') {
  throw new Error('TEE_MODE=simulator is not allowed in production...');
}
```

The staging environment needs `NODE_ENV=production` (for TypeORM synchronize=false and other production behaviors) but also `TEE_MODE=simulator` (since there is no CVM on the VPS). This guard needs to check `CIPHERBOX_ENVIRONMENT` instead of `NODE_ENV`, allowing simulator mode in staging but blocking it in production.

### Finding 3: API Port is Hardcoded (HIGH confidence)

In `apps/api/src/main.ts`, line 40: `await app.listen(3000)`. This should read from `process.env.PORT || 3000` for container flexibility.

### Finding 4: Database Migrations Needed for Staging (HIGH confidence)

`synchronize` is disabled when `NODE_ENV=production`. The project has 2 existing migration files but these are incremental (adding nullable fields, adding token prefix). A full schema migration needs to be generated that captures the current complete schema state, so a fresh staging database can be initialized.

### Finding 5: SPA Routing on IPFS (MEDIUM confidence)

CipherBox uses `react-router-dom` v7 with browser history routing (`/files/:folderId?`). IPFS gateways serve files literally by path, so navigating to `app.staging.cipherbox.cc/files/abc` will 404 because there is no `files/abc/index.html`. Options:

1. Switch to hash-based routing (`#/files/abc`) -- simplest, works everywhere
2. Use a Cloudflare Worker to rewrite all paths to `/index.html` -- preserves clean URLs
3. Use Pinata's gateway root feature -- may handle SPA routing

This needs resolution before deployment. Hash routing is the simplest and most IPFS-native solution.

### Finding 6: Web App Needs @cipherbox/crypto Built First (HIGH confidence)

The web app depends on `@cipherbox/crypto` as a workspace package. The CI build already does this correctly: `pnpm --filter @cipherbox/crypto --filter @cipherbox/web build`. The deploy workflow must build crypto before web.

### Finding 7: TEE Worker Is Not in pnpm Workspace (HIGH confidence)

The TEE worker lives at `tee-worker/` (not `apps/tee-worker/`), is not listed in `pnpm-workspace.yaml`, and uses `npm` (not `pnpm`). Its existing Dockerfile uses `npm ci --production`. This is intentional -- the TEE worker is designed for standalone deployment in a CVM.

## State of the Art

| Old Approach                       | Current Approach                   | When Changed | Impact                                                     |
| ---------------------------------- | ---------------------------------- | ------------ | ---------------------------------------------------------- |
| Docker Compose v1 (docker-compose) | Docker Compose v2 (docker compose) | 2023         | Use `docker compose` (space) not `docker-compose` (hyphen) |
| Manual GHCR login                  | `docker/login-action@v3`           | 2024         | Simpler auth with GITHUB_TOKEN                             |
| Manual Docker builds               | `docker/build-push-action@v5`      | 2024         | Multi-platform, caching, SBOM support                      |
| Pinata SDK v1                      | Pinata SDK v2+ / API v3            | 2024         | New upload endpoint at `uploads.pinata.cloud/v3/files`     |
| Nginx manual config                | Caddy automatic HTTPS              | 2020+        | Zero-config TLS, simpler reverse proxy                     |

## GitHub Secrets Needed for Staging

| Secret Name                 | Purpose                              | Where Used          |
| --------------------------- | ------------------------------------ | ------------------- |
| `STAGING_HOST`              | VPS IP address or hostname           | SSH deploy action   |
| `STAGING_USER`              | SSH username on VPS                  | SSH deploy action   |
| `STAGING_SSH_KEY`           | SSH private key for VPS access       | SSH deploy action   |
| `STAGING_DB_PASSWORD`       | PostgreSQL password for staging      | .env generation     |
| `STAGING_JWT_SECRET`        | JWT signing secret for staging       | .env generation     |
| `STAGING_TEE_WORKER_SECRET` | Shared secret for API-TEE auth       | .env generation     |
| `VITE_WEB3AUTH_CLIENT_ID`   | Web3Auth client ID (already exists)  | Web app build       |
| `PINATA_JWT`                | Pinata API JWT for uploading web app | Web deploy step     |
| `CLOUDFLARE_API_TOKEN`      | Cloudflare API token for DNS updates | DNSLink update step |
| `CLOUDFLARE_ZONE_ID`        | Cloudflare zone ID for the domain    | DNSLink update step |

## Cloudflare Configuration

### DNS Records Needed

| Type  | Name                   | Content               | Proxy                  | Purpose                         |
| ----- | ---------------------- | --------------------- | ---------------------- | ------------------------------- |
| A     | api.staging            | `<VPS IP>`            | Proxied (orange cloud) | API endpoint                    |
| CNAME | app.staging            | `cloudflare-ipfs.com` | Proxied                | Web app via IPFS gateway        |
| TXT   | `_dnslink.app.staging` | `dnslink=/ipfs/<CID>` | DNS only (gray cloud)  | Points to current web app build |

Note: IPFS (Kubo) and TEE worker do NOT need external DNS records. The browser fetches files through the API backend (which proxies to Kubo internally), and the TEE worker is only called by the API via Docker networking.

### SSL/TLS Settings

- **SSL Mode:** Full (Strict) -- requires valid cert on origin
- **Origin Certificate:** Generate Cloudflare Origin CA certificate (free, 15-year validity)
- Install origin cert + key in Caddy on VPS
- Cloudflare handles browser-facing TLS; Caddy handles Cloudflare-to-origin TLS

### Cloudflare Web3 Gateway

Alternatively, use Cloudflare's Web3 gateway feature:

1. Dashboard > Web3 > Create Gateway
2. Target: IPFS DNSLink
3. Hostname: `app.staging.cipherbox.cc`
4. This automatically configures the CNAME and TLS

## Open Questions

Things that could not be fully resolved:

1. **SPA routing on IPFS gateway**
   - What we know: Browser history routing will not work on IPFS. Hash routing works. Cloudflare Workers can rewrite paths.
   - What is unclear: Whether Cloudflare's Web3 gateway supports path rewriting for SPAs, or if a separate Worker is needed.
   - Recommendation: Switch to hash-based routing as the simplest solution. It is the most IPFS-native approach and avoids the need for any server-side configuration.

2. **Pinata directory upload in CI**
   - What we know: Pinata API v3 supports directory uploads via FormData with multiple files. Pinata CLI also supports `pinata upload <directory>`.
   - What is unclear: Whether there is a maintained GitHub Action for Pinata uploads, or if a custom script is needed.
   - Recommendation: Use Pinata CLI (`npx pinata upload dist/`) or a custom script with the API. Both are straightforward.

3. **Full schema migration for fresh database**
   - What we know: Existing migrations are incremental. A fresh database needs the full schema.
   - What is unclear: Whether `synchronize: true` should be run once to create the schema, then a snapshot migration generated, OR whether a full migration should be hand-written.
   - Recommendation: Generate a full schema migration using `typeorm migration:generate` against a clean database. This creates a single migration file that sets up the complete schema.

4. **VPS sizing for Kubo + API + Postgres + Redis + TEE Worker**
   - What we know: Kubo has a 2GB memory limit in the existing Docker Compose. API, Postgres, Redis, and TEE worker each need ~256-512MB.
   - What is unclear: Minimum VPS specs needed. Kubo in online mode with server profile may use significant CPU for DHT operations.
   - Recommendation: Start with 4GB RAM / 2 vCPU VPS. Monitor and scale if needed. Staging data is disposable.

## Sources

### Primary (HIGH confidence)

- Codebase analysis: Direct reading of all workflow files, Docker files, source code
- `apps/api/src/app.module.ts` -- TypeORM config, synchronize behavior
- `tee-worker/src/services/tee-keys.ts` -- TEE mode guard
- `packages/crypto/src/vault/init.ts` -- Random IPNS key generation
- `packages/crypto/src/ed25519/keygen.ts` -- Ed25519 random keypair
- `apps/web/src/services/folder.service.ts` -- Subfolder random IPNS key generation

### Secondary (MEDIUM confidence)

- [Cloudflare IPFS Gateway DNSLink docs](https://developers.cloudflare.com/web3/ipfs-gateway/concepts/dnslink/)
- [Cloudflare Origin CA docs](https://developers.cloudflare.com/ssl/origin-configuration/origin-ca/)
- [Pinata upload docs](https://docs.pinata.cloud/pinning/pinning-files)
- [NestJS Docker production guide](https://www.tomray.dev/nestjs-docker-production)
- [GitHub Actions Docker deploy patterns](https://medium.com/@DynamoDevOps/complete-guide-ci-cd-with-github-actions-and-docker-deploy-to-ghcr-with-ssh-authentication-75fcce3e87a2)
- [Pinata static website hosting](https://pinata.cloud/blog/how-to-ship-a-static-website-to-ipfs-with-pinata/)
- [IPFS hosting with Pinata and Cloudflare](https://alphasec.io/how-to-host-a-website-on-ipfs-using-pinata-and-cloudflare/)

### Tertiary (LOW confidence)

- VPS sizing recommendations (based on general experience, not verified for this specific stack)

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH -- based on codebase analysis and existing patterns
- Architecture: HIGH -- Docker Compose pattern already established in project
- IPNS key derivation finding: HIGH -- verified by reading actual source code
- TEE simulator guard: HIGH -- verified in source code
- Cloudflare + IPFS hosting: MEDIUM -- official docs confirm approach, specific SPA routing behavior unverified
- Pitfalls: HIGH -- derived from codebase analysis
- VPS sizing: LOW -- estimated, not benchmarked

**Research date:** 2026-02-09
**Valid until:** 2026-03-09 (30 days -- stable infrastructure patterns)
