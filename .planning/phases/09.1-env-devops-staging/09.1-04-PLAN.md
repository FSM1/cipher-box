---
phase: 09.1-env-devops-staging
plan: 04
type: execute
wave: 2
depends_on: ['09.1-01', '09.1-02', '09.1-03']
files_modified:
  - .github/workflows/deploy-staging.yml
  - tee-worker/Dockerfile
autonomous: true

must_haves:
  truths:
    - 'Pushing a tag matching v*-staging* triggers the deployment workflow'
    - 'Workflow builds and pushes API and TEE worker Docker images to GHCR'
    - 'Workflow builds the web app with staging env vars and uploads to Pinata'
    - 'Workflow updates Cloudflare DNSLink TXT record with new web app CID'
    - 'Workflow SSHs into VPS to pull new images and restart Docker Compose'
  artifacts:
    - path: '.github/workflows/deploy-staging.yml'
      provides: 'Tag-triggered staging deployment pipeline'
      contains: 'v*-staging*'
      min_lines: 80
    - path: 'tee-worker/Dockerfile'
      provides: 'Multi-stage TEE worker Docker build'
      contains: 'FROM node:20-alpine'
  key_links:
    - from: '.github/workflows/deploy-staging.yml'
      to: 'apps/api/Dockerfile'
      via: 'docker/build-push-action'
      pattern: 'apps/api/Dockerfile'
    - from: '.github/workflows/deploy-staging.yml'
      to: 'docker/docker-compose.staging.yml'
      via: 'SSH command'
      pattern: 'docker-compose.staging.yml'
---

<objective>
Create the GitHub Actions deployment workflow that builds, pushes, and deploys all components to staging when a version tag is pushed. Also update the TEE worker Dockerfile to be multi-stage for CI builds.

Purpose: This is the automation that connects code changes to a running staging environment. Tag a release, and CI handles building Docker images, deploying the web app to IPFS, and restarting services on the VPS.

Output: A GitHub Actions workflow file and an updated TEE worker Dockerfile.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09.1-env-devops-staging/09.1-CONTEXT.md
@.planning/phases/09.1-env-devops-staging/09.1-RESEARCH.md
@.github/workflows/ci.yml
@.planning/phases/09.1-env-devops-staging/09.1-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
<name>Task 1: Update TEE worker Dockerfile to multi-stage</name>
<files>
tee-worker/Dockerfile
</files>
<action>

The current TEE worker Dockerfile expects pre-built `dist/` directory. Update it to be multi-stage so CI can build from source without a separate build step.

Stage 1 (build): FROM node:20-alpine AS build, WORKDIR /app, COPY package.json package-lock.json, RUN npm ci, COPY src/ tsconfig.json, RUN npm run build.

Stage 2 (production): FROM node:20-alpine, WORKDIR /app, COPY --from=build /app/dist ./dist, COPY --from=build /app/node_modules ./node_modules, COPY package.json ./, ENV NODE_ENV=production PORT=3001, EXPOSE 3001, USER node, CMD ["node", "dist/index.js"].

</action>
<verify>

1. `grep -c 'FROM' tee-worker/Dockerfile` returns 2 (multi-stage)
2. `docker build -t cipherbox-tee-worker:test tee-worker/` succeeds

</verify>
<done>
TEE worker Dockerfile is self-contained and builds from source. CI does not need a separate build step before Docker build.
</done>
</task>

<task type="auto">
<name>Task 2: Create tag-triggered deployment workflow</name>
<files>
.github/workflows/deploy-staging.yml
</files>
<action>

Create `.github/workflows/deploy-staging.yml` with the following structure:

**Trigger:** Push tags matching `v*-staging*` (e.g., `v1.0.0-staging.1`).

**Environment variables (workflow level):**

```yaml
env:
  REGISTRY: ghcr.io
  API_IMAGE: ghcr.io/${{ github.repository_owner }}/cipherbox-api
  TEE_IMAGE: ghcr.io/${{ github.repository_owner }}/cipherbox-tee-worker
```

**Job 1: build-api** (builds and pushes API Docker image to GHCR)

- runs-on: ubuntu-latest
- permissions: contents: read, packages: write
- Steps: Checkout, docker/login-action@v3 (GHCR), docker/build-push-action@v5 with context `.`, file `apps/api/Dockerfile`, push true, tags with github.ref_name and latest.

**Job 2: build-tee** (builds and pushes TEE worker Docker image to GHCR)

- runs-on: ubuntu-latest
- permissions: contents: read, packages: write
- Steps: Checkout, docker/login-action@v3 (GHCR), docker/build-push-action@v5 with context `./tee-worker`, file `tee-worker/Dockerfile`, push true, tags with github.ref_name and latest.

**Job 3: deploy-web** (builds web app and uploads to Pinata, updates DNSLink)

- runs-on: ubuntu-latest
- Steps:
  - Checkout, pnpm/action-setup@v4 (version 10), actions/setup-node@v4 (node 22, cache pnpm)
  - `pnpm install --frozen-lockfile`
  - Build crypto then web: `pnpm --filter @cipherbox/crypto build && pnpm --filter @cipherbox/web build`
  - Pass staging env vars: VITE_WEB3AUTH_CLIENT_ID, VITE_API_URL=<https://api.staging.cipherbox.cc>, VITE_ENVIRONMENT=staging
  - Upload dist to Pinata using the Pinata CLI. Install and run:

    ```bash
    npx pinata-cli -a ${{ secrets.PINATA_JWT }} upload apps/web/dist
    ```

    Parse the output JSON to extract the CID (IpfsHash field). If `pinata-cli` is unavailable or problematic, use curl as fallback:

    ```bash
    CID=$(curl -s -X POST "https://api.pinata.cloud/pinning/pinFileToIPFS" \
      -H "Authorization: Bearer ${{ secrets.PINATA_JWT }}" \
      -F "file=@apps/web/dist" | jq -r '.IpfsHash')
    ```

    Note: For directory uploads with curl, you need to recursively add files. The Pinata CLI handles this automatically. Use whichever approach works -- capture the CID in a `$CID` variable for the next step.

  - Update Cloudflare DNSLink TXT record with the new CID:

    ```bash
    curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records/${{ secrets.CLOUDFLARE_DNSLINK_RECORD_ID }}" \
      -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
      -H "Content-Type: application/json" \
      --data '{"type":"TXT","name":"_dnslink.app.staging","content":"dnslink=/ipfs/'"$CID"'","ttl":1}'
    ```

**Job 4: deploy-vps** (pulls new images on VPS and restarts services)

- needs: [build-api, build-tee]
- runs-on: ubuntu-latest
- Steps:
  - Generate .env.staging from GitHub Secrets (NODE_ENV=production, CIPHERBOX_ENVIRONMENT=staging, DB_HOST=postgres, REDIS_HOST=redis, WEB_APP_URL=<https://app.staging.cipherbox.cc>, GRAFANA_LOKI_URL, GRAFANA_LOKI_USERNAME, GRAFANA_LOKI_API_KEY, etc.)
  - SCP .env.staging, docker-compose.staging.yml, and Caddyfile to VPS at /opt/cipherbox/. Do NOT include alloy-config.river in this initial deploy -- it is created by Plan 06 (monitoring layer) and will be deployed on a subsequent tag push after Plan 06 completes.
  - SSH into VPS using appleboy/ssh-action@v1 to: login to GHCR, set TAG env var, docker compose pull, run migrations, docker compose up -d.
  - For migrations, run inside the API container:

    ```bash
    docker compose -f /opt/cipherbox/docker-compose.staging.yml run --rm api node dist/data-source.js migration:run
    ```

    If the TypeORM CLI approach (`npx typeorm migration:run -d dist/data-source.js`) does not work inside the container (because the container has no devDependencies and no `npx`), use the programmatic approach instead: add a migration script to the API that calls `dataSource.runMigrations()` and invoke it with `node dist/run-migrations.js`. Choose whichever approach works based on the container's available binaries.

</action>
<verify>

1. `.github/workflows/deploy-staging.yml` exists with 4 jobs
2. Workflow triggers on `v*-staging*` tags
3. YAML is valid: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/deploy-staging.yml'))"`
4. Workflow references all required GitHub Secrets
5. deploy-web job has explicit Pinata upload command (not "SDK or CLI or curl")
6. deploy-web job has explicit Cloudflare API curl command for DNSLink update
7. deploy-vps SCP step does NOT include alloy-config.river
8. Migration command is specified with fallback approach documented

</verify>
<done>
Deployment workflow is ready. Tag push triggers: build API image, build TEE image, build + deploy web to Pinata, update DNSLink, pull images on VPS, run migrations, restart services. TEE worker Dockerfile updated to multi-stage. Monitoring layer (alloy-config.river) deploys separately after Plan 06.
</done>
</task>

</tasks>

<verification>

- deploy-staging.yml passes YAML validation
- Workflow has 4 jobs: build-api, build-tee, deploy-web, deploy-vps
- deploy-vps depends on build-api and build-tee
- Trigger pattern matches v\*-staging\* tags
- TEE worker Dockerfile is now multi-stage
- Pinata upload uses explicit CLI/curl command with CID capture
- Cloudflare DNSLink update uses explicit PUT curl command
- Migration command addresses container path correctness

</verification>

<success_criteria>
The full deployment pipeline is defined as code. Pushing a staging tag triggers automated build and deployment of all 3 components (API, TEE worker, web app) to their respective targets (GHCR + VPS for backend, Pinata + Cloudflare for frontend). Migration runs inside Docker container with verified path.
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-env-devops-staging/09.1-04-SUMMARY.md`
</output>
