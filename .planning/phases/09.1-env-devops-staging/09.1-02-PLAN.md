---
phase: 09.1-env-devops-staging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/Dockerfile
  - .dockerignore
  - docker/docker-compose.staging.yml
  - docker/Caddyfile
autonomous: true

must_haves:
  truths:
    - 'API Docker image builds from monorepo root with multi-stage build'
    - 'Staging Docker Compose runs API, Postgres, Redis, Kubo, TEE worker, and Caddy'
    - 'Caddy reverse-proxies HTTPS traffic to the API container'
    - 'All services use Docker networking (service names, not localhost)'
  artifacts:
    - path: 'apps/api/Dockerfile'
      provides: 'Multi-stage API Docker build'
      contains: 'FROM node:22-alpine'
      min_lines: 20
    - path: '.dockerignore'
      provides: 'Excludes unnecessary files from Docker build context'
      contains: 'node_modules'
    - path: 'docker/docker-compose.staging.yml'
      provides: 'Full staging stack with all services'
      contains: 'cipherbox-api'
    - path: 'docker/Caddyfile'
      provides: 'Reverse proxy config for API'
      contains: 'reverse_proxy'
  key_links:
    - from: 'docker/docker-compose.staging.yml'
      to: 'apps/api/Dockerfile'
      via: 'image reference or build context'
      pattern: 'cipherbox-api'
    - from: 'docker/docker-compose.staging.yml'
      to: 'docker/Caddyfile'
      via: 'volume mount'
      pattern: 'Caddyfile'
---

<objective>
Create the Docker infrastructure for staging deployment: API Dockerfile, staging Docker Compose, Caddy reverse proxy config, and .dockerignore.

Purpose: The staging environment runs all services (API, Postgres, Redis, Kubo, TEE worker) on a single VPS behind Caddy as reverse proxy with Cloudflare Origin CA certificates. These files are the deployment target for the CI/CD pipeline.

Output: Four new files that define the complete staging infrastructure.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09.1-env-devops-staging/09.1-CONTEXT.md
@.planning/phases/09.1-env-devops-staging/09.1-RESEARCH.md
@apps/api/package.json
@apps/api/src/app.module.ts
@docker/docker-compose.yml
@tee-worker/Dockerfile
@pnpm-workspace.yaml
@tsconfig.base.json
</context>

<tasks>

<task type="auto">
<name>Task 1: Create API Dockerfile and .dockerignore</name>
<files>
apps/api/Dockerfile
.dockerignore
</files>
<action>

**1. Create `apps/api/Dockerfile` (multi-stage build):**

The Dockerfile is built from the repo root (context = `.`), not from `apps/api/`. This is required because pnpm needs the workspace root for lockfile resolution.

Stage 1 (deps): Install production dependencies only. Use `node:22-alpine` base. Enable corepack and prepare pnpm@10. Copy `pnpm-lock.yaml`, `pnpm-workspace.yaml`, root `package.json`. Copy `apps/api/package.json` (only the api workspace). Run `pnpm install --frozen-lockfile --filter @cipherbox/api...`. Note: The API does NOT depend on `@cipherbox/crypto` workspace package, so only its own deps are needed.

Stage 2 (build): Compile TypeScript. Copy `apps/api/` source code. Copy `tsconfig.base.json` (API's tsconfig extends it). Run `pnpm --filter @cipherbox/api build`.

Stage 3 (production): Minimal runtime image. Use `node:22-alpine`. Create non-root user (appuser:1001, appgroup:1001). Copy `dist/` from build stage. Copy `node_modules/` from deps stage (both root and apps/api). Set `NODE_ENV=production`, `PORT=3000`. Switch to non-root user. EXPOSE 3000. CMD `["node", "dist/main.js"]`.

Important: The pnpm hoisting may place dependencies at root `node_modules/`. Copy both root `node_modules/` and `apps/api/node_modules/` to the production stage. The working directory should match the structure so `dist/main.js` can find modules.

**2. Create `.dockerignore` at repo root:**

Exclude files not needed in Docker build context: `node_modules`, `.git`, `.github`, `.planning`, `.learnings`, `.claude`, `00-Preliminary-R&D`, `apps/web`, `apps/desktop`, `tee-worker`, `tests`, `tools`, `designs`, `coverage`, `dist`, `*.md`, `.env*`, `.DS_Store`.

Keep only what the API Dockerfile needs: `apps/api/`, `pnpm-lock.yaml`, `pnpm-workspace.yaml`, `package.json`, `tsconfig.base.json`.

</action>
<verify>

1. `docker build -f apps/api/Dockerfile -t cipherbox-api:test .` succeeds from repo root
2. `docker run --rm cipherbox-api:test node -e "console.log('ok')"` outputs "ok"
3. `.dockerignore` exists and excludes `node_modules`, `.git`, `apps/web`

</verify>
<done>
API Docker image builds successfully from monorepo root using multi-stage build. Image runs as non-root user. .dockerignore excludes irrelevant files from build context.
</done>
</task>

<task type="auto">
<name>Task 2: Create staging Docker Compose and Caddyfile</name>
<files>
docker/docker-compose.staging.yml
docker/Caddyfile
</files>
<action>

**1. Create `docker/docker-compose.staging.yml`:**

Define services that pull pre-built images from GHCR (not build locally):

**api**: `image: ghcr.io/OWNER/cipherbox-api:${TAG:-latest}`, restart: unless-stopped, env_file: .env.staging, ports: 127.0.0.1:3000:3000, depends_on postgres (healthy) and redis (healthy). The OWNER should be a placeholder -- the deploy workflow substitutes the actual GitHub repository owner.

**postgres**: `image: postgres:16-alpine`, restart: unless-stopped, environment from env vars (DB_USERNAME, DB_PASSWORD, DB_DATABASE), volume postgres_staging for persistence, healthcheck with pg_isready. Bind port to 127.0.0.1 only.

**redis**: `image: redis:7-alpine`, restart: unless-stopped, bind port 127.0.0.1:6379:6379, volume redis_staging, healthcheck with redis-cli ping.

**ipfs**: `image: ipfs/kubo:v0.34.0`, restart: unless-stopped, IPFS_PROFILE=server, swarm ports 4001 (tcp+udp) open to internet for DHT, API port 127.0.0.1:5001, gateway port 127.0.0.1:8080, volume ipfs_staging, healthcheck, memory limit 2G, cpu limit 1.0.

**tee-worker**: `image: ghcr.io/OWNER/cipherbox-tee-worker:${TAG:-latest}`, restart: unless-stopped, environment: NODE_ENV=production, PORT=3001, TEE_MODE=simulator, CIPHERBOX_ENVIRONMENT=staging, TEE_WORKER_SECRET from env. Port 127.0.0.1:3001:3001.

**caddy**: `image: caddy:2-alpine`, restart: unless-stopped, ports 80:80 and 443:443, volumes: ./Caddyfile:/etc/caddy/Caddyfile, ./certs:/etc/caddy/certs (for Cloudflare Origin CA certs), caddy_data and caddy_config named volumes.

Named volumes: postgres_staging, redis_staging, ipfs_staging, caddy_data, caddy_config.

Use Docker service names for inter-service communication: API connects to postgres via DB_HOST=postgres, REDIS_HOST=redis, IPFS via IPFS_LOCAL_API_URL=<http://ipfs:5001>, TEE via TEE_WORKER_URL=<http://tee-worker:3001>.

**2. Create `docker/Caddyfile`:**

Caddy handles TLS termination with Cloudflare Origin CA certificates. Cloudflare proxies traffic to the VPS -- Caddy serves the origin cert so Cloudflare Full (Strict) mode works.

```text
{
  auto_https off
}

:443 {
  tls /etc/caddy/certs/origin.pem /etc/caddy/certs/origin-key.pem
  reverse_proxy api:3000
}

:80 {
  redir https://{host}{uri} permanent
}
```

Note: Use Docker service name `api` (not localhost) for the reverse proxy target. Caddy is on the same Docker network as the API container.

</action>
<verify>

1. `docker compose -f docker/docker-compose.staging.yml config` validates the compose file (use --no-interpolate if env vars not set)
2. `docker/Caddyfile` exists with reverse_proxy directive
3. Compose file has all 6 services (api, postgres, redis, ipfs, tee-worker, caddy)
4. All non-public ports bind to 127.0.0.1

</verify>
<done>
Staging Docker Compose defines all 6 services with proper networking, health checks, and security (localhost-bound ports). Caddyfile reverse-proxies HTTPS to the API with Cloudflare Origin CA support.
</done>
</task>

</tasks>

<verification>

- API Docker image builds from monorepo root
- docker-compose.staging.yml passes config validation
- All ports except 80, 443, and 4001 are bound to 127.0.0.1
- Caddyfile uses Docker service name for upstream
- .dockerignore excludes web app, desktop, tests, docs

</verification>

<success_criteria>
API Dockerfile builds a working multi-stage image. Staging Docker Compose orchestrates 6 services. Caddy provides TLS termination. All infrastructure files are ready for the deployment workflow.
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-env-devops-staging/09.1-02-SUMMARY.md`
</output>
