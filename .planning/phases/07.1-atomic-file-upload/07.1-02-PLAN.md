---
phase: 07.1-atomic-file-upload
plan: 02
type: execute
wave: 2
depends_on: ['07.1-01']
files_modified:
  - apps/web/src/lib/api/ipfs.ts
  - apps/web/src/services/upload.service.ts
  - apps/web/src/services/folder.service.ts
  - apps/web/src/hooks/useFolder.ts
  - apps/web/src/stores/upload.store.ts
  - apps/web/src/components/file-browser/UploadZone.tsx
  - apps/web/src/components/file-browser/EmptyState.tsx
autonomous: true

must_haves:
  truths:
    - 'File uploads use the new POST /ipfs/upload endpoint (pin + quota record in one call)'
    - 'Multi-file uploads publish IPNS exactly once for the entire batch, not once per file'
    - 'After upload completes, quota is refreshed from server (not just locally incremented)'
    - "Upload progress shows 'registering' status during batch folder metadata registration"
    - 'Single file upload still works (batch of 1)'
    - 'Upload cancellation still works mid-batch'
  artifacts:
    - path: 'apps/web/src/lib/api/ipfs.ts'
      provides: 'addToIpfs function using /ipfs/upload endpoint'
      contains: '/ipfs/upload'
    - path: 'apps/web/src/services/folder.service.ts'
      provides: 'addFilesToFolder batch function'
      contains: 'addFilesToFolder'
    - path: 'apps/web/src/hooks/useFolder.ts'
      provides: 'addFiles batch handler alongside existing addFile'
      contains: 'addFiles'
    - path: 'apps/web/src/stores/upload.store.ts'
      provides: 'registering status in upload state'
      contains: 'registering'
    - path: 'apps/web/src/components/file-browser/UploadZone.tsx'
      provides: 'Batch addFiles call replacing per-file addFile loop'
      contains: 'addFiles'
    - path: 'apps/web/src/components/file-browser/EmptyState.tsx'
      provides: 'Batch addFiles call replacing per-file addFile loop'
      contains: 'addFiles'
  key_links:
    - from: 'apps/web/src/lib/api/ipfs.ts'
      to: 'POST /ipfs/upload'
      via: 'axios.post to new endpoint'
      pattern: '/ipfs/upload'
    - from: 'apps/web/src/services/folder.service.ts'
      to: 'updateFolderMetadata'
      via: 'Single call for batch (not N calls)'
      pattern: 'addFilesToFolder'
    - from: 'apps/web/src/components/file-browser/UploadZone.tsx'
      to: 'apps/web/src/hooks/useFolder.ts'
      via: 'addFiles batch call'
      pattern: "addFiles\\("
    - from: 'apps/web/src/services/upload.service.ts'
      to: 'apps/web/src/stores/quota.store.ts'
      via: 'fetchQuota after upload instead of local addUsage'
      pattern: 'fetchQuota'
---

<objective>
Refactor the frontend upload flow to use the new atomic endpoint and batch IPNS publishing.

Purpose: Currently each file upload does 3 HTTP requests (pin, record metadata, publish IPNS) and multi-file uploads publish IPNS N times. This plan switches to the new atomic endpoint (1 request per file for pin+record) and adds a batch `addFilesToFolder` function that publishes IPNS exactly once for all files in a batch. For 5 files, this reduces IPNS publishes from 5 to 1 (saving ~6-8 seconds).

Output: Updated upload flow with atomic endpoint, batch folder registration, server-authoritative quota sync.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-atomic-file-upload/07.1-RESEARCH.md
@.planning/phases/07.1-atomic-file-upload/07.1-01-SUMMARY.md

Key source files:
@apps/web/src/lib/api/ipfs.ts
@apps/web/src/services/upload.service.ts
@apps/web/src/services/folder.service.ts
@apps/web/src/hooks/useFolder.ts
@apps/web/src/hooks/useFileUpload.ts
@apps/web/src/stores/upload.store.ts
@apps/web/src/stores/quota.store.ts
@apps/web/src/components/file-browser/UploadZone.tsx
@apps/web/src/components/file-browser/EmptyState.tsx
</context>

<tasks>

<task type="auto">
<name>Task 1: Switch upload API to new endpoint, add batch folder registration, update quota flow</name>
<files>
apps/web/src/lib/api/ipfs.ts
apps/web/src/services/upload.service.ts
apps/web/src/services/folder.service.ts
apps/web/src/stores/upload.store.ts
</files>
<action>
**ipfs.ts** -- Change `addToIpfs` function to POST to `${BASE_URL}/ipfs/upload` instead of `${BASE_URL}/ipfs/add`. The response type stays the same (`{ cid: string; size: number }`) -- the `recorded` field from UploadResponseDto can be ignored on the client side. Keep the function name `addToIpfs` to minimize downstream changes. Keep `unpinFromIpfs` and `fetchFromIpfs` unchanged.

**upload.store.ts** -- Add `'registering'` to the `UploadStatus` type union so it becomes: `'idle' | 'encrypting' | 'uploading' | 'registering' | 'success' | 'error' | 'cancelled'`. Add `setRegistering: () => void` to the store type. Implement: `setRegistering: () => set({ status: 'registering', currentFile: null })`. This status indicates "all files uploaded, now registering in folder metadata".

**upload.service.ts** -- In `uploadFiles()`, remove the per-file `quotaStore.addUsage(result.size)` call from inside the for loop (line 121). Instead, after the for loop completes (before `uploadStore.setSuccess()`), call `await quotaStore.fetchQuota()` to refresh quota from server. The server now authoritatively tracks quota via `recordPin` in the new endpoint. Keep the `quotaStore.canUpload(totalSize)` pre-check for fail-fast behavior.

**folder.service.ts** -- Add `addFilesToFolder()` batch function right after the existing `addFileToFolder()` function. Signature:

```typescript
export async function addFilesToFolder(params: {
  parentFolderState: FolderNode;
  files: Array<{
    cid: string;
    fileKeyEncrypted: string;
    fileIv: string;
    name: string;
    size: number;
  }>;
}): Promise<{ fileEntries: FileEntry[]; newSequenceNumber: bigint }>;
```

Implementation: (a) Build a Set of existing child names from `params.parentFolderState.children`. (b) Create FileEntry[] for all files, checking name collisions against existingNames AND within the batch itself (add each name to the Set as you go). (c) If collision found, throw `new Error('A file with name "X" already exists')`. (d) Each FileEntry uses: `type: 'file'`, `id: crypto.randomUUID()`, `name`, `cid`, `fileKeyEncrypted`, `fileIv`, `encryptionMode: 'GCM'`, `size`, `createdAt: Date.now()`, `modifiedAt: Date.now()`. (e) Build children: `[...params.parentFolderState.children, ...fileEntries]`. (f) Call `updateFolderMetadata()` ONCE (single IPNS publish). (g) Return `{ fileEntries, newSequenceNumber }`.

Do NOT remove `addFileToFolder()` -- it is still used by other code paths.
</action>
<verify>
`pnpm --filter web build` compiles without errors. Verify `ipfs.ts` uses `/ipfs/upload` URL. Verify `folder.service.ts` exports both `addFileToFolder` and `addFilesToFolder`. Verify `upload.store.ts` includes `registering` status. Verify `upload.service.ts` calls `fetchQuota()` instead of per-file `addUsage()`.
</verify>
<done>
addToIpfs posts to /ipfs/upload (atomic endpoint with server-side quota recording). addFilesToFolder batch function exists in folder.service.ts. Upload store has registering status. Quota is server-authoritative (fetchQuota after upload, no per-file addUsage).
</done>
</task>

<task type="auto">
<name>Task 2: Wire batch upload flow into hooks and components</name>
<files>
apps/web/src/hooks/useFolder.ts
apps/web/src/hooks/useFileUpload.ts
apps/web/src/components/file-browser/UploadZone.tsx
apps/web/src/components/file-browser/EmptyState.tsx
</files>
<action>
**useFolder.ts** -- Add a new `handleAddFiles` callback (batch version of `handleAddFile`). It accepts `parentId: string` and `filesData: Array<{ cid, wrappedKey, iv, originalName, originalSize }>`, returns `Promise<FileEntry[]>`. Inside: get folders and vault state, resolve parentFolder (same logic as handleAddFile), call `folderService.addFilesToFolder()` mapping `wrappedKey` to `fileKeyEncrypted` and `iv` to `fileIv` and `originalName` to `name` and `originalSize` to `size`. After success, update local state: `store.updateFolderChildren(parentId, [...parentFolder.children, ...fileEntries])` and `store.updateFolderSequence(parentId, newSequenceNumber)`. Add `addFiles: handleAddFiles` to the return object alongside existing `addFile: handleAddFile`.

**useFileUpload.ts** -- Update `isUploading` to include `'registering'` status: `isUploading: status === 'encrypting' || status === 'uploading' || status === 'registering'`. No other changes needed.

**UploadZone.tsx** -- Change `const { addFile } = useFolder()` to `const { addFiles } = useFolder()`. Replace the per-file registration loop (the `for (const uploaded of uploadedFiles)` block with `addFile` calls and `failedRegistrations` handling) with a batch call:

```typescript
// Set registering status
useUploadStore.getState().setRegistering();

// Batch register all files in folder (single IPNS publish)
await addFiles(
  folderId,
  uploadedFiles.map((uploaded) => ({
    cid: uploaded.cid,
    wrappedKey: uploaded.wrappedKey,
    iv: uploaded.iv,
    originalName: uploaded.originalName,
    originalSize: uploaded.originalSize,
  }))
);
```

Remove the `failedRegistrations` array and related error handling (batch is all-or-nothing now). Update dependency array: change `addFile` to `addFiles`. Add import of `useUploadStore` from `'../../stores/upload.store'`.

**EmptyState.tsx** -- Apply the exact same changes as UploadZone.tsx: change `addFile` to `addFiles` from useFolder, replace per-file loop with batch call, add `useUploadStore.getState().setRegistering()` before the batch call, remove `failedRegistrations`, update dependency array. Add import of `useUploadStore`.

The upload flow in both components now follows: (a) validate files (unchanged), (b) `upload(acceptedFiles)` encrypts + uploads to IPFS (unchanged), (c) `setRegistering()` (new), (d) `addFiles(folderId, ...)` batch registration with single IPNS publish (new), (e) `onUploadComplete?.()` (unchanged).
</action>
<verify>
`pnpm --filter web build` compiles without errors. `pnpm --filter web lint` passes. Verify UploadZone.tsx uses `addFiles` (not `addFile`). Verify EmptyState.tsx uses `addFiles` (not `addFile`). Verify useFolder.ts exports both `addFile` and `addFiles`. Verify useFileUpload.ts `isUploading` includes `registering` status.
</verify>
<done>
useFolder hook exposes both addFile (single) and addFiles (batch). UploadZone uses batch addFiles for all uploads (single IPNS publish). EmptyState uses batch addFiles for all uploads (single IPNS publish). Upload progress correctly shows registering status during metadata registration. isUploading flag covers encrypting + uploading + registering statuses.
</done>
</task>

</tasks>

<verification>

1. `pnpm --filter web build` passes
2. `pnpm --filter web lint` passes
3. Full upload flow: dropping 3 files results in 3 calls to POST /ipfs/upload (one per file, sequential) + 1 IPNS publish (batch registration)
4. Single file upload still works correctly
5. Upload cancellation still works
6. After upload, quota reflects server-side totals (fetchQuota called, not local increment)
7. Upload modal shows "registering" status between upload completion and folder metadata update

</verification>

<success_criteria>
Multi-file upload publishes IPNS exactly once (not N times). Upload uses POST /ipfs/upload endpoint (server records quota per pin). Quota synced from server after upload completes. Upload store shows registering status during metadata update. Single file upload works (batch of 1). UploadZone and EmptyState both use batch flow. All existing addFile/addFileToFolder single-file functions remain for other code paths.
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-atomic-file-upload/07.1-02-SUMMARY.md`
</output>
