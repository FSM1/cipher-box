---
phase: 07.1-atomic-file-upload
status: complete
completed: 2026-02-07
uat: 6/6 pass
verification: 10/10 pass
---

# Phase 7.1: Atomic File Upload - Completion

## Summary

Refactored the multi-request upload flow into a single atomic backend call (POST /ipfs/upload) that combines quota check, IPFS pin, and pin recording. Frontend now batches folder metadata registration into a single IPNS publish per upload batch.

## Results

- **UAT:** 6/6 tests pass (single upload, multi-file batch, progress states, quota refresh, cancellation, folder operations)
- **Verification:** 10/10 must-haves verified
- **Unit tests:** 13/13 pass (10 existing + 3 new)
- **Builds:** API and web both compile cleanly

## Known Issues Discovered During UAT

These are **pre-existing issues** not caused by Phase 7.1, but surfaced during testing:

### 1. Upload modal not dismissable + button stuck (Severity: High)

**Symptom:** After upload completes, the modal stays open with no close button. The toolbar upload button stays stuck on "uploading...".

**Root cause:** `setSuccess()` is never called after the upload+registration flow completes. The status stays on `registering`, which keeps `isVisible=true` on the modal and `isUploading=true` on the button.

**Fix:** Add `useUploadStore.getState().setSuccess()` after `addFiles()` succeeds in UploadZone.tsx and EmptyState.tsx.

### 2. Auth refresh token race condition (Severity: Medium)

**Symptom:** Multiple parallel POST /auth/refresh calls, some succeed then later ones fail [401] due to token rotation.

**Root cause:** Timing gap in the 401 interceptor allows multiple refresh calls before `isRefreshing` flag is set. Server-side token rotation without DB locking creates a TOCTOU race.

**Fix:** Replace isRefreshing+failedQueue with a single shared Promise pattern. Optional: add SELECT FOR UPDATE on server.

### 3. IPNS resolve 502 / Sync failed (Severity: Critical)

**Symptom:** All IPNS resolve calls return 502. Files disappear after page reload. "Sync failed" indicator shown permanently.

**Root cause:** The delegated routing service (delegated-ipfs.dev) can't find IPNS records - returns "routing: not found". IPNS records are ephemeral and the public DHT doesn't reliably index them.

**Fix:** Fall back to DB-cached metadata CID (folder_ipns table already stores it). Use IPNS only as secondary verification.

## Learnings

### 1. Always verify the full upload lifecycle in UAT

The upload store had proper state transitions defined (`idle -> encrypting -> uploading -> registering -> success`) but the `success` transition was never wired up. Code verification (VERIFICATION.md) confirmed `setRegistering()` was called but didn't check that the terminal state was reached. **Lesson: Verify state machines end-to-end, not just individual transitions.**

### 2. Modal dismiss = explicit close handler, not just state

The UploadModal passes `onClose={canClose ? handleClose : undefined}` to Modal. When `canClose` is false (which it is during `registering` status), `onClose` is undefined, so Modal renders no close button and doesn't respond to Escape/backdrop clicks. **Lesson: Modals should always have a dismiss path, even during active operations (e.g., "minimize" or background the operation).**

### 3. IPNS is not reliable for primary data retrieval

The IPNS resolve failure means the entire file browsing experience breaks on page reload. Files uploaded in the current session work fine (local state), but nothing persists across sessions. **Lesson: Never use an eventually-consistent external service as the sole source of truth for critical data. Always have a server-side fallback.**

### 4. Token refresh needs a mutex, not a flag

The `isRefreshing` boolean flag pattern is fundamentally racy in async JS - multiple microtasks can read `false` before any writes `true`. The correct pattern is to store the refresh Promise itself and have all waiters subscribe to it. **Lesson: For async deduplication, share the Promise, not a boolean flag.**

### 5. UAT with Playwright catches what code review misses

The upload modal blocking issue was invisible in code review and static verification (both passed 10/10). It was immediately obvious in UAT when the modal trapped all pointer events. **Lesson: Automated E2E testing is essential for UX flows, not optional.**
