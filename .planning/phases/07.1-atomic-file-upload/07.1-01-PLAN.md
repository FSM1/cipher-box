---
phase: 07.1-atomic-file-upload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/ipfs/dto/upload.dto.ts
  - apps/api/src/ipfs/dto/index.ts
  - apps/api/src/ipfs/ipfs.controller.ts
  - apps/api/src/ipfs/ipfs.module.ts
  - apps/web/src/api/
autonomous: true

must_haves:
  truths:
    - 'POST /ipfs/upload accepts multipart file, checks quota, pins to IPFS, records pin in DB, returns {cid, size, recorded}'
    - 'POST /ipfs/upload returns 413 PayloadTooLargeException when user quota exceeded'
    - 'Existing POST /ipfs/add endpoint continues to work unchanged for folder metadata pins'
    - 'Regenerated API client includes the new upload endpoint types'
  artifacts:
    - path: 'apps/api/src/ipfs/dto/upload.dto.ts'
      provides: 'UploadResponseDto with cid, size, recorded fields'
      contains: 'class UploadResponseDto'
    - path: 'apps/api/src/ipfs/ipfs.controller.ts'
      provides: 'New POST /ipfs/upload endpoint with quota check + pin + record'
      contains: 'upload('
    - path: 'apps/api/src/ipfs/ipfs.module.ts'
      provides: 'VaultModule import for VaultService access'
      contains: 'VaultModule'
  key_links:
    - from: 'apps/api/src/ipfs/ipfs.controller.ts'
      to: 'apps/api/src/vault/vault.service.ts'
      via: 'VaultService injection for checkQuota and recordPin'
      pattern: "vaultService\\.(checkQuota|recordPin)"
    - from: 'apps/api/src/ipfs/ipfs.module.ts'
      to: 'apps/api/src/vault/vault.module.ts'
      via: 'Module import'
      pattern: 'VaultModule'
---

<objective>
Add atomic upload endpoint to the backend that combines IPFS pinning with server-side quota check and pin recording in a single request.

Purpose: Eliminates the gap where a file can be pinned to IPFS but never recorded for quota tracking. The current `POST /ipfs/add` only pins -- it does not record the pin or check quota server-side. This new `POST /ipfs/upload` endpoint does all three atomically.

Output: Working `POST /ipfs/upload` endpoint, new DTO, updated IpfsModule, and regenerated API client.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-atomic-file-upload/07.1-RESEARCH.md

Key source files:
@apps/api/src/ipfs/ipfs.controller.ts
@apps/api/src/ipfs/ipfs.module.ts
@apps/api/src/ipfs/dto/add.dto.ts
@apps/api/src/ipfs/dto/index.ts
@apps/api/src/vault/vault.service.ts
@apps/api/src/vault/vault.module.ts
</context>

<tasks>

<task type="auto">
<name>Task 1: Create UploadResponseDto and new POST /ipfs/upload endpoint</name>
<files>
apps/api/src/ipfs/dto/upload.dto.ts
apps/api/src/ipfs/dto/index.ts
apps/api/src/ipfs/ipfs.controller.ts
apps/api/src/ipfs/ipfs.module.ts
</files>
<action>
Create `apps/api/src/ipfs/dto/upload.dto.ts` with class `UploadResponseDto` having `@ApiProperty()` decorated fields: `cid: string`, `size: number`, `recorded: boolean`. Follow the exact same pattern as `AddResponseDto` in `add.dto.ts`.

Update `apps/api/src/ipfs/dto/index.ts` to add export for `UploadResponseDto`.

Update `apps/api/src/ipfs/ipfs.module.ts`: import `VaultModule` from `'../vault/vault.module'` and add it to the `imports` array alongside `ConfigModule`. This makes `VaultService` (already exported from VaultModule) injectable in IpfsController.

Update `apps/api/src/ipfs/ipfs.controller.ts`:

- Import `VaultService` from `'../vault/vault.service'`
- Import `PayloadTooLargeException`, `Request` from `@nestjs/common`
- Import `UploadResponseDto` from `'./dto'`
- Define `interface RequestWithUser extends Request { user: { id: string } }` at the top (same pattern as auth.controller.ts)
- Add `VaultService` to constructor injection: `private readonly vaultService: VaultService`
- Add new endpoint method `upload()` with these decorators: `@Post('upload')`, `@ApiOperation({ summary: 'Upload encrypted file to IPFS with quota tracking', description: 'Pins encrypted file to IPFS, checks storage quota, and records the pin for quota tracking. All in one atomic request.' })`, `@ApiConsumes('multipart/form-data')`, same `@ApiBody` schema as the existing `add` endpoint, `@ApiResponse({ status: 201, type: UploadResponseDto })`, `@ApiResponse({ status: 401 })`, `@ApiResponse({ status: 413, description: 'Storage quota exceeded' })`, `@UseInterceptors(FileInterceptor('file', { limits: { fileSize: MAX_FILE_SIZE } }))`
- Method signature: `async upload(@Request() req: RequestWithUser, @UploadedFile(new ParseFilePipe({ validators: [new MaxFileSizeValidator({ maxSize: MAX_FILE_SIZE })] })) file: Express.Multer.File): Promise<UploadResponseDto>`
- Implementation body:

```typescript
const hasQuota = await this.vaultService.checkQuota(req.user.id, file.size);
if (!hasQuota) throw new PayloadTooLargeException('Storage quota exceeded');
const result = await this.ipfsProvider.pinFile(file.buffer);
await this.vaultService.recordPin(req.user.id, result.cid, result.size);
return { cid: result.cid, size: result.size, recorded: true };
```

IMPORTANT: Do NOT modify the existing `add()` endpoint. It remains as-is for folder metadata pins.
IMPORTANT: The `@Request()` decorator is imported from `@nestjs/common`. Check if `Request` is already in the imports; if not, add it.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter api build` compiles without errors. `curl -X POST http://localhost:3000/ipfs/upload` returns 401 (auth required, not 404 -- proving the endpoint exists). Swagger at http://localhost:3000/api includes the new `POST /ipfs/upload` endpoint.
</verify>
<done>
UploadResponseDto exists with cid, size, recorded fields. POST /ipfs/upload endpoint exists, injects VaultService, checks quota before pinning, records pin after pinning. Existing POST /ipfs/add unchanged. IpfsModule imports VaultModule. API compiles cleanly.
</done>
</task>

<task type="auto">
<name>Task 2: Regenerate API client</name>
<files>
apps/web/src/api/
</files>
<action>
Run `pnpm api:generate` to regenerate the OpenAPI spec and typed API client. This generates the OpenAPI spec from the NestJS backend (which now includes POST /ipfs/upload), creates the typed client for the web app using orval, and runs lint fixes on generated files.

After regeneration, verify the generated client includes the new upload endpoint types by checking that the generated files contain references to `UploadResponseDto` or the `/ipfs/upload` path.

Commit the regenerated client files alongside the API changes per project convention.
</action>
<verify>
`pnpm api:generate` completes without errors. Generated files in `apps/web/src/api/` contain references to the upload endpoint. `pnpm --filter web build` compiles (frontend still builds with regenerated client).
</verify>
<done>
API client regenerated with new upload endpoint types. Frontend builds cleanly with regenerated client.
</done>
</task>

</tasks>

<verification>

1. `pnpm --filter api build` passes (backend compiles)
2. `pnpm api:generate` succeeds (client regeneration)
3. `pnpm --filter web build` passes (frontend compiles with new client)
4. Swagger docs show both `POST /ipfs/add` (unchanged) and `POST /ipfs/upload` (new)

</verification>

<success_criteria>
New POST /ipfs/upload endpoint exists and compiles. Endpoint checks quota before pinning (PayloadTooLargeException on exceed). Endpoint records pin via VaultService.recordPin after pinning. Existing POST /ipfs/add is untouched. API client regenerated with new types. Both API and web compile cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-atomic-file-upload/07.1-01-SUMMARY.md`
</output>
