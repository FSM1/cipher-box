# Phase 4.1: API Service Testing - Research

**Researched:** 2026-01-20
**Domain:** NestJS unit testing with Jest, TypeORM mocking
**Confidence:** HIGH

## Summary

This research documents the current state of the backend codebase and establishes testing patterns for comprehensive unit test coverage. The backend uses NestJS with TypeORM, and Jest is already configured and working (12 tests passing for IpfsService).

The project requires specific coverage thresholds per TESTING.md:

- Auth Services: 90% line, 85% branch
- Vault Services: 90% line, 85% branch
- IPFS/IPNS Services: 85% line, 80% branch
- Controllers: 80% line, 75% branch
- Guards/Middleware: 90% line, 85% branch
- Overall Minimum: 85% line, 80% branch

**Primary recommendation:** Follow the existing `ipfs.service.spec.ts` pattern for consistency. Use `@nestjs/testing` TestingModule with mocked providers. Configure Jest `coverageThreshold` to enforce per-directory coverage requirements.

## Current State Analysis

### Existing Test Infrastructure

| Component       | Status     | Notes                                                    |
| --------------- | ---------- | -------------------------------------------------------- |
| Jest            | Configured | `jest.config.js` in apps/api                             |
| @nestjs/testing | Installed  | v11.0.0 in devDependencies                               |
| ts-jest         | Installed  | v29.3.0                                                  |
| Test script     | Working    | `npm test` runs Jest                                     |
| Coverage script | Working    | `npm test:cov` generates report                          |
| Existing tests  | 1 file     | `ipfs.service.spec.ts` (12 tests, 100% service coverage) |

### Current Coverage Snapshot

```
Overall: ~10% (only IpfsService fully tested)
IpfsService: 100% line, 88% branch
All other services: 0%
All controllers: 0%
```

### Services to Test

| Service                 | File                                         | Methods   | Dependencies                                   | Priority |
| ----------------------- | -------------------------------------------- | --------- | ---------------------------------------------- | -------- |
| AuthService             | `auth/auth.service.ts`                       | 7 methods | Web3AuthVerifierService, TokenService, 3 repos | HIGH     |
| TokenService            | `auth/services/token.service.ts`             | 4 methods | JwtService, RefreshToken repo                  | HIGH     |
| Web3AuthVerifierService | `auth/services/web3auth-verifier.service.ts` | 3 methods | jose (external JWKS)                           | HIGH     |
| VaultService            | `vault/vault.service.ts`                     | 8 methods | Vault repo, PinnedCid repo                     | HIGH     |
| IpfsService             | `ipfs/ipfs.service.ts`                       | 2 methods | ConfigService, fetch                           | DONE     |
| JwtStrategy             | `auth/strategies/jwt.strategy.ts`            | 1 method  | ConfigService, User repo                       | MEDIUM   |
| JwtAuthGuard            | `auth/guards/jwt-auth.guard.ts`              | 0 methods | Extends AuthGuard                              | LOW      |

### Controllers to Test

| Controller      | File                        | Endpoints   | Service Dependencies |
| --------------- | --------------------------- | ----------- | -------------------- |
| AuthController  | `auth/auth.controller.ts`   | 6 endpoints | AuthService          |
| VaultController | `vault/vault.controller.ts` | 3 endpoints | VaultService         |
| IpfsController  | `ipfs/ipfs.controller.ts`   | 2 endpoints | IpfsService          |

## Standard Stack

### Core Testing Libraries (Already Installed)

| Library         | Version | Purpose                         |
| --------------- | ------- | ------------------------------- |
| jest            | ^29.7.0 | Test runner                     |
| ts-jest         | ^29.3.0 | TypeScript transformer for Jest |
| @nestjs/testing | ^11.0.0 | NestJS TestingModule creation   |
| @types/jest     | ^29.5.0 | TypeScript definitions          |

### No Additional Libraries Needed

The existing setup is complete. Do NOT add:

- supertest (not needed for unit tests, only E2E)
- @golevelup/ts-jest (unnecessary abstraction)
- jest-mock-extended (native Jest mocks sufficient)

## Architecture Patterns

### Pattern 1: TestingModule with Mocked Providers

The standard NestJS unit test pattern. Use `Test.createTestingModule()` with mocked dependencies.

**Source:** Existing `ipfs.service.spec.ts` in codebase

```typescript
// Example pattern from ipfs.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { MyService } from './my.service';

describe('MyService', () => {
  let service: MyService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MyService,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn((key: string) => {
              if (key === 'SOME_CONFIG') return 'mock-value';
              return undefined;
            }),
          },
        },
      ],
    }).compile();

    service = module.get<MyService>(MyService);
  });

  // tests...
});
```

### Pattern 2: Mocking TypeORM Repositories

Use `getRepositoryToken()` to provide mock repositories.

**Source:** [NestJS TypeORM Testing Guide](https://www.restack.io/p/nestjs-typeorm-testing)

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;
  let userRepository: jest.Mocked<Repository<User>>;

  beforeEach(async () => {
    const mockRepository = {
      findOne: jest.fn(),
      find: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      remove: jest.fn(),
      count: jest.fn(),
      createQueryBuilder: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: getRepositoryToken(User),
          useValue: mockRepository,
        },
        // ... other mocked dependencies
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    userRepository = module.get(getRepositoryToken(User));
  });

  it('should find user by publicKey', async () => {
    const mockUser = { id: 'uuid', publicKey: 'key123' };
    userRepository.findOne.mockResolvedValue(mockUser as User);

    const result = await service.findByPublicKey('key123');

    expect(userRepository.findOne).toHaveBeenCalledWith({
      where: { publicKey: 'key123' },
    });
    expect(result).toEqual(mockUser);
  });
});
```

### Pattern 3: Mocking External HTTP Services

For services that make external HTTP calls (like Web3AuthVerifierService fetching JWKS), mock the external module.

```typescript
// Mock jose module at module level
jest.mock('jose', () => ({
  createRemoteJWKSet: jest.fn(() => jest.fn()),
  jwtVerify: jest.fn(),
}));

import * as jose from 'jose';
import { Web3AuthVerifierService } from './web3auth-verifier.service';

describe('Web3AuthVerifierService', () => {
  let service: Web3AuthVerifierService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [Web3AuthVerifierService],
    }).compile();

    service = module.get<Web3AuthVerifierService>(Web3AuthVerifierService);
  });

  it('should verify social login token', async () => {
    const mockPayload = {
      wallets: [{ type: 'web3auth_app_key', public_key: 'abc123', curve: 'secp256k1' }],
      verifier: 'google',
    };

    (jose.jwtVerify as jest.Mock).mockResolvedValue({ payload: mockPayload });

    const result = await service.verifyIdToken('token', 'abc123', 'social');

    expect(result).toEqual(mockPayload);
  });
});
```

### Pattern 4: Testing QueryBuilder Operations

VaultService uses QueryBuilder for quota calculations. Mock the chained methods.

```typescript
describe('VaultService.getQuota', () => {
  it('should calculate quota from SUM of pinned CIDs', async () => {
    const mockQueryBuilder = {
      select: jest.fn().mockReturnThis(),
      where: jest.fn().mockReturnThis(),
      getRawOne: jest.fn().mockResolvedValue({ total: '1048576' }), // 1 MiB
    };

    pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder as any);

    const result = await service.getQuota('user-id');

    expect(result).toEqual({
      usedBytes: 1048576,
      limitBytes: 524288000,
      remainingBytes: 523239424,
    });
  });
});
```

### Pattern 5: Testing JwtStrategy with ConfigService

JwtStrategy requires ConfigService for JWT_SECRET. Test both successful validation and missing config.

```typescript
describe('JwtStrategy', () => {
  it('should throw if JWT_SECRET is not configured', async () => {
    await expect(
      Test.createTestingModule({
        providers: [
          JwtStrategy,
          {
            provide: ConfigService,
            useValue: { get: jest.fn(() => undefined) },
          },
          {
            provide: getRepositoryToken(User),
            useValue: {},
          },
        ],
      }).compile()
    ).rejects.toThrow('JWT_SECRET environment variable is not set');
  });

  it('should validate JWT payload and return user', async () => {
    const mockUser = { id: 'user-uuid', publicKey: 'key' };
    userRepository.findOne.mockResolvedValue(mockUser as User);

    const result = await strategy.validate({ sub: 'user-uuid', publicKey: 'key' });

    expect(result).toEqual(mockUser);
  });
});
```

### Anti-Patterns to Avoid

- **Mocking implementation details:** Don't mock private methods or internal state
- **Over-mocking:** Don't mock the service under test, only its dependencies
- **Shared mutable state:** Reset mocks in `beforeEach`, not `beforeAll`
- **Coupling to TypeORM internals:** Mock repository methods, not TypeORM connection details
- **Testing framework code:** Don't test NestJS decorators or guards that just extend base classes

## Don't Hand-Roll

| Problem                  | Don't Build          | Use Instead                | Why                                     |
| ------------------------ | -------------------- | -------------------------- | --------------------------------------- |
| Mock repository factory  | Custom mock factory  | Jest inline mocks          | Simpler, no abstraction layer           |
| Test database            | In-memory SQLite     | Jest mocks                 | Unit tests should not touch DB          |
| HTTP request mocking     | Custom fetch wrapper | Jest mock of global.fetch  | Already working in ipfs.service.spec.ts |
| JWT generation for tests | Real JwtService      | Mock with hardcoded tokens | Faster, deterministic                   |
| JWKS validation          | Real jose calls      | Mock jose module           | Network-independent tests               |

## Common Pitfalls

### Pitfall 1: Forgetting async/await in Repository Mocks

**What goes wrong:** Tests pass but coverage misses error paths
**Why it happens:** `mockReturnValue` vs `mockResolvedValue` confusion
**How to avoid:** Always use `mockResolvedValue` for async repository methods
**Warning signs:** Tests passing but code not executing as expected

### Pitfall 2: Not Resetting Mocks Between Tests

**What goes wrong:** Tests pass individually, fail when run together
**Why it happens:** Mock call counts accumulate across tests
**How to avoid:** Use `jest.resetAllMocks()` in `afterEach`
**Warning signs:** Flaky tests that pass/fail depending on test order

### Pitfall 3: Mocking argon2 Incorrectly

**What goes wrong:** Hash verification fails in tests
**Why it happens:** argon2.verify returns boolean, argon2.hash returns string
**How to avoid:**

```typescript
jest.mock('argon2', () => ({
  hash: jest.fn().mockResolvedValue('$argon2id$mocked-hash'),
  verify: jest.fn().mockResolvedValue(true),
}));
```

**Warning signs:** "Invalid hash format" errors in tests

### Pitfall 4: QueryBuilder Mock Chain Breaking

**What goes wrong:** "Cannot read property 'where' of undefined"
**Why it happens:** Missing `mockReturnThis()` in chain
**How to avoid:** Every chainable method must return `this`:

```typescript
const qb = {
  select: jest.fn().mockReturnThis(),
  where: jest.fn().mockReturnThis(),
  getRawOne: jest.fn().mockResolvedValue({ total: '0' }),
};
```

**Warning signs:** Type errors about undefined method calls

### Pitfall 5: Testing Controller with Missing Guard Mock

**What goes wrong:** Controller tests fail with authentication errors
**Why it happens:** JwtAuthGuard executes during test
**How to avoid:** Override the guard in test module:

```typescript
const module = await Test.createTestingModule({
  controllers: [AuthController],
  providers: [{ provide: AuthService, useValue: mockAuthService }],
})
  .overrideGuard(JwtAuthGuard)
  .useValue({ canActivate: () => true })
  .compile();
```

**Warning signs:** UnauthorizedException in controller unit tests

## Code Examples

### Complete AuthService Test Setup

```typescript
// auth/auth.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { UnauthorizedException, BadRequestException } from '@nestjs/common';
import { AuthService } from './auth.service';
import { Web3AuthVerifierService } from './services/web3auth-verifier.service';
import { TokenService } from './services/token.service';
import { User } from './entities/user.entity';
import { AuthMethod } from './entities/auth-method.entity';
import { RefreshToken } from './entities/refresh-token.entity';

describe('AuthService', () => {
  let service: AuthService;
  let web3AuthVerifier: jest.Mocked<Web3AuthVerifierService>;
  let tokenService: jest.Mocked<TokenService>;
  let userRepository: jest.Mocked<any>;
  let authMethodRepository: jest.Mocked<any>;
  let refreshTokenRepository: jest.Mocked<any>;

  beforeEach(async () => {
    const mockUserRepo = {
      findOne: jest.fn(),
      save: jest.fn(),
    };

    const mockAuthMethodRepo = {
      findOne: jest.fn(),
      find: jest.fn(),
      save: jest.fn(),
      count: jest.fn(),
      remove: jest.fn(),
    };

    const mockRefreshTokenRepo = {
      find: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
    };

    const mockWeb3AuthVerifier = {
      verifyIdToken: jest.fn(),
      extractAuthMethodType: jest.fn(),
      extractIdentifier: jest.fn(),
    };

    const mockTokenService = {
      createTokens: jest.fn(),
      rotateRefreshToken: jest.fn(),
      revokeAllUserTokens: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        { provide: Web3AuthVerifierService, useValue: mockWeb3AuthVerifier },
        { provide: TokenService, useValue: mockTokenService },
        { provide: getRepositoryToken(User), useValue: mockUserRepo },
        { provide: getRepositoryToken(AuthMethod), useValue: mockAuthMethodRepo },
        { provide: getRepositoryToken(RefreshToken), useValue: mockRefreshTokenRepo },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    web3AuthVerifier = module.get(Web3AuthVerifierService);
    tokenService = module.get(TokenService);
    userRepository = module.get(getRepositoryToken(User));
    authMethodRepository = module.get(getRepositoryToken(AuthMethod));
    refreshTokenRepository = module.get(getRepositoryToken(RefreshToken));
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('login', () => {
    const loginDto = {
      idToken: 'valid-token',
      publicKey: 'abc123',
      loginType: 'social' as const,
    };

    it('should create new user on first login', async () => {
      const mockPayload = { verifier: 'google', email: 'test@example.com' };
      const mockUser = { id: 'new-user-id', publicKey: 'abc123' };
      const mockTokens = { accessToken: 'at', refreshToken: 'rt' };

      web3AuthVerifier.verifyIdToken.mockResolvedValue(mockPayload);
      web3AuthVerifier.extractAuthMethodType.mockReturnValue('google');
      web3AuthVerifier.extractIdentifier.mockReturnValue('test@example.com');
      userRepository.findOne.mockResolvedValue(null); // No existing user
      userRepository.save.mockResolvedValue(mockUser);
      authMethodRepository.findOne.mockResolvedValue(null);
      authMethodRepository.save.mockResolvedValue({ id: 'am-1', type: 'google' });
      tokenService.createTokens.mockResolvedValue(mockTokens);

      const result = await service.login(loginDto);

      expect(result.isNewUser).toBe(true);
      expect(result.accessToken).toBe('at');
      expect(userRepository.save).toHaveBeenCalled();
    });

    it('should return existing user on subsequent login', async () => {
      const mockPayload = { verifier: 'google', email: 'test@example.com' };
      const mockUser = { id: 'existing-id', publicKey: 'abc123' };
      const mockAuthMethod = { id: 'am-1', userId: 'existing-id', type: 'google' };
      const mockTokens = { accessToken: 'at', refreshToken: 'rt' };

      web3AuthVerifier.verifyIdToken.mockResolvedValue(mockPayload);
      web3AuthVerifier.extractAuthMethodType.mockReturnValue('google');
      web3AuthVerifier.extractIdentifier.mockReturnValue('test@example.com');
      userRepository.findOne.mockResolvedValue(mockUser);
      authMethodRepository.findOne.mockResolvedValue(mockAuthMethod);
      authMethodRepository.save.mockResolvedValue(mockAuthMethod);
      tokenService.createTokens.mockResolvedValue(mockTokens);

      const result = await service.login(loginDto);

      expect(result.isNewUser).toBe(false);
      expect(userRepository.save).not.toHaveBeenCalled();
    });
  });
});
```

### VaultService Test with QueryBuilder Mock

```typescript
// vault/vault.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ConflictException, NotFoundException } from '@nestjs/common';
import { VaultService, QUOTA_LIMIT_BYTES } from './vault.service';
import { Vault } from './entities/vault.entity';
import { PinnedCid } from './entities/pinned-cid.entity';

describe('VaultService', () => {
  let service: VaultService;
  let vaultRepository: jest.Mocked<any>;
  let pinnedCidRepository: jest.Mocked<any>;

  beforeEach(async () => {
    const mockVaultRepo = {
      findOne: jest.fn(),
      create: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
    };

    const mockPinnedCidRepo = {
      createQueryBuilder: jest.fn(),
      delete: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        VaultService,
        { provide: getRepositoryToken(Vault), useValue: mockVaultRepo },
        { provide: getRepositoryToken(PinnedCid), useValue: mockPinnedCidRepo },
      ],
    }).compile();

    service = module.get<VaultService>(VaultService);
    vaultRepository = module.get(getRepositoryToken(Vault));
    pinnedCidRepository = module.get(getRepositoryToken(PinnedCid));
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('getQuota', () => {
    it('should return quota with calculated values', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ total: '104857600' }), // 100 MiB
      };
      pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getQuota('user-id');

      expect(result.usedBytes).toBe(104857600);
      expect(result.limitBytes).toBe(QUOTA_LIMIT_BYTES);
      expect(result.remainingBytes).toBe(QUOTA_LIMIT_BYTES - 104857600);
    });

    it('should return full quota when no pins exist', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ total: '0' }),
      };
      pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getQuota('user-id');

      expect(result.usedBytes).toBe(0);
      expect(result.remainingBytes).toBe(QUOTA_LIMIT_BYTES);
    });
  });

  describe('initializeVault', () => {
    const initDto = {
      ownerPublicKey: 'abcd1234',
      encryptedRootFolderKey: 'encrypted-key-hex',
      encryptedRootIpnsPrivateKey: 'encrypted-ipns-hex',
      rootIpnsName: 'k51...',
    };

    it('should create vault for new user', async () => {
      vaultRepository.findOne.mockResolvedValue(null);
      vaultRepository.create.mockReturnValue({ id: 'vault-id', ...initDto });
      vaultRepository.save.mockResolvedValue({
        id: 'vault-id',
        ownerPublicKey: Buffer.from(initDto.ownerPublicKey, 'hex'),
        encryptedRootFolderKey: Buffer.from(initDto.encryptedRootFolderKey, 'hex'),
        encryptedRootIpnsPrivateKey: Buffer.from(initDto.encryptedRootIpnsPrivateKey, 'hex'),
        rootIpnsName: initDto.rootIpnsName,
        createdAt: new Date(),
        initializedAt: null,
      });

      const result = await service.initializeVault('user-id', initDto);

      expect(result.id).toBe('vault-id');
      expect(vaultRepository.create).toHaveBeenCalled();
    });

    it('should throw ConflictException if vault exists', async () => {
      vaultRepository.findOne.mockResolvedValue({ id: 'existing' });

      await expect(service.initializeVault('user-id', initDto)).rejects.toThrow(ConflictException);
    });
  });
});
```

## Coverage Configuration

### Jest Coverage Thresholds

Update `apps/api/jest.config.js` to enforce per-directory thresholds:

```javascript
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.module.ts', // Exclude module files (configuration only)
    '!**/index.ts', // Exclude barrel exports
    '!**/dto/**', // Exclude DTOs (class definitions)
    '!**/entities/**', // Exclude entities (TypeORM decorators)
    '!main.ts', // Exclude bootstrap
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  coverageThreshold: {
    global: {
      lines: 85,
      branches: 80,
      functions: 85,
      statements: 85,
    },
    './auth/*.ts': {
      lines: 90,
      branches: 85,
    },
    './auth/services/*.ts': {
      lines: 90,
      branches: 85,
    },
    './vault/vault.service.ts': {
      lines: 90,
      branches: 85,
    },
    './ipfs/ipfs.service.ts': {
      lines: 85,
      branches: 80,
    },
    './auth/guards/*.ts': {
      lines: 90,
      branches: 85,
    },
    './**/**.controller.ts': {
      lines: 80,
      branches: 75,
    },
  },
};
```

**Source:** [Jest Configuration Documentation](https://jestjs.io/docs/configuration)

### Coverage Exclusions

Exclude from coverage (low value):

- `*.module.ts` - NestJS configuration only
- `index.ts` - Barrel exports
- `dto/**` - Class property declarations with decorators
- `entities/**` - TypeORM entity definitions
- `main.ts` - Application bootstrap

## Test File Organization

### Recommended Structure

```
apps/api/src/
├── auth/
│   ├── auth.controller.ts
│   ├── auth.controller.spec.ts       # NEW
│   ├── auth.service.ts
│   ├── auth.service.spec.ts          # NEW
│   ├── guards/
│   │   ├── jwt-auth.guard.ts
│   │   └── jwt-auth.guard.spec.ts    # NEW (minimal)
│   ├── services/
│   │   ├── token.service.ts
│   │   ├── token.service.spec.ts     # NEW
│   │   ├── web3auth-verifier.service.ts
│   │   └── web3auth-verifier.service.spec.ts  # NEW
│   └── strategies/
│       ├── jwt.strategy.ts
│       └── jwt.strategy.spec.ts      # NEW
├── vault/
│   ├── vault.controller.ts
│   ├── vault.controller.spec.ts      # NEW
│   ├── vault.service.ts
│   └── vault.service.spec.ts         # NEW
└── ipfs/
    ├── ipfs.controller.ts
    ├── ipfs.controller.spec.ts       # NEW
    ├── ipfs.service.ts
    └── ipfs.service.spec.ts          # EXISTS (12 tests)
```

## Test Scenarios Matrix

### AuthService (7 methods)

| Method             | Happy Path              | Error Cases                             | Edge Cases                             |
| ------------------ | ----------------------- | --------------------------------------- | -------------------------------------- |
| `login`            | New user, existing user | Invalid token, key mismatch             | External wallet with derivationVersion |
| `refresh`          | Valid token             | Invalid token, expired                  | -                                      |
| `logout`           | Success                 | -                                       | -                                      |
| `refreshByToken`   | Valid token             | Invalid token, expired, already revoked | Multiple tokens, hash verification     |
| `getLinkedMethods` | Return methods          | Empty list                              | -                                      |
| `linkMethod`       | Link new                | Already linked, key mismatch            | -                                      |
| `unlinkMethod`     | Unlink                  | Not found, last method                  | -                                      |

### TokenService (4 methods)

| Method                | Happy Path      | Error Cases            | Edge Cases                |
| --------------------- | --------------- | ---------------------- | ------------------------- |
| `createTokens`        | Generate tokens | -                      | Verify expiry calculation |
| `rotateRefreshToken`  | New tokens      | Invalid token, expired | Multiple tokens to check  |
| `revokeAllUserTokens` | Update all      | No tokens exist        | -                         |
| `revokeToken`         | Update single   | Token not found        | Already revoked           |

### VaultService (8 methods)

| Method            | Happy Path  | Error Cases    | Edge Cases             |
| ----------------- | ----------- | -------------- | ---------------------- |
| `initializeVault` | Create      | Already exists | -                      |
| `getVault`        | Return      | Not found      | -                      |
| `findVault`       | Return/null | -              | -                      |
| `getQuota`        | Calculate   | -              | No pins, at limit      |
| `checkQuota`      | True/false  | -              | Exact limit            |
| `recordPin`       | Insert      | -              | Duplicate (idempotent) |
| `recordUnpin`     | Delete      | -              | Not found (idempotent) |
| `markInitialized` | Update      | -              | Already initialized    |

### Web3AuthVerifierService (3 methods)

| Method                  | Happy Path                | Error Cases                               | Edge Cases       |
| ----------------------- | ------------------------- | ----------------------------------------- | ---------------- |
| `verifyIdToken`         | Social, external wallet   | Invalid JWT, key mismatch, missing wallet | Wrong algorithm  |
| `extractIdentifier`     | Email, verifierId, wallet | No identifier                             | -                |
| `extractAuthMethodType` | All providers             | -                                         | Unknown verifier |

## Open Questions

1. **argon2 mocking strategy:**
   - Should we mock argon2 globally or per-test?
   - Recommendation: Per-test for explicit control over verify return values

2. **JwtAuthGuard testing value:**
   - Guard only extends AuthGuard with no custom logic
   - Recommendation: Minimal test (instantiation only) or skip, as it's framework code

## Sources

### Primary (HIGH confidence)

- Existing `apps/api/src/ipfs/ipfs.service.spec.ts` - Working test pattern in codebase
- [Jest Configuration Documentation](https://jestjs.io/docs/configuration) - Coverage thresholds
- `.planning/codebase/TESTING.md` - Coverage requirements specification

### Secondary (MEDIUM confidence)

- [NestJS TypeORM Testing Guide](https://www.restack.io/p/nestjs-typeorm-testing) - Repository mocking patterns
- [testing-nestjs Repository](https://github.com/jmcdo29/testing-nestjs) - Community patterns

### Tertiary (LOW confidence)

- [Medium: Testing custom repositories](https://medium.com/@sevicdev/testing-custom-repositories-nestjs-typeorm-3b20d4448db0) - Additional patterns

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - Using existing NestJS/Jest setup, no new libraries
- Architecture patterns: HIGH - Following existing ipfs.service.spec.ts pattern
- Coverage configuration: HIGH - Jest documentation is authoritative
- Mocking patterns: MEDIUM - Standard community patterns, verified with existing code

**Research date:** 2026-01-20
**Valid until:** 2026-02-20 (30 days - stable testing patterns)
