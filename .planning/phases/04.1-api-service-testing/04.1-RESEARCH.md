# Phase 4.1: API Service Testing - Research

**Researched:** 2026-01-20
**Domain:** NestJS unit testing with Jest, TypeORM mocking
**Confidence:** HIGH

## Summary

This research documents the current state of the backend codebase and establishes testing patterns for comprehensive unit test coverage. The backend uses NestJS with TypeORM, and Jest is already configured and working (12 tests passing for IpfsService).

The project requires specific coverage thresholds per TESTING.md:

- Auth Services: 90% line, 85% branch
- Vault Services: 90% line, 85% branch
- IPFS/IPNS Services: 85% line, 80% branch
- Controllers: 80% line, 75% branch
- Guards/Middleware: 90% line, 85% branch
- Overall Minimum: 85% line, 80% branch

**Primary recommendation:** Follow the existing `ipfs.service.spec.ts` pattern for consistency. Use `@nestjs/testing` TestingModule with mocked providers. Configure Jest `coverageThreshold` to enforce per-directory coverage requirements.

## Current State Analysis

### Existing Test Infrastructure

| Component       | Status     | Notes                                                    |
| --------------- | ---------- | -------------------------------------------------------- |
| Jest            | Configured | `jest.config.js` in apps/api                             |
| @nestjs/testing | Installed  | v11.0.0 in devDependencies                               |
| ts-jest         | Installed  | v29.3.0                                                  |
| Test script     | Working    | `pnpm test` runs Jest                                    |
| Coverage script | Working    | `pnpm test:cov` generates report                         |
| Existing tests  | 1 file     | `ipfs.service.spec.ts` (12 tests, 100% service coverage) |

### Current Coverage Snapshot (from `pnpm test:cov`)

```
Overall: 7.49% lines, 7.3% branches (only IpfsService fully tested)
IpfsService: 100% lines, 88.46% branch
All other services: 0%
All controllers: 0%
All guards/strategies: 0%
```

### Services to Test

| Service                 | File                                         | Lines | Methods   | Dependencies                                   | Priority |
| ----------------------- | -------------------------------------------- | ----- | --------- | ---------------------------------------------- | -------- |
| AuthService             | `auth/auth.service.ts`                       | ~258  | 7 methods | Web3AuthVerifierService, TokenService, 3 repos | HIGH     |
| TokenService            | `auth/services/token.service.ts`             | ~102  | 4 methods | JwtService, RefreshToken repo, argon2          | HIGH     |
| Web3AuthVerifierService | `auth/services/web3auth-verifier.service.ts` | ~137  | 3 methods | jose (external JWKS)                           | HIGH     |
| VaultService            | `vault/vault.service.ts`                     | ~161  | 8 methods | Vault repo, PinnedCid repo (with QueryBuilder) | HIGH     |
| IpfsService             | `ipfs/ipfs.service.ts`                       | ~141  | 2 methods | ConfigService, fetch                           | DONE     |
| JwtStrategy             | `auth/strategies/jwt.strategy.ts`            | ~45   | 1 method  | ConfigService, User repo                       | MEDIUM   |
| JwtAuthGuard            | `auth/guards/jwt-auth.guard.ts`              | ~5    | 0 methods | Extends AuthGuard                              | LOW      |

### Controllers to Test

| Controller      | File                        | Endpoints   | Complexity | Notes                     |
| --------------- | --------------------------- | ----------- | ---------- | ------------------------- |
| AuthController  | `auth/auth.controller.ts`   | 6 endpoints | MEDIUM     | Cookie handling, guards   |
| VaultController | `vault/vault.controller.ts` | 3 endpoints | LOW        | Thin wrapper over service |
| IpfsController  | `ipfs/ipfs.controller.ts`   | 2 endpoints | MEDIUM     | File upload interceptor   |

## Standard Stack

### Core Testing Libraries (Already Installed)

| Library         | Version | Purpose                         |
| --------------- | ------- | ------------------------------- |
| jest            | ^29.7.0 | Test runner                     |
| ts-jest         | ^29.3.0 | TypeScript transformer for Jest |
| @nestjs/testing | ^11.0.0 | NestJS TestingModule creation   |
| @types/jest     | ^29.5.0 | TypeScript definitions          |

### No Additional Libraries Needed

The existing setup is complete. Do NOT add:

- supertest (not needed for unit tests, only E2E)
- @golevelup/ts-jest (unnecessary abstraction)
- jest-mock-extended (native Jest mocks sufficient)

## Architecture Patterns

### Pattern 1: TestingModule with Mocked Providers

The standard NestJS unit test pattern. Use `Test.createTestingModule()` with mocked dependencies.

**Source:** Existing `ipfs.service.spec.ts` in codebase

```typescript
// Example pattern from ipfs.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { MyService } from './my.service';

describe('MyService', () => {
  let service: MyService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MyService,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn((key: string) => {
              if (key === 'SOME_CONFIG') return 'mock-value';
              return undefined;
            }),
          },
        },
      ],
    }).compile();

    service = module.get<MyService>(MyService);
  });

  // tests...
});
```

### Pattern 2: Mocking TypeORM Repositories

Use `getRepositoryToken()` to provide mock repositories.

**Source:** [NestJS TypeORM Testing Pattern](https://github.com/nestjs/nest/issues/415)

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;
  let userRepository: jest.Mocked<Repository<User>>;

  beforeEach(async () => {
    const mockRepository = {
      findOne: jest.fn(),
      find: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      remove: jest.fn(),
      count: jest.fn(),
      createQueryBuilder: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: getRepositoryToken(User),
          useValue: mockRepository,
        },
        // ... other mocked dependencies
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    userRepository = module.get(getRepositoryToken(User));
  });

  it('should find user by publicKey', async () => {
    const mockUser = { id: 'uuid', publicKey: 'key123' };
    userRepository.findOne.mockResolvedValue(mockUser as User);

    const result = await service.findByPublicKey('key123');

    expect(userRepository.findOne).toHaveBeenCalledWith({
      where: { publicKey: 'key123' },
    });
    expect(result).toEqual(mockUser);
  });
});
```

### Pattern 3: Mocking External HTTP Services (jose library)

For services that make external HTTP calls (like Web3AuthVerifierService fetching JWKS), mock the external module.

```typescript
// Mock jose module at module level
jest.mock('jose', () => ({
  createRemoteJWKSet: jest.fn(() => jest.fn()),
  jwtVerify: jest.fn(),
}));

import * as jose from 'jose';
import { Web3AuthVerifierService } from './web3auth-verifier.service';

describe('Web3AuthVerifierService', () => {
  let service: Web3AuthVerifierService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [Web3AuthVerifierService],
    }).compile();

    service = module.get<Web3AuthVerifierService>(Web3AuthVerifierService);
  });

  it('should verify social login token', async () => {
    const mockPayload = {
      wallets: [{ type: 'web3auth_app_key', public_key: 'abc123', curve: 'secp256k1' }],
      verifier: 'google',
    };

    (jose.jwtVerify as jest.Mock).mockResolvedValue({ payload: mockPayload });

    const result = await service.verifyIdToken('token', 'abc123', 'social');

    expect(result).toEqual(mockPayload);
  });
});
```

### Pattern 4: Testing QueryBuilder Operations (VaultService)

VaultService uses QueryBuilder for quota calculations (`getQuota`) and pin recording (`recordPin`). Mock the chained methods with `mockReturnThis()`.

**Source:** [TypeORM QueryBuilder Mock Pattern](https://github.com/typeorm/typeorm/issues/1774)

```typescript
describe('VaultService.getQuota', () => {
  it('should calculate quota from SUM of pinned CIDs', async () => {
    const mockQueryBuilder = {
      select: jest.fn().mockReturnThis(),
      where: jest.fn().mockReturnThis(),
      getRawOne: jest.fn().mockResolvedValue({ total: '1048576' }), // 1 MiB
    };

    pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder as any);

    const result = await service.getQuota('user-id');

    expect(result).toEqual({
      usedBytes: 1048576,
      limitBytes: 524288000,
      remainingBytes: 523239424,
    });
  });
});
```

For `recordPin` with INSERT/orIgnore:

```typescript
describe('VaultService.recordPin', () => {
  it('should insert pin record with orIgnore for idempotency', async () => {
    const mockQueryBuilder = {
      insert: jest.fn().mockReturnThis(),
      into: jest.fn().mockReturnThis(),
      values: jest.fn().mockReturnThis(),
      orIgnore: jest.fn().mockReturnThis(),
      execute: jest.fn().mockResolvedValue({ affected: 1 }),
    };

    pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder as any);

    await service.recordPin('user-id', 'bafk...', 1024);

    expect(mockQueryBuilder.values).toHaveBeenCalledWith({
      userId: 'user-id',
      cid: 'bafk...',
      sizeBytes: '1024',
    });
    expect(mockQueryBuilder.orIgnore).toHaveBeenCalled();
  });
});
```

### Pattern 5: Testing JwtStrategy with ConfigService

JwtStrategy requires ConfigService for JWT_SECRET. Test both successful validation and missing config.

```typescript
describe('JwtStrategy', () => {
  it('should throw if JWT_SECRET is not configured', async () => {
    await expect(
      Test.createTestingModule({
        providers: [
          JwtStrategy,
          {
            provide: ConfigService,
            useValue: { get: jest.fn(() => undefined) },
          },
          {
            provide: getRepositoryToken(User),
            useValue: {},
          },
        ],
      }).compile()
    ).rejects.toThrow('JWT_SECRET environment variable is not set');
  });

  it('should validate JWT payload and return user', async () => {
    const mockUser = { id: 'user-uuid', publicKey: 'key' };
    userRepository.findOne.mockResolvedValue(mockUser as User);

    const result = await strategy.validate({ sub: 'user-uuid', publicKey: 'key' });

    expect(result).toEqual(mockUser);
  });
});
```

### Pattern 6: Controller Testing with Service Mocks and Guard Override

**Source:** [NestJS Testing Controllers](https://docs.nestjs.com/fundamentals/testing)

```typescript
describe('AuthController', () => {
  let controller: AuthController;
  let mockAuthService: jest.Mocked<Partial<AuthService>>;

  beforeEach(async () => {
    mockAuthService = {
      login: jest.fn(),
      logout: jest.fn(),
      refreshByToken: jest.fn(),
      getLinkedMethods: jest.fn(),
      linkMethod: jest.fn(),
      unlinkMethod: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [{ provide: AuthService, useValue: mockAuthService }],
    })
      .overrideGuard(JwtAuthGuard)
      .useValue({ canActivate: () => true })
      .compile();

    controller = module.get<AuthController>(AuthController);
  });

  describe('login', () => {
    it('should set refresh token in HTTP-only cookie', async () => {
      const mockResponse = {
        cookie: jest.fn(),
      } as unknown as Response;

      mockAuthService.login.mockResolvedValue({
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
        isNewUser: false,
      });

      const result = await controller.login(
        { idToken: 'token', publicKey: 'key', loginType: 'social' },
        mockResponse
      );

      expect(mockResponse.cookie).toHaveBeenCalledWith(
        'refresh_token',
        'refresh-token',
        expect.objectContaining({ httpOnly: true, path: '/auth' })
      );
      expect(result.accessToken).toBe('access-token');
    });
  });
});
```

### Anti-Patterns to Avoid

- **Mocking implementation details:** Don't mock private methods or internal state
- **Over-mocking:** Don't mock the service under test, only its dependencies
- **Shared mutable state:** Reset mocks in `afterEach`, not `beforeAll`
- **Coupling to TypeORM internals:** Mock repository methods, not TypeORM connection details
- **Testing framework code:** Don't test NestJS decorators or guards that just extend base classes
- **Mocking cryptographic functions:** Per TESTING.md, do NOT mock argon2 - test real implementations

## Don't Hand-Roll

| Problem                  | Don't Build          | Use Instead                | Why                                     |
| ------------------------ | -------------------- | -------------------------- | --------------------------------------- |
| Mock repository factory  | Custom mock factory  | Jest inline mocks          | Simpler, no abstraction layer           |
| Test database            | In-memory SQLite     | Jest mocks                 | Unit tests should not touch DB          |
| HTTP request mocking     | Custom fetch wrapper | Jest mock of global.fetch  | Already working in ipfs.service.spec.ts |
| JWT generation for tests | Real JwtService      | Mock with hardcoded tokens | Faster, deterministic                   |
| JWKS validation          | Real jose calls      | Mock jose module           | Network-independent tests               |

## Common Pitfalls

### Pitfall 1: Forgetting async/await in Repository Mocks

**What goes wrong:** Tests pass but coverage misses error paths
**Why it happens:** `mockReturnValue` vs `mockResolvedValue` confusion
**How to avoid:** Always use `mockResolvedValue` for async repository methods
**Warning signs:** Tests passing but code not executing as expected

### Pitfall 2: Not Resetting Mocks Between Tests

**What goes wrong:** Tests pass individually, fail when run together
**Why it happens:** Mock call counts accumulate across tests
**How to avoid:** Use `jest.resetAllMocks()` in `afterEach`
**Warning signs:** Flaky tests that pass/fail depending on test order

### Pitfall 3: Mocking argon2 Incorrectly

**What goes wrong:** Hash verification fails in tests or misses real bugs
**Why it happens:** argon2.verify returns boolean, argon2.hash returns string
**TESTING.md guidance:** Do NOT mock crypto functions - test with real implementations
**How to handle:** Use real argon2, accept slightly slower tests for correctness

### Pitfall 4: QueryBuilder Mock Chain Breaking

**What goes wrong:** "Cannot read property 'where' of undefined"
**Why it happens:** Missing `mockReturnThis()` in chain
**How to avoid:** Every chainable method must return `this`:

```typescript
const qb = {
  select: jest.fn().mockReturnThis(),
  where: jest.fn().mockReturnThis(),
  insert: jest.fn().mockReturnThis(),
  into: jest.fn().mockReturnThis(),
  values: jest.fn().mockReturnThis(),
  orIgnore: jest.fn().mockReturnThis(),
  execute: jest.fn().mockResolvedValue({ affected: 1 }),
  getRawOne: jest.fn().mockResolvedValue({ total: '0' }),
};
```

**Warning signs:** Type errors about undefined method calls

### Pitfall 5: Testing Controller with Missing Guard Mock

**What goes wrong:** Controller tests fail with authentication errors
**Why it happens:** JwtAuthGuard executes during test
**How to avoid:** Override the guard in test module:

```typescript
const module = await Test.createTestingModule({
  controllers: [AuthController],
  providers: [{ provide: AuthService, useValue: mockAuthService }],
})
  .overrideGuard(JwtAuthGuard)
  .useValue({ canActivate: () => true })
  .compile();
```

**Warning signs:** UnauthorizedException in controller unit tests

### Pitfall 6: Not Testing Error Branches

**What goes wrong:** High line coverage but low branch coverage
**Why it happens:** Focus on happy paths only
**How to avoid:** For each method, test: success, invalid input, missing data, external failure
**Warning signs:** Branch coverage below thresholds despite many tests

## Code Examples

### Complete AuthService Test Setup

```typescript
// auth/auth.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { UnauthorizedException, BadRequestException } from '@nestjs/common';
import { AuthService } from './auth.service';
import { Web3AuthVerifierService } from './services/web3auth-verifier.service';
import { TokenService } from './services/token.service';
import { User } from './entities/user.entity';
import { AuthMethod } from './entities/auth-method.entity';
import { RefreshToken } from './entities/refresh-token.entity';

describe('AuthService', () => {
  let service: AuthService;
  let web3AuthVerifier: jest.Mocked<Web3AuthVerifierService>;
  let tokenService: jest.Mocked<TokenService>;
  let userRepository: jest.Mocked<any>;
  let authMethodRepository: jest.Mocked<any>;
  let refreshTokenRepository: jest.Mocked<any>;

  beforeEach(async () => {
    const mockUserRepo = {
      findOne: jest.fn(),
      save: jest.fn(),
    };

    const mockAuthMethodRepo = {
      findOne: jest.fn(),
      find: jest.fn(),
      save: jest.fn(),
      count: jest.fn(),
      remove: jest.fn(),
    };

    const mockRefreshTokenRepo = {
      find: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
    };

    const mockWeb3AuthVerifier = {
      verifyIdToken: jest.fn(),
      extractAuthMethodType: jest.fn(),
      extractIdentifier: jest.fn(),
    };

    const mockTokenService = {
      createTokens: jest.fn(),
      rotateRefreshToken: jest.fn(),
      revokeAllUserTokens: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        { provide: Web3AuthVerifierService, useValue: mockWeb3AuthVerifier },
        { provide: TokenService, useValue: mockTokenService },
        { provide: getRepositoryToken(User), useValue: mockUserRepo },
        { provide: getRepositoryToken(AuthMethod), useValue: mockAuthMethodRepo },
        { provide: getRepositoryToken(RefreshToken), useValue: mockRefreshTokenRepo },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    web3AuthVerifier = module.get(Web3AuthVerifierService);
    tokenService = module.get(TokenService);
    userRepository = module.get(getRepositoryToken(User));
    authMethodRepository = module.get(getRepositoryToken(AuthMethod));
    refreshTokenRepository = module.get(getRepositoryToken(RefreshToken));
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('login', () => {
    const loginDto = {
      idToken: 'valid-token',
      publicKey: 'abc123',
      loginType: 'social' as const,
    };

    it('should create new user on first login', async () => {
      const mockPayload = { verifier: 'google', email: 'test@example.com' };
      const mockUser = { id: 'new-user-id', publicKey: 'abc123' };
      const mockTokens = { accessToken: 'at', refreshToken: 'rt' };

      web3AuthVerifier.verifyIdToken.mockResolvedValue(mockPayload);
      web3AuthVerifier.extractAuthMethodType.mockReturnValue('google');
      web3AuthVerifier.extractIdentifier.mockReturnValue('test@example.com');
      userRepository.findOne.mockResolvedValue(null); // No existing user
      userRepository.save.mockResolvedValue(mockUser);
      authMethodRepository.findOne.mockResolvedValue(null);
      authMethodRepository.save.mockResolvedValue({ id: 'am-1', type: 'google' });
      tokenService.createTokens.mockResolvedValue(mockTokens);

      const result = await service.login(loginDto);

      expect(result.isNewUser).toBe(true);
      expect(result.accessToken).toBe('at');
      expect(userRepository.save).toHaveBeenCalled();
    });

    it('should return existing user on subsequent login', async () => {
      const mockPayload = { verifier: 'google', email: 'test@example.com' };
      const mockUser = { id: 'existing-id', publicKey: 'abc123', derivationVersion: null };
      const mockAuthMethod = { id: 'am-1', userId: 'existing-id', type: 'google' };
      const mockTokens = { accessToken: 'at', refreshToken: 'rt' };

      web3AuthVerifier.verifyIdToken.mockResolvedValue(mockPayload);
      web3AuthVerifier.extractAuthMethodType.mockReturnValue('google');
      web3AuthVerifier.extractIdentifier.mockReturnValue('test@example.com');
      userRepository.findOne.mockResolvedValue(mockUser);
      authMethodRepository.findOne.mockResolvedValue(mockAuthMethod);
      authMethodRepository.save.mockResolvedValue(mockAuthMethod);
      tokenService.createTokens.mockResolvedValue(mockTokens);

      const result = await service.login(loginDto);

      expect(result.isNewUser).toBe(false);
    });

    it('should handle external wallet login with derivationVersion', async () => {
      const externalLoginDto = {
        idToken: 'valid-token',
        publicKey: 'derived-key',
        loginType: 'external_wallet' as const,
        walletAddress: '0x123...',
        derivationVersion: 1,
      };
      const mockPayload = { wallets: [{ type: 'ethereum', address: '0x123...' }] };
      const mockUser = { id: 'user-id', publicKey: 'derived-key', derivationVersion: 1 };
      const mockTokens = { accessToken: 'at', refreshToken: 'rt' };

      web3AuthVerifier.verifyIdToken.mockResolvedValue(mockPayload);
      web3AuthVerifier.extractAuthMethodType.mockReturnValue('external_wallet');
      web3AuthVerifier.extractIdentifier.mockReturnValue('0x123...');
      userRepository.findOne.mockResolvedValue(null);
      userRepository.save.mockResolvedValue(mockUser);
      authMethodRepository.findOne.mockResolvedValue(null);
      authMethodRepository.save.mockResolvedValue({ id: 'am-1', type: 'external_wallet' });
      tokenService.createTokens.mockResolvedValue(mockTokens);

      const result = await service.login(externalLoginDto);

      expect(userRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({
          publicKey: 'derived-key',
          derivationVersion: 1,
        })
      );
      expect(web3AuthVerifier.verifyIdToken).toHaveBeenCalledWith(
        'valid-token',
        '0x123...', // Should use walletAddress, not publicKey
        'external_wallet'
      );
    });
  });
});
```

### VaultService Test with QueryBuilder Mock

```typescript
// vault/vault.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ConflictException, NotFoundException } from '@nestjs/common';
import { VaultService, QUOTA_LIMIT_BYTES } from './vault.service';
import { Vault } from './entities/vault.entity';
import { PinnedCid } from './entities/pinned-cid.entity';

describe('VaultService', () => {
  let service: VaultService;
  let vaultRepository: jest.Mocked<any>;
  let pinnedCidRepository: jest.Mocked<any>;

  beforeEach(async () => {
    const mockVaultRepo = {
      findOne: jest.fn(),
      create: jest.fn(),
      save: jest.fn(),
      update: jest.fn(),
    };

    const mockPinnedCidRepo = {
      createQueryBuilder: jest.fn(),
      delete: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        VaultService,
        { provide: getRepositoryToken(Vault), useValue: mockVaultRepo },
        { provide: getRepositoryToken(PinnedCid), useValue: mockPinnedCidRepo },
      ],
    }).compile();

    service = module.get<VaultService>(VaultService);
    vaultRepository = module.get(getRepositoryToken(Vault));
    pinnedCidRepository = module.get(getRepositoryToken(PinnedCid));
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('getQuota', () => {
    it('should return quota with calculated values', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ total: '104857600' }), // 100 MiB
      };
      pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getQuota('user-id');

      expect(result.usedBytes).toBe(104857600);
      expect(result.limitBytes).toBe(QUOTA_LIMIT_BYTES);
      expect(result.remainingBytes).toBe(QUOTA_LIMIT_BYTES - 104857600);
    });

    it('should return full quota when no pins exist', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ total: '0' }),
      };
      pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getQuota('user-id');

      expect(result.usedBytes).toBe(0);
      expect(result.remainingBytes).toBe(QUOTA_LIMIT_BYTES);
    });

    it('should handle null total (no rows)', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ total: null }),
      };
      pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getQuota('user-id');

      expect(result.usedBytes).toBe(0);
    });
  });

  describe('initializeVault', () => {
    const initDto = {
      ownerPublicKey: 'abcd1234',
      encryptedRootFolderKey: 'encrypted-key-hex',
      encryptedRootIpnsPrivateKey: 'encrypted-ipns-hex',
      rootIpnsName: 'k51...',
    };

    it('should create vault for new user', async () => {
      vaultRepository.findOne.mockResolvedValue(null);
      vaultRepository.create.mockReturnValue({ id: 'vault-id', ...initDto });
      vaultRepository.save.mockResolvedValue({
        id: 'vault-id',
        ownerPublicKey: Buffer.from(initDto.ownerPublicKey, 'hex'),
        encryptedRootFolderKey: Buffer.from(initDto.encryptedRootFolderKey, 'hex'),
        encryptedRootIpnsPrivateKey: Buffer.from(initDto.encryptedRootIpnsPrivateKey, 'hex'),
        rootIpnsName: initDto.rootIpnsName,
        createdAt: new Date(),
        initializedAt: null,
      });

      const result = await service.initializeVault('user-id', initDto);

      expect(result.id).toBe('vault-id');
      expect(vaultRepository.create).toHaveBeenCalled();
    });

    it('should throw ConflictException if vault exists', async () => {
      vaultRepository.findOne.mockResolvedValue({ id: 'existing' });

      await expect(service.initializeVault('user-id', initDto)).rejects.toThrow(ConflictException);
    });
  });

  describe('recordPin', () => {
    it('should insert pin record with orIgnore for idempotency', async () => {
      const mockQueryBuilder = {
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        orIgnore: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue({ affected: 1 }),
      };
      pinnedCidRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      await service.recordPin('user-id', 'bafk...', 1024);

      expect(mockQueryBuilder.insert).toHaveBeenCalled();
      expect(mockQueryBuilder.into).toHaveBeenCalledWith(PinnedCid);
      expect(mockQueryBuilder.values).toHaveBeenCalledWith({
        userId: 'user-id',
        cid: 'bafk...',
        sizeBytes: '1024',
      });
      expect(mockQueryBuilder.orIgnore).toHaveBeenCalled();
      expect(mockQueryBuilder.execute).toHaveBeenCalled();
    });
  });
});
```

## Coverage Configuration

### Jest Coverage Thresholds

Update `apps/api/jest.config.js` to enforce per-directory thresholds:

```javascript
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.module.ts', // Exclude module files (configuration only)
    '!**/index.ts', // Exclude barrel exports
    '!**/dto/**', // Exclude DTOs (class definitions)
    '!**/entities/**', // Exclude entities (TypeORM decorators)
    '!main.ts', // Exclude bootstrap
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  coverageThreshold: {
    global: {
      lines: 85,
      branches: 80,
      functions: 85,
      statements: 85,
    },
    './auth/*.ts': {
      lines: 90,
      branches: 85,
    },
    './auth/services/*.ts': {
      lines: 90,
      branches: 85,
    },
    './vault/vault.service.ts': {
      lines: 90,
      branches: 85,
    },
    './ipfs/ipfs.service.ts': {
      lines: 85,
      branches: 80,
    },
    './auth/guards/*.ts': {
      lines: 90,
      branches: 85,
    },
    './**/**.controller.ts': {
      lines: 80,
      branches: 75,
    },
  },
};
```

**Source:** [Jest Configuration Documentation](https://jestjs.io/docs/configuration)

### Coverage Exclusions

Exclude from coverage (low value):

- `*.module.ts` - NestJS configuration only
- `index.ts` - Barrel exports
- `dto/**` - Class property declarations with decorators
- `entities/**` - TypeORM entity definitions
- `main.ts` - Application bootstrap

## Test File Organization

### Recommended Structure

```
apps/api/src/
├── auth/
│   ├── auth.controller.ts
│   ├── auth.controller.spec.ts       # NEW
│   ├── auth.service.ts
│   ├── auth.service.spec.ts          # NEW
│   ├── guards/
│   │   ├── jwt-auth.guard.ts
│   │   └── jwt-auth.guard.spec.ts    # NEW (minimal)
│   ├── services/
│   │   ├── token.service.ts
│   │   ├── token.service.spec.ts     # NEW
│   │   ├── web3auth-verifier.service.ts
│   │   └── web3auth-verifier.service.spec.ts  # NEW
│   └── strategies/
│       ├── jwt.strategy.ts
│       └── jwt.strategy.spec.ts      # NEW
├── vault/
│   ├── vault.controller.ts
│   ├── vault.controller.spec.ts      # NEW
│   ├── vault.service.ts
│   └── vault.service.spec.ts         # NEW
└── ipfs/
    ├── ipfs.controller.ts
    ├── ipfs.controller.spec.ts       # NEW
    ├── ipfs.service.ts
    └── ipfs.service.spec.ts          # EXISTS (12 tests)
```

## Test Scenarios Matrix

### AuthService (7 methods)

| Method             | Happy Path              | Error Cases                             | Edge Cases                             |
| ------------------ | ----------------------- | --------------------------------------- | -------------------------------------- |
| `login`            | New user, existing user | Invalid token, key mismatch             | External wallet with derivationVersion |
| `refresh`          | Valid token             | Invalid token, expired                  | -                                      |
| `logout`           | Success                 | -                                       | -                                      |
| `refreshByToken`   | Valid token             | Invalid token, expired, already revoked | Multiple tokens, hash verification     |
| `getLinkedMethods` | Return methods          | Empty list                              | -                                      |
| `linkMethod`       | Link new                | Already linked, key mismatch            | -                                      |
| `unlinkMethod`     | Unlink                  | Not found, last method                  | -                                      |

### TokenService (4 methods)

| Method                | Happy Path      | Error Cases            | Edge Cases                |
| --------------------- | --------------- | ---------------------- | ------------------------- |
| `createTokens`        | Generate tokens | -                      | Verify expiry calculation |
| `rotateRefreshToken`  | New tokens      | Invalid token, expired | Multiple tokens to check  |
| `revokeAllUserTokens` | Update all      | No tokens exist        | -                         |
| `revokeToken`         | Update single   | Token not found        | Already revoked           |

### VaultService (8 methods)

| Method            | Happy Path  | Error Cases    | Edge Cases             |
| ----------------- | ----------- | -------------- | ---------------------- |
| `initializeVault` | Create      | Already exists | -                      |
| `getVault`        | Return      | Not found      | -                      |
| `findVault`       | Return/null | -              | -                      |
| `getQuota`        | Calculate   | -              | No pins, at limit      |
| `checkQuota`      | True/false  | -              | Exact limit            |
| `recordPin`       | Insert      | -              | Duplicate (idempotent) |
| `recordUnpin`     | Delete      | -              | Not found (idempotent) |
| `markInitialized` | Update      | -              | Already initialized    |

### Web3AuthVerifierService (3 methods)

| Method                  | Happy Path                | Error Cases                               | Edge Cases       |
| ----------------------- | ------------------------- | ----------------------------------------- | ---------------- |
| `verifyIdToken`         | Social, external wallet   | Invalid JWT, key mismatch, missing wallet | Wrong algorithm  |
| `extractIdentifier`     | Email, verifierId, wallet | No identifier                             | -                |
| `extractAuthMethodType` | All providers             | -                                         | Unknown verifier |

## Open Questions

1. **argon2 test performance:**
   - What we know: TESTING.md says don't mock crypto, argon2 is slow by design
   - What's unclear: Will this make auth tests unacceptably slow?
   - Recommendation: Start with real argon2, measure test time, only optimize if > 10s total

2. **JwtAuthGuard testing value:**
   - Guard only extends AuthGuard with no custom logic
   - Recommendation: Minimal test (instantiation only) or skip, as it's framework code

## Sources

### Primary (HIGH confidence)

- Existing `apps/api/src/ipfs/ipfs.service.spec.ts` - Working test pattern in codebase
- [Jest Configuration Documentation](https://jestjs.io/docs/configuration) - Coverage thresholds
- `.planning/codebase/TESTING.md` - Coverage requirements specification

### Secondary (MEDIUM confidence)

- [NestJS Testing Documentation](https://docs.nestjs.com/fundamentals/testing) - Test.createTestingModule patterns
- [TypeORM Repository Mocking](https://github.com/nestjs/nest/issues/415) - getRepositoryToken pattern
- [QueryBuilder Mock Pattern](https://github.com/typeorm/typeorm/issues/1774) - Chainable mock approach

### Tertiary (LOW confidence)

- [Advanced Testing with Mocks in NestJS](https://trilon.io/blog/advanced-testing-strategies-with-mocks-in-nestjs) - Additional patterns

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - Using existing NestJS/Jest setup, no new libraries
- Architecture patterns: HIGH - Following existing ipfs.service.spec.ts pattern
- Coverage configuration: HIGH - Jest documentation is authoritative
- Mocking patterns: HIGH - Verified with existing codebase and NestJS docs

**Research date:** 2026-01-20
**Valid until:** 2026-02-20 (30 days - stable testing patterns)
