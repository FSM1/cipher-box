---
phase: 04.1-api-service-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/auth/auth.service.spec.ts
  - apps/api/src/auth/services/token.service.spec.ts
  - apps/api/src/auth/services/web3auth-verifier.service.spec.ts
  - apps/api/src/auth/strategies/jwt.strategy.spec.ts
autonomous: true

must_haves:
  truths:
    - 'AuthService.login creates new user on first login'
    - 'AuthService.login returns existing user on subsequent login'
    - 'AuthService.refreshByToken verifies argon2 hash and rotates token'
    - 'AuthService.linkMethod validates token and prevents duplicate linking'
    - 'AuthService.unlinkMethod prevents unlinking last auth method'
    - 'TokenService.createTokens generates JWT and stores hashed refresh token'
    - 'TokenService.rotateRefreshToken revokes old token and creates new one'
    - 'Web3AuthVerifierService.verifyIdToken validates JWT against JWKS'
    - 'JwtStrategy.validate returns user or throws UnauthorizedException'
  artifacts:
    - path: 'apps/api/src/auth/auth.service.spec.ts'
      provides: 'AuthService unit tests'
      min_lines: 200
    - path: 'apps/api/src/auth/services/token.service.spec.ts'
      provides: 'TokenService unit tests'
      min_lines: 100
    - path: 'apps/api/src/auth/services/web3auth-verifier.service.spec.ts'
      provides: 'Web3AuthVerifierService unit tests'
      min_lines: 100
    - path: 'apps/api/src/auth/strategies/jwt.strategy.spec.ts'
      provides: 'JwtStrategy unit tests'
      min_lines: 50
  key_links:
    - from: 'apps/api/src/auth/auth.service.spec.ts'
      to: 'apps/api/src/auth/auth.service.ts'
      via: 'imports and tests all methods'
      pattern: "describe\\('AuthService'"
    - from: 'apps/api/src/auth/services/token.service.spec.ts'
      to: 'apps/api/src/auth/services/token.service.ts'
      via: 'imports and tests all methods'
      pattern: "describe\\('TokenService'"
---

<objective>
Create comprehensive unit tests for all auth-related services to achieve 90% line coverage and 85% branch coverage.

Purpose: Establish test coverage for critical authentication logic including Web3Auth token verification, JWT handling, and token rotation per TESTING.md requirements.
Output: Four spec files testing AuthService (7 methods), TokenService (4 methods), Web3AuthVerifierService (3 methods), and JwtStrategy (1 method).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-api-service-testing/04.1-RESEARCH.md
@apps/api/src/ipfs/ipfs.service.spec.ts (existing test pattern)
@apps/api/src/auth/auth.service.ts
@apps/api/src/auth/services/token.service.ts
@apps/api/src/auth/services/web3auth-verifier.service.ts
@apps/api/src/auth/strategies/jwt.strategy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthService unit tests</name>
  <files>apps/api/src/auth/auth.service.spec.ts</files>
  <action>
Create comprehensive unit tests for AuthService following the pattern in ipfs.service.spec.ts.

**Setup:**

- Use `Test.createTestingModule` with mocked providers
- Mock dependencies: Web3AuthVerifierService, TokenService, User/AuthMethod/RefreshToken repositories
- Use `getRepositoryToken()` from `@nestjs/typeorm` for repository mocks
- Mock argon2 at module level: `jest.mock('argon2', () => ({ hash: jest.fn().mockResolvedValue('$argon2id$hash'), verify: jest.fn().mockResolvedValue(true) }))`
- Reset all mocks in `afterEach`

**Test cases for login() method:**

- Should create new user on first login (no existing user)
- Should return existing user on subsequent login
- Should update derivation version for external wallets
- Should create auth method if not exists
- Should update lastUsedAt on auth method
- Should throw if Web3Auth token verification fails

**Test cases for refresh() method:**

- Should call tokenService.rotateRefreshToken with correct params
- Should return new tokens

**Test cases for logout() method:**

- Should revoke all user tokens
- Should return success: true

**Test cases for refreshByToken() method:**

- Should find matching token by verifying argon2 hashes
- Should skip expired tokens
- Should throw UnauthorizedException if no valid token found
- Should revoke old token and create new tokens
- Should handle argon2.verify exceptions gracefully

**Test cases for getLinkedMethods() method:**

- Should return list of auth methods ordered by createdAt
- Should return empty array if no methods

**Test cases for linkMethod() method:**

- Should verify token and create new auth method
- Should throw BadRequestException if method already linked
- Should throw UnauthorizedException if user not found

**Test cases for unlinkMethod() method:**

- Should remove auth method
- Should throw BadRequestException if method not found
- Should throw BadRequestException if last auth method
  </action>
  <verify>Run `cd /Users/myankelev/Code/random/cipher-box/apps/api && npm test -- --testPathPattern=auth.service.spec.ts` - all tests pass</verify>
  <done>AuthService has 20+ test cases covering all 7 methods with happy paths and error cases</done>
  </task>

<task type="auto">
  <name>Task 2: Create TokenService and Web3AuthVerifierService unit tests</name>
  <files>
apps/api/src/auth/services/token.service.spec.ts
apps/api/src/auth/services/web3auth-verifier.service.spec.ts
  </files>
  <action>
**TokenService tests (apps/api/src/auth/services/token.service.spec.ts):**

Setup:

- Mock JwtService with `sign: jest.fn().mockReturnValue('mock-jwt')`
- Mock RefreshToken repository
- Mock argon2 at module level
- Mock crypto.randomBytes: `jest.spyOn(require('crypto'), 'randomBytes').mockReturnValue(Buffer.from('x'.repeat(32)))`

Test cases for createTokens():

- Should generate access token with correct payload (sub, publicKey, expiresIn)
- Should generate random refresh token and hash with argon2
- Should save hashed token to database with correct expiry (7 days)
- Should return both tokens

Test cases for rotateRefreshToken():

- Should find non-revoked tokens for user
- Should verify token against argon2 hashes
- Should throw UnauthorizedException if no match
- Should throw UnauthorizedException if token expired (and revoke it)
- Should revoke old token and create new tokens

Test cases for revokeAllUserTokens():

- Should update all non-revoked tokens for user with revokedAt

Test cases for revokeToken():

- Should update specific token with revokedAt

**Web3AuthVerifierService tests (apps/api/src/auth/services/web3auth-verifier.service.spec.ts):**

Setup:

- Mock jose module at top: `jest.mock('jose', () => ({ createRemoteJWKSet: jest.fn(() => jest.fn()), jwtVerify: jest.fn() }))`
- Import mocked jose after mock declaration

Test cases for verifyIdToken():

- Should verify social login token against social JWKS endpoint
- Should verify external wallet token against external JWKS endpoint
- Should throw UnauthorizedException on invalid JWT
- Should throw UnauthorizedException if no secp256k1 public key (social)
- Should throw UnauthorizedException if public key mismatch (social)
- Should throw UnauthorizedException if no ethereum address (external)
- Should throw UnauthorizedException if address mismatch (external, case-insensitive)

Test cases for extractIdentifier():

- Should return email if present
- Should return verifierId if no email
- Should return wallet address if no verifierId
- Should return public key as last resort
- Should throw UnauthorizedException if no identifier

Test cases for extractAuthMethodType():

- Should return 'external_wallet' for external_wallet loginType
- Should return 'google' if verifier contains 'google'
- Should return 'apple' if verifier contains 'apple'
- Should return 'github' if verifier contains 'github'
- Should return 'email_passwordless' if verifier contains 'email'
- Should return 'email_passwordless' as default if email present
  </action>
  <verify>Run `cd /Users/myankelev/Code/random/cipher-box/apps/api && npm test -- --testPathPattern="token.service.spec|web3auth-verifier.service.spec"` - all tests pass</verify>
  <done>TokenService has 10+ tests, Web3AuthVerifierService has 15+ tests covering all methods</done>
  </task>

<task type="auto">
  <name>Task 3: Create JwtStrategy unit tests</name>
  <files>apps/api/src/auth/strategies/jwt.strategy.spec.ts</files>
  <action>
Create unit tests for JwtStrategy following existing patterns.

**Setup:**

- Test that constructor throws if JWT_SECRET not configured (module compile should fail)
- Mock ConfigService to return JWT_SECRET
- Mock User repository

**Test cases for constructor:**

- Should throw Error if JWT_SECRET is not configured
- Should initialize successfully with valid JWT_SECRET

**Test cases for validate() method:**

- Should return user if found by payload.sub
- Should throw UnauthorizedException if user not found

**Note:** JwtStrategy extends PassportStrategy, so we test:

1. Configuration validation (constructor)
2. The validate() callback behavior

Use the pattern from research:

```typescript
it('should throw if JWT_SECRET is not configured', async () => {
  await expect(
    Test.createTestingModule({
      providers: [
        JwtStrategy,
        { provide: ConfigService, useValue: { get: jest.fn(() => undefined) } },
        { provide: getRepositoryToken(User), useValue: {} },
      ],
    }).compile()
  ).rejects.toThrow('JWT_SECRET environment variable is not set');
});
```

  </action>
  <verify>Run `cd /Users/myankelev/Code/random/cipher-box/apps/api && npm test -- --testPathPattern=jwt.strategy.spec.ts` - all tests pass</verify>
  <done>JwtStrategy has 4+ tests covering constructor validation and validate() method</done>
</task>

</tasks>

<verification>
1. All auth service tests pass: `cd apps/api && npm test -- --testPathPattern="auth|token|web3auth|jwt.strategy"`
2. Coverage check: `cd apps/api && npm test -- --coverage --testPathPattern="auth|token|web3auth|jwt.strategy"`
   - auth.service.ts: >= 90% lines, >= 85% branches
   - token.service.ts: >= 90% lines, >= 85% branches
   - web3auth-verifier.service.ts: >= 90% lines, >= 85% branches
   - jwt.strategy.ts: >= 90% lines, >= 85% branches
</verification>

<success_criteria>

- All 4 spec files created and passing
- Combined auth services coverage meets 90% line, 85% branch thresholds
- Tests follow existing ipfs.service.spec.ts pattern
- All mocks properly reset between tests
  </success_criteria>

<output>
After completion, create `.planning/phases/04.1-api-service-testing/04.1-01-SUMMARY.md`
</output>
