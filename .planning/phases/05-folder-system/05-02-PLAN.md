---
phase: 05-folder-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/ipns/create-record.ts
  - packages/crypto/src/ipns/derive-name.ts
  - packages/crypto/src/ipns/marshal.ts
  - packages/crypto/src/ipns/index.ts
  - packages/crypto/src/folder/types.ts
  - packages/crypto/src/folder/metadata.ts
  - packages/crypto/src/folder/index.ts
  - packages/crypto/src/index.ts
  - packages/crypto/package.json
  - packages/crypto/src/__tests__/ipns-record.test.ts
  - packages/crypto/src/__tests__/folder-metadata.test.ts
autonomous: true

must_haves:
  truths:
    - "Crypto module can create valid IPNS records from Ed25519 keys"
    - "IPNS records serialize to bytes compatible with delegated routing API"
    - "Folder metadata encrypts/decrypts correctly with AES-256-GCM"
    - "IPNS name derived correctly from Ed25519 public key (k51... format)"
  artifacts:
    - path: "packages/crypto/src/ipns/create-record.ts"
      provides: "createIpnsRecord function using ipns npm package"
      exports: ["createIpnsRecord"]
    - path: "packages/crypto/src/ipns/derive-name.ts"
      provides: "deriveIpnsName from Ed25519 public key"
      exports: ["deriveIpnsName"]
    - path: "packages/crypto/src/ipns/marshal.ts"
      provides: "marshalIpnsRecord, unmarshalIpnsRecord helpers"
      exports: ["marshalIpnsRecord", "unmarshalIpnsRecord"]
    - path: "packages/crypto/src/folder/types.ts"
      provides: "FolderMetadata, FolderEntry, FileEntry types"
    - path: "packages/crypto/src/folder/metadata.ts"
      provides: "encryptFolderMetadata, decryptFolderMetadata"
      exports: ["encryptFolderMetadata", "decryptFolderMetadata"]
  key_links:
    - from: "packages/crypto/src/ipns/create-record.ts"
      to: "ipns npm package"
      via: "import createIPNSRecord"
      pattern: "import.*createIPNSRecord.*from.*ipns"
    - from: "packages/crypto/src/ipns/derive-name.ts"
      to: "@libp2p/peer-id"
      via: "peerIdFromKeys"
      pattern: "peerIdFromKeys"
    - from: "packages/crypto/src/folder/metadata.ts"
      to: "packages/crypto/src/aes"
      via: "import encryptAesGcm, decryptAesGcm"
      pattern: "import.*encryptAesGcm.*decryptAesGcm"
---

<objective>
Extend the @cipherbox/crypto package to support IPNS record creation using the ipns npm package and folder metadata encryption. This provides the cryptographic primitives needed for folder operations on the frontend.

Purpose: Bridge existing @noble/ed25519 keys to libp2p format for IPNS record creation. Enable encrypted folder metadata storage.
Output: IPNS record creation functions, folder metadata encryption, comprehensive tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-folder-system/05-RESEARCH.md
@packages/crypto/src/ipns/sign-record.ts
@packages/crypto/src/ed25519/keygen.ts
@packages/crypto/src/aes/encrypt.ts
@packages/crypto/src/aes/decrypt.ts
@packages/crypto/src/types.ts
@packages/crypto/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPNS dependencies and create record functions</name>
  <files>
    packages/crypto/package.json
    packages/crypto/src/ipns/create-record.ts
    packages/crypto/src/ipns/derive-name.ts
    packages/crypto/src/ipns/marshal.ts
    packages/crypto/src/ipns/index.ts
  </files>
  <action>
**Add dependencies to packages/crypto/package.json:**
```bash
pnpm add ipns @libp2p/crypto @libp2p/peer-id multiformats
```

**create-record.ts:**
Create `createIpnsRecord(ed25519PrivateKey: Uint8Array, value: string, sequenceNumber: bigint, lifetimeMs?: number)`:
1. Convert raw 32-byte Ed25519 private key to libp2p PrivateKey format:
   - Ed25519 private key in libp2p format is protobuf-encoded
   - Use `@libp2p/crypto/keys` generateKeyPairFromSeed or unmarshalPrivateKey
   - The 32-byte seed/private key needs to be expanded to include public key
   - @noble/ed25519 getPublicKey(privateKey) gets the 32-byte public key
   - Concatenate: [privateKey (32 bytes) + publicKey (32 bytes)] = 64 bytes for Ed25519
   - Then marshal using libp2p protobuf format
2. Call `createIPNSRecord` from `ipns` package with:
   - privateKey (libp2p format)
   - value (string, e.g., "/ipfs/bafy...")
   - sequenceNumber (bigint)
   - lifetime (default: 24 * 60 * 60 * 1000 = 24 hours)
3. Return the IPNSRecord object

**derive-name.ts:**
Create `deriveIpnsName(ed25519PublicKey: Uint8Array): Promise<string>`:
1. Marshal public key to libp2p format (protobuf with key type prefix)
2. Use `peerIdFromPublicKey` from `@libp2p/peer-id`
3. Return `peerId.toCID().toString()` (k51... format)

**marshal.ts:**
- `marshalIpnsRecord(record: IPNSRecord): Uint8Array` - wrapper around ipns.marshalIPNSRecord
- `unmarshalIpnsRecord(bytes: Uint8Array): IPNSRecord` - wrapper around ipns.unmarshalIPNSRecord
- Export types: `IPNSRecord` from ipns package

**index.ts:**
Update to export:
- `createIpnsRecord`
- `deriveIpnsName`
- `marshalIpnsRecord`
- `unmarshalIpnsRecord`
- Keep existing `signIpnsData`, `IPNS_SIGNATURE_PREFIX`
  </action>
  <verify>
`pnpm build` in packages/crypto succeeds. `pnpm exec tsc --noEmit` passes.
  </verify>
  <done>
IPNS record creation functions exist using ipns npm package. Ed25519 key conversion from @noble to libp2p format works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create folder metadata types and encryption</name>
  <files>
    packages/crypto/src/folder/types.ts
    packages/crypto/src/folder/metadata.ts
    packages/crypto/src/folder/index.ts
    packages/crypto/src/index.ts
  </files>
  <action>
**types.ts:**
```typescript
/** Decrypted folder metadata (before encryption) */
export type FolderMetadata = {
  version: 'v1';
  children: FolderChild[];
};

export type FolderChild = FolderEntry | FileEntry;

export type FolderEntry = {
  type: 'folder';
  id: string;                       // UUID for internal reference
  name: string;                     // Plaintext (whole metadata is encrypted)
  ipnsName: string;                 // k51... IPNS name
  ipnsPrivateKeyEncrypted: string;  // Hex ECIES-wrapped Ed25519 private key
  folderKeyEncrypted: string;       // Hex ECIES-wrapped AES-256 key
  createdAt: number;                // Unix timestamp ms
  modifiedAt: number;
};

export type FileEntry = {
  type: 'file';
  id: string;                       // UUID for internal reference
  name: string;
  cid: string;                      // IPFS CID of encrypted file
  fileKeyEncrypted: string;         // Hex ECIES-wrapped AES-256 key
  fileIv: string;                   // Hex IV used for encryption
  encryptionMode: 'GCM';            // Always GCM for v1.0
  size: number;                     // Original file size in bytes
  createdAt: number;
  modifiedAt: number;
};

/** Encrypted folder metadata for storage */
export type EncryptedFolderMetadata = {
  iv: string;                       // Hex-encoded
  data: string;                     // Base64-encoded AES-GCM ciphertext
};
```

**metadata.ts:**
```typescript
import { encryptAesGcm, decryptAesGcm } from '../aes';
import { generateIv, bytesToHex, hexToBytes } from '../utils';
import type { FolderMetadata, EncryptedFolderMetadata } from './types';

export async function encryptFolderMetadata(
  metadata: FolderMetadata,
  folderKey: Uint8Array
): Promise<EncryptedFolderMetadata> {
  const iv = generateIv();
  const plaintext = new TextEncoder().encode(JSON.stringify(metadata));
  const ciphertext = await encryptAesGcm(plaintext, folderKey, iv);

  return {
    iv: bytesToHex(iv),
    data: btoa(String.fromCharCode(...ciphertext)),
  };
}

export async function decryptFolderMetadata(
  encrypted: EncryptedFolderMetadata,
  folderKey: Uint8Array
): Promise<FolderMetadata> {
  const iv = hexToBytes(encrypted.iv);
  const ciphertext = Uint8Array.from(atob(encrypted.data), c => c.charCodeAt(0));
  const plaintext = await decryptAesGcm(ciphertext, folderKey, iv);
  return JSON.parse(new TextDecoder().decode(plaintext)) as FolderMetadata;
}
```

**folder/index.ts:**
Export all types and functions.

**packages/crypto/src/index.ts:**
Add exports for folder module:
```typescript
// Folder
export * from './folder';
```
  </action>
  <verify>
`pnpm build` in packages/crypto succeeds. Types are exported correctly from package index.
  </verify>
  <done>
FolderMetadata types defined. Encryption/decryption functions work with existing AES-GCM primitives.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for IPNS record and folder metadata</name>
  <files>
    packages/crypto/src/__tests__/ipns-record.test.ts
    packages/crypto/src/__tests__/folder-metadata.test.ts
  </files>
  <action>
**ipns-record.test.ts:**
Test cases:
1. createIpnsRecord creates valid record with correct value
2. createIpnsRecord respects sequence number
3. createIpnsRecord uses default 24h lifetime
4. createIpnsRecord accepts custom lifetime
5. deriveIpnsName returns k51... format string
6. deriveIpnsName is deterministic (same key = same name)
7. marshalIpnsRecord produces Uint8Array
8. unmarshalIpnsRecord round-trips correctly
9. Created record can be verified (value matches, seq matches)

**folder-metadata.test.ts:**
Test cases:
1. encryptFolderMetadata produces valid encrypted structure
2. decryptFolderMetadata recovers original metadata
3. Round-trip preserves all folder entry fields
4. Round-trip preserves all file entry fields
5. Empty children array works correctly
6. Multiple children (mixed files/folders) round-trip correctly
7. Different folder keys produce different ciphertext
8. Wrong key fails decryption with error
9. Corrupted ciphertext fails decryption

Run tests with: `pnpm test` in packages/crypto
  </action>
  <verify>
`pnpm test` in packages/crypto passes. All new tests pass. Coverage remains high.
  </verify>
  <done>
Comprehensive tests for IPNS record creation and folder metadata encryption. Tests verify compatibility with IPFS network expectations.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes in packages/crypto
2. `pnpm test` passes with all new tests
3. `pnpm exec tsc --noEmit` passes in packages/crypto
4. New dependencies installed (ipns, @libp2p/crypto, @libp2p/peer-id, multiformats)
5. IPNS name derivation produces k51... format strings
6. Folder metadata round-trips through encryption/decryption
</verification>

<success_criteria>
- createIpnsRecord produces records compatible with delegated routing API
- deriveIpnsName converts Ed25519 public keys to k51... IPNS names
- marshalIpnsRecord/unmarshalIpnsRecord work with ipns package
- FolderMetadata types match RESEARCH.md specification
- encryptFolderMetadata/decryptFolderMetadata work with folder keys
- All tests pass with good coverage
</success_criteria>

<output>
After completion, create `.planning/phases/05-folder-system/05-02-SUMMARY.md`
</output>
