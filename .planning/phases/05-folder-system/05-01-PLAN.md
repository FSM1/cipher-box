---
phase: 05-folder-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/ipns/ipns.module.ts
  - apps/api/src/ipns/ipns.controller.ts
  - apps/api/src/ipns/ipns.service.ts
  - apps/api/src/ipns/dto/publish.dto.ts
  - apps/api/src/ipns/dto/index.ts
  - apps/api/src/ipns/entities/folder-ipns.entity.ts
  - apps/api/src/ipns/entities/index.ts
  - apps/api/src/app.module.ts
  - apps/api/scripts/generate-openapi.ts
autonomous: true

must_haves:
  truths:
    - "Backend accepts pre-signed IPNS records via POST /ipns/publish"
    - "Backend relays records to delegated-ipfs.dev routing API"
    - "Backend tracks all folder IPNS names and latest CIDs in database"
    - "Backend enforces authentication on IPNS endpoints"
  artifacts:
    - path: "apps/api/src/ipns/ipns.module.ts"
      provides: "NestJS IPNS module with controller and service"
    - path: "apps/api/src/ipns/ipns.controller.ts"
      provides: "POST /ipns/publish endpoint"
      exports: ["IpnsController"]
    - path: "apps/api/src/ipns/ipns.service.ts"
      provides: "Delegated routing client and folder tracking"
      exports: ["IpnsService"]
    - path: "apps/api/src/ipns/entities/folder-ipns.entity.ts"
      provides: "FolderIpns entity for tracking IPNS names/CIDs"
  key_links:
    - from: "apps/api/src/ipns/ipns.controller.ts"
      to: "apps/api/src/ipns/ipns.service.ts"
      via: "dependency injection"
      pattern: "constructor.*IpnsService"
    - from: "apps/api/src/ipns/ipns.service.ts"
      to: "https://delegated-ipfs.dev/routing/v1/ipns"
      via: "fetch PUT request"
      pattern: "fetch.*delegated-ipfs.dev.*routing/v1/ipns"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/ipns/ipns.module.ts"
      via: "module import"
      pattern: "IpnsModule"
---

<objective>
Create backend IPNS module that accepts pre-signed IPNS records from clients and relays them to the IPFS network via the Delegated Routing HTTP API. Track all folder IPNS names and CIDs in the database for TEE republishing.

Purpose: Enable folder metadata publishing without requiring the backend to hold private keys (zero-knowledge). Backend tracks all folders for future TEE auto-republishing.
Output: IpnsModule with publish endpoint, FolderIpns entity, integration with delegated-ipfs.dev
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-folder-system/05-CONTEXT.md
@.planning/phases/05-folder-system/05-RESEARCH.md
@apps/api/src/vault/vault.entity.ts
@apps/api/src/ipfs/ipfs.module.ts
@apps/api/src/app.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FolderIpns entity and DTOs</name>
  <files>
    apps/api/src/ipns/entities/folder-ipns.entity.ts
    apps/api/src/ipns/entities/index.ts
    apps/api/src/ipns/dto/publish.dto.ts
    apps/api/src/ipns/dto/index.ts
  </files>
  <action>
Create the FolderIpns entity to track folder IPNS names and latest metadata CIDs:

**FolderIpns entity fields:**
- `id` (uuid, primary key)
- `userId` (uuid, foreign key to User, indexed)
- `ipnsName` (varchar 255, unique per user - the k51... IPNS name)
- `latestCid` (varchar 255, nullable - CID of latest encrypted metadata)
- `sequenceNumber` (bigint, default 0 - for IPNS record ordering)
- `encryptedIpnsPrivateKey` (bytea - ECIES-wrapped Ed25519 key for TEE)
- `keyEpoch` (integer - TEE epoch the key was encrypted for)
- `isRoot` (boolean, default false - marks root folder)
- `createdAt`, `updatedAt` timestamps

Add unique constraint on (userId, ipnsName).

**PublishIpnsDto fields:**
- `ipnsName` (string, required) - k51... IPNS name
- `record` (string, required) - Base64-encoded marshaled IPNS record
- `metadataCid` (string, required) - CID the record points to
- `encryptedIpnsPrivateKey` (string, optional) - Hex-encoded ECIES-wrapped key (only on first publish for this folder)
- `keyEpoch` (number, optional) - TEE epoch (only with encryptedIpnsPrivateKey)

**PublishIpnsResponseDto:**
- `success` (boolean)
- `ipnsName` (string)
- `sequenceNumber` (string - bigint as string)
  </action>
  <verify>
`pnpm exec tsc --noEmit` in apps/api passes with no errors. Entity has all required fields and relationships.
  </verify>
  <done>
FolderIpns entity exists with proper TypeORM decorators. DTOs have class-validator decorators for validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IpnsService with delegated routing</name>
  <files>
    apps/api/src/ipns/ipns.service.ts
  </files>
  <action>
Create IpnsService that:

1. **publishRecord(userId, dto)** method:
   - Validate record is valid base64
   - Decode to Uint8Array
   - PUT to `https://delegated-ipfs.dev/routing/v1/ipns/${ipnsName}` with:
     - Content-Type: `application/vnd.ipfs.ipns-record`
     - Body: raw record bytes
   - On success (2xx): update/create FolderIpns entry
   - On failure: throw appropriate HttpException
   - Return sequence number

2. **upsertFolderIpns(userId, ipnsName, metadataCid, encryptedKey?, keyEpoch?)** private method:
   - Find existing by (userId, ipnsName)
   - If exists: increment sequenceNumber, update latestCid
   - If not exists: create new with sequenceNumber 0
   - If encryptedIpnsPrivateKey provided: store it (only on first publish)
   - Return the entity

3. **getFolderIpns(userId, ipnsName)** method:
   - Return FolderIpns or null

4. **getAllFolderIpns(userId)** method:
   - Return all FolderIpns for user (needed for TEE republishing)

Use ConfigService to get optional DELEGATED_ROUTING_URL env var (default: https://delegated-ipfs.dev).

Handle rate limits with retry (exponential backoff, max 3 retries).
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. Service has all methods with proper dependency injection.
  </verify>
  <done>
IpnsService connects to delegated routing API, tracks folders in database, handles retries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create IpnsController and IpnsModule</name>
  <files>
    apps/api/src/ipns/ipns.controller.ts
    apps/api/src/ipns/ipns.module.ts
    apps/api/src/app.module.ts
    apps/api/scripts/generate-openapi.ts
  </files>
  <action>
**IpnsController:**
- Add `@Controller('ipns')` and `@ApiTags('IPNS')` decorators
- `@Post('publish')` endpoint with `@UseGuards(JwtAuthGuard)`:
  - Extract userId from request (use @Req() and JwtPayload pattern from VaultController)
  - Call ipnsService.publishRecord(userId, dto)
  - Return PublishIpnsResponseDto
  - Add Swagger decorators: @ApiOperation, @ApiResponse for 200, 401, 400, 502

**IpnsModule:**
- Import ConfigModule, TypeOrmModule.forFeature([FolderIpns])
- Providers: [IpnsService]
- Controllers: [IpnsController]
- Exports: [IpnsService] (needed for future VaultModule integration)

**app.module.ts:**
- Add IpnsModule to imports
- Add FolderIpns to TypeORM entities array

**generate-openapi.ts:**
- Add IpnsController and IpnsService to the minimal module

Run `pnpm api:generate` to regenerate OpenAPI spec and API client.
  </action>
  <verify>
`pnpm api:generate` completes without errors. `pnpm exec tsc --noEmit` passes in both apps/api and apps/web.
  </verify>
  <done>
IpnsModule registered in app, OpenAPI spec includes /ipns/publish endpoint, API client regenerated.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes in apps/api
2. `pnpm api:generate` completes successfully
3. `pnpm exec tsc --noEmit` passes in apps/web (client types valid)
4. OpenAPI spec at packages/api-client/openapi.json includes /ipns/publish endpoint
5. FolderIpns entity has unique constraint on (userId, ipnsName)
</verification>

<success_criteria>
- POST /ipns/publish endpoint accepts pre-signed IPNS records
- Backend relays records to delegated-ipfs.dev with correct content-type
- FolderIpns entity tracks all folder IPNS names, CIDs, sequence numbers
- Encrypted IPNS private keys stored for TEE republishing
- API client regenerated with typed publish method
</success_criteria>

<output>
After completion, create `.planning/phases/05-folder-system/05-01-SUMMARY.md`
</output>
