---
phase: 05-folder-system
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - apps/web/src/stores/folder.store.ts
  - apps/web/src/stores/vault.store.ts
  - apps/web/src/services/folder.service.ts
  - apps/web/src/services/ipns.service.ts
  - apps/web/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can create IPNS records locally using crypto module"
    - "Frontend can publish IPNS records via backend relay"
    - "Frontend maintains folder tree state in memory"
    - "Folder keys decrypt correctly to reveal folder contents"
  artifacts:
    - path: "apps/web/src/stores/folder.store.ts"
      provides: "Zustand store for folder tree state management"
      exports: ["useFolderStore"]
    - path: "apps/web/src/stores/vault.store.ts"
      provides: "Vault state with root folder key and IPNS keypair"
      exports: ["useVaultStore"]
    - path: "apps/web/src/services/ipns.service.ts"
      provides: "IPNS record creation and publishing"
      exports: ["createAndPublishIpnsRecord", "resolveIpnsRecord"]
    - path: "apps/web/src/services/folder.service.ts"
      provides: "Folder CRUD operations with encryption"
      exports: ["loadFolder", "createFolder", "updateFolderMetadata"]
  key_links:
    - from: "apps/web/src/services/ipns.service.ts"
      to: "@cipherbox/crypto"
      via: "createIpnsRecord, marshalIpnsRecord"
      pattern: "import.*createIpnsRecord.*marshalIpnsRecord.*from.*@cipherbox/crypto"
    - from: "apps/web/src/services/ipns.service.ts"
      to: "apps/api/src/ipns/ipns.controller.ts"
      via: "POST /ipns/publish API call"
      pattern: "postIpnsPublish|fetch.*ipns/publish"
    - from: "apps/web/src/services/folder.service.ts"
      to: "apps/web/src/stores/folder.store.ts"
      via: "useFolderStore actions"
      pattern: "useFolderStore"
    - from: "apps/web/src/stores/folder.store.ts"
      to: "apps/web/src/stores/vault.store.ts"
      via: "root folder key access"
      pattern: "useVaultStore"
---

<objective>
Create frontend folder state management and IPNS publishing services. This bridges the crypto module to the backend API and provides the foundation for folder operations UI.

Purpose: Enable the frontend to create, encrypt, and publish folder metadata. Manage folder tree state for navigation and operations.
Output: Zustand stores for folder/vault state, services for IPNS publishing and folder operations
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-folder-system/05-CONTEXT.md
@.planning/phases/05-folder-system/05-RESEARCH.md
@apps/web/src/stores/auth.store.ts
@apps/web/src/stores/upload.store.ts
@packages/crypto/src/folder/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vault store for key management</name>
  <files>
    apps/web/src/stores/vault.store.ts
  </files>
  <action>
Create useVaultStore Zustand store for managing decrypted vault keys in memory:

**State:**
```typescript
type VaultState = {
  // Decrypted vault keys (memory-only)
  rootFolderKey: Uint8Array | null;
  rootIpnsKeypair: { publicKey: Uint8Array; privateKey: Uint8Array } | null;
  rootIpnsName: string | null;

  // Vault metadata from server
  vaultId: string | null;
  isInitialized: boolean;

  // Actions
  setVaultKeys: (keys: {
    rootFolderKey: Uint8Array;
    rootIpnsKeypair: { publicKey: Uint8Array; privateKey: Uint8Array };
    rootIpnsName: string;
    vaultId: string;
  }) => void;
  clearVaultKeys: () => void;
};
```

**Implementation notes:**
- On clearVaultKeys, zero-fill all Uint8Arrays before setting to null (same pattern as auth.store.ts)
- Keys are set after vault initialization/retrieval (called from login flow)
- rootIpnsName is derived from rootIpnsKeypair.publicKey using deriveIpnsName
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes in apps/web. Store exports correctly.
  </verify>
  <done>
VaultStore exists with rootFolderKey, rootIpnsKeypair, rootIpnsName. Memory clearing on logout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IPNS service for record publishing</name>
  <files>
    apps/web/src/services/ipns.service.ts
    apps/web/src/services/index.ts
  </files>
  <action>
Create ipns.service.ts with functions for IPNS record creation and publishing:

**createAndPublishIpnsRecord:**
```typescript
export async function createAndPublishIpnsRecord(params: {
  ipnsPrivateKey: Uint8Array;
  ipnsName: string;
  metadataCid: string;
  sequenceNumber: bigint;
  encryptedIpnsPrivateKey?: string;  // Hex, only on first publish
  keyEpoch?: number;
}): Promise<{ success: boolean; sequenceNumber: bigint }> {
  // 1. Create IPNS record pointing to /ipfs/{metadataCid}
  const record = await createIpnsRecord(
    params.ipnsPrivateKey,
    `/ipfs/${params.metadataCid}`,
    params.sequenceNumber,
    24 * 60 * 60 * 1000  // 24 hour lifetime
  );

  // 2. Marshal to bytes
  const recordBytes = marshalIpnsRecord(record);

  // 3. Base64 encode for API
  const recordBase64 = btoa(String.fromCharCode(...recordBytes));

  // 4. Call backend API
  const response = await postIpnsPublish({
    ipnsName: params.ipnsName,
    record: recordBase64,
    metadataCid: params.metadataCid,
    encryptedIpnsPrivateKey: params.encryptedIpnsPrivateKey,
    keyEpoch: params.keyEpoch,
  });

  return {
    success: response.success,
    sequenceNumber: BigInt(response.sequenceNumber),
  };
}
```

**resolveIpnsRecord (for future sync):**
```typescript
export async function resolveIpnsRecord(ipnsName: string): Promise<{
  cid: string;
  sequenceNumber: bigint;
} | null> {
  // For now, resolve via Pinata gateway or direct IPFS gateway
  // This will be expanded in Phase 7 (Multi-Device Sync)
  // Stub that returns null - actual implementation deferred
  return null;
}
```

**services/index.ts:**
Create barrel export for services:
```typescript
export * from './ipns.service';
```

Import from @cipherbox/crypto: createIpnsRecord, marshalIpnsRecord
Import from generated API client: postIpnsPublish (or equivalent from orval)
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes in apps/web. Service functions type-check correctly.
  </verify>
  <done>
IPNS service creates records locally and publishes via backend. Uses crypto module and generated API client.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create folder store and service</name>
  <files>
    apps/web/src/stores/folder.store.ts
    apps/web/src/services/folder.service.ts
    apps/web/src/services/index.ts
  </files>
  <action>
**folder.store.ts:**
Zustand store for folder tree state:

```typescript
type FolderNode = {
  id: string;
  name: string;
  ipnsName: string;
  parentId: string | null;  // null for root
  children: FolderChild[];  // Decrypted from metadata
  isLoaded: boolean;        // Has metadata been fetched?
  isLoading: boolean;
  sequenceNumber: bigint;
  folderKey: Uint8Array;    // Decrypted folder key
  ipnsPrivateKey: Uint8Array; // Decrypted IPNS private key
};

type FolderState = {
  // Folder tree indexed by id
  folders: Record<string, FolderNode>;

  // Current navigation
  currentFolderId: string | null;  // null = root
  breadcrumbs: Array<{ id: string; name: string }>;

  // Publishing state
  pendingPublishes: Set<string>;  // folder IDs with pending IPNS publishes

  // Actions
  setFolder: (folder: FolderNode) => void;
  updateFolderChildren: (folderId: string, children: FolderChild[]) => void;
  setCurrentFolder: (folderId: string | null) => void;
  addPendingPublish: (folderId: string) => void;
  removePendingPublish: (folderId: string) => void;
  clearFolders: () => void;
};
```

**folder.service.ts:**
Functions for folder operations:

**loadFolder:**
```typescript
export async function loadFolder(
  folderId: string | null,  // null = root
  folderKey: Uint8Array,
  ipnsPrivateKey: Uint8Array,
  ipnsName: string
): Promise<FolderNode> {
  // 1. Resolve IPNS to get current metadata CID (or use cached)
  // 2. Fetch encrypted metadata from IPFS gateway
  // 3. Decrypt with folderKey
  // 4. Return FolderNode with decrypted children

  // For now, return empty folder (metadata fetch deferred to 05-04)
  return {
    id: folderId ?? 'root',
    name: folderId ? 'Folder' : 'My Vault',
    ipnsName,
    parentId: null,
    children: [],
    isLoaded: true,
    isLoading: false,
    sequenceNumber: 0n,
    folderKey,
    ipnsPrivateKey,
  };
}
```

**createFolder:**
```typescript
export async function createFolder(params: {
  parentFolderId: string | null;
  name: string;
  userPublicKey: Uint8Array;  // For ECIES wrapping
}): Promise<{ folder: FolderEntry; ipnsPrivateKey: Uint8Array; folderKey: Uint8Array }> {
  // 1. Generate Ed25519 keypair for folder IPNS
  const ipnsKeypair = await generateEd25519Keypair();
  const ipnsName = await deriveIpnsName(ipnsKeypair.publicKey);

  // 2. Generate random AES-256 folder key
  const folderKey = generateRandomBytes(32);

  // 3. Wrap keys with user's public key
  const ipnsPrivateKeyEncrypted = bytesToHex(await wrapKey(ipnsKeypair.privateKey, params.userPublicKey));
  const folderKeyEncrypted = bytesToHex(await wrapKey(folderKey, params.userPublicKey));

  // 4. Create folder entry
  const folder: FolderEntry = {
    type: 'folder',
    id: crypto.randomUUID(),
    name: params.name,
    ipnsName,
    ipnsPrivateKeyEncrypted,
    folderKeyEncrypted,
    createdAt: Date.now(),
    modifiedAt: Date.now(),
  };

  return { folder, ipnsPrivateKey: ipnsKeypair.privateKey, folderKey };
}
```

**updateFolderMetadata:**
```typescript
export async function updateFolderMetadata(params: {
  folderId: string;
  children: FolderChild[];
  folderKey: Uint8Array;
  ipnsPrivateKey: Uint8Array;
  ipnsName: string;
  sequenceNumber: bigint;
  encryptedIpnsPrivateKey?: string;  // Only for new folders
  keyEpoch?: number;
}): Promise<{ cid: string; newSequenceNumber: bigint }> {
  // 1. Create folder metadata
  const metadata: FolderMetadata = {
    version: 'v1',
    children: params.children,
  };

  // 2. Encrypt metadata
  const encrypted = await encryptFolderMetadata(metadata, params.folderKey);

  // 3. Upload to IPFS (via backend)
  const blob = new Blob([JSON.stringify(encrypted)], { type: 'application/json' });
  const { cid } = await postIpfsAdd(blob);  // Use existing IPFS upload endpoint

  // 4. Publish IPNS record
  const newSeq = params.sequenceNumber + 1n;
  await createAndPublishIpnsRecord({
    ipnsPrivateKey: params.ipnsPrivateKey,
    ipnsName: params.ipnsName,
    metadataCid: cid,
    sequenceNumber: newSeq,
    encryptedIpnsPrivateKey: params.encryptedIpnsPrivateKey,
    keyEpoch: params.keyEpoch,
  });

  return { cid, newSequenceNumber: newSeq };
}
```

Update services/index.ts to export folder.service.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes in apps/web. All service functions type-check with crypto module types.
  </verify>
  <done>
FolderStore manages folder tree state. FolderService provides createFolder, loadFolder, updateFolderMetadata operations.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes in apps/web
2. VaultStore properly clears keys on logout (memory zeroing)
3. FolderStore tracks folder tree with proper state management
4. IPNS service integrates with crypto module and API client
5. Folder service uses ECIES wrapping for key storage
6. All imports from @cipherbox/crypto resolve correctly
</verification>

<success_criteria>
- VaultStore holds decrypted root folder key and IPNS keypair
- FolderStore manages folder tree with navigation state
- IPNS service creates and publishes records via backend
- Folder service creates folders with proper key wrapping
- All state is memory-only (cleared on logout)
- Types align with @cipherbox/crypto folder types
</success_criteria>

<output>
After completion, create `.planning/phases/05-folder-system/05-03-SUMMARY.md`
</output>
