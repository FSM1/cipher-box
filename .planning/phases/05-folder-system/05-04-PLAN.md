---
phase: 05-folder-system
plan: 04
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - apps/web/src/services/folder.service.ts
  - apps/web/src/stores/folder.store.ts
  - apps/web/src/hooks/useFolder.ts
  - apps/web/src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "User can create folders and they persist across sessions"
    - "User can delete folders and all contents are recursively removed"
    - "User can nest folders up to 20 levels deep"
    - "User can rename files and folders"
    - "User can move files and folders between parent folders"
  artifacts:
    - path: "apps/web/src/services/folder.service.ts"
      provides: "Complete folder CRUD operations"
      exports: ["createFolder", "deleteFolder", "renameFolder", "moveFolder", "renameFile", "moveFile"]
    - path: "apps/web/src/hooks/useFolder.ts"
      provides: "React hook for folder operations with UI state"
      exports: ["useFolder"]
  key_links:
    - from: "apps/web/src/hooks/useFolder.ts"
      to: "apps/web/src/stores/folder.store.ts"
      via: "useFolderStore"
      pattern: "useFolderStore"
    - from: "apps/web/src/services/folder.service.ts"
      to: "apps/web/src/services/ipns.service.ts"
      via: "createAndPublishIpnsRecord"
      pattern: "createAndPublishIpnsRecord"
    - from: "apps/web/src/services/folder.service.ts"
      to: "@cipherbox/crypto"
      via: "encryptFolderMetadata, decryptFolderMetadata"
      pattern: "import.*encryptFolderMetadata.*decryptFolderMetadata"
---

<objective>
Implement complete folder CRUD operations including create, delete (recursive), rename, and move for both files and folders. Enforce depth limit and handle IPNS publishing with proper error handling.

Purpose: Deliver all folder operation requirements (FOLD-01 through FOLD-05, FILE-04, FILE-05). Enable users to organize files in encrypted folder hierarchy.
Output: Complete folder operations with React hooks for UI integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-folder-system/05-CONTEXT.md
@.planning/phases/05-folder-system/05-RESEARCH.md
@.planning/phases/05-folder-system/05-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement folder rename and delete operations</name>
  <files>
    apps/web/src/services/folder.service.ts
    apps/web/src/stores/folder.store.ts
  </files>
  <action>
**Add to folder.service.ts:**

**renameFolder:**
```typescript
export async function renameFolder(params: {
  folderId: string;
  newName: string;
  parentFolderState: FolderNode;  // Parent folder containing this folder
}): Promise<void> {
  // 1. Find folder entry in parent's children
  const children = [...params.parentFolderState.children];
  const folderIndex = children.findIndex(
    c => c.type === 'folder' && c.id === params.folderId
  );

  if (folderIndex === -1) throw new Error('Folder not found');

  // 2. Check for name collision
  const nameExists = children.some(
    c => c.name === params.newName && c.id !== params.folderId
  );
  if (nameExists) throw new Error('An item with this name already exists');

  // 3. Update name and modifiedAt
  const folder = children[folderIndex] as FolderEntry;
  children[folderIndex] = {
    ...folder,
    name: params.newName,
    modifiedAt: Date.now(),
  };

  // 4. Update parent folder metadata and publish
  await updateFolderMetadata({
    folderId: params.parentFolderState.id,
    children,
    folderKey: params.parentFolderState.folderKey,
    ipnsPrivateKey: params.parentFolderState.ipnsPrivateKey,
    ipnsName: params.parentFolderState.ipnsName,
    sequenceNumber: params.parentFolderState.sequenceNumber,
  });
}
```

**deleteFolder (recursive):**
```typescript
export async function deleteFolder(params: {
  folderId: string;
  parentFolderState: FolderNode;
  getFolderState: (id: string) => FolderNode | undefined;
  unpinCid: (cid: string) => Promise<void>;
}): Promise<void> {
  // 1. Find folder in parent's children
  const children = [...params.parentFolderState.children];
  const folderIndex = children.findIndex(
    c => c.type === 'folder' && c.id === params.folderId
  );

  if (folderIndex === -1) throw new Error('Folder not found');

  // 2. Recursively collect all CIDs to unpin (files in this folder and subfolders)
  const cidsToUnpin: string[] = [];
  const collectCids = async (folderId: string) => {
    const folder = params.getFolderState(folderId);
    if (!folder) return;

    for (const child of folder.children) {
      if (child.type === 'file') {
        cidsToUnpin.push(child.cid);
      } else if (child.type === 'folder') {
        await collectCids(child.id);
      }
    }
  };

  await collectCids(params.folderId);

  // 3. Remove folder from parent's children
  children.splice(folderIndex, 1);

  // 4. Update parent folder metadata and publish
  await updateFolderMetadata({
    folderId: params.parentFolderState.id,
    children,
    folderKey: params.parentFolderState.folderKey,
    ipnsPrivateKey: params.parentFolderState.ipnsPrivateKey,
    ipnsName: params.parentFolderState.ipnsName,
    sequenceNumber: params.parentFolderState.sequenceNumber,
  });

  // 5. Unpin all collected CIDs (fire and forget, don't block)
  Promise.all(cidsToUnpin.map(cid => params.unpinCid(cid).catch(() => {})));
}
```

**Add to folder.store.ts:**
- `removeFolder(folderId: string)` action to remove folder from local state
- `updateFolderName(folderId: string, newName: string)` action
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. Functions handle edge cases (not found, name collision).
  </verify>
  <done>
renameFolder updates parent metadata with new name. deleteFolder recursively collects CIDs and unpins.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement move operations for files and folders</name>
  <files>
    apps/web/src/services/folder.service.ts
  </files>
  <action>
**Add to folder.service.ts:**

**moveFolder:**
```typescript
export async function moveFolder(params: {
  folderId: string;
  sourceFolderState: FolderNode;
  destFolderState: FolderNode;
  getDepth: (folderId: string) => number;  // Returns depth from root
}): Promise<void> {
  // 1. Find folder in source
  const folder = params.sourceFolderState.children.find(
    c => c.type === 'folder' && c.id === params.folderId
  ) as FolderEntry | undefined;

  if (!folder) throw new Error('Folder not found');

  // 2. Check name collision in destination
  const nameExists = params.destFolderState.children.some(
    c => c.name === folder.name
  );
  if (nameExists) throw new Error('An item with this name already exists in destination');

  // 3. Check depth limit (20 levels max)
  const destDepth = params.getDepth(params.destFolderState.id);
  const folderSubtreeDepth = calculateSubtreeDepth(params.folderId, /* ... */);
  if (destDepth + 1 + folderSubtreeDepth > 20) {
    throw new Error('Cannot move: would exceed maximum folder depth of 20');
  }

  // 4. Prevent moving folder into itself or its descendants
  if (isDescendantOf(params.destFolderState.id, params.folderId)) {
    throw new Error('Cannot move folder into itself or its subfolder');
  }

  // 5. ADD to destination FIRST (add-before-remove pattern)
  const destChildren = [...params.destFolderState.children, {
    ...folder,
    modifiedAt: Date.now(),
  }];

  await updateFolderMetadata({
    folderId: params.destFolderState.id,
    children: destChildren,
    folderKey: params.destFolderState.folderKey,
    ipnsPrivateKey: params.destFolderState.ipnsPrivateKey,
    ipnsName: params.destFolderState.ipnsName,
    sequenceNumber: params.destFolderState.sequenceNumber,
  });

  // 6. REMOVE from source AFTER destination confirmed
  const sourceChildren = params.sourceFolderState.children.filter(
    c => !(c.type === 'folder' && c.id === params.folderId)
  );

  await updateFolderMetadata({
    folderId: params.sourceFolderState.id,
    children: sourceChildren,
    folderKey: params.sourceFolderState.folderKey,
    ipnsPrivateKey: params.sourceFolderState.ipnsPrivateKey,
    ipnsName: params.sourceFolderState.ipnsName,
    sequenceNumber: params.sourceFolderState.sequenceNumber,
  });
}
```

**moveFile:**
```typescript
export async function moveFile(params: {
  fileId: string;
  sourceFolderState: FolderNode;
  destFolderState: FolderNode;
}): Promise<void> {
  // 1. Find file in source
  const file = params.sourceFolderState.children.find(
    c => c.type === 'file' && c.id === params.fileId
  ) as FileEntry | undefined;

  if (!file) throw new Error('File not found');

  // 2. Check name collision in destination
  const nameExists = params.destFolderState.children.some(
    c => c.name === file.name
  );
  if (nameExists) throw new Error('An item with this name already exists in destination');

  // 3. ADD to destination FIRST
  const destChildren = [...params.destFolderState.children, {
    ...file,
    modifiedAt: Date.now(),
  }];

  await updateFolderMetadata({
    folderId: params.destFolderState.id,
    children: destChildren,
    folderKey: params.destFolderState.folderKey,
    ipnsPrivateKey: params.destFolderState.ipnsPrivateKey,
    ipnsName: params.destFolderState.ipnsName,
    sequenceNumber: params.destFolderState.sequenceNumber,
  });

  // 4. REMOVE from source AFTER
  const sourceChildren = params.sourceFolderState.children.filter(
    c => !(c.type === 'file' && c.id === params.fileId)
  );

  await updateFolderMetadata({
    folderId: params.sourceFolderState.id,
    children: sourceChildren,
    folderKey: params.sourceFolderState.folderKey,
    ipnsPrivateKey: params.sourceFolderState.ipnsPrivateKey,
    ipnsName: params.sourceFolderState.ipnsName,
    sequenceNumber: params.sourceFolderState.sequenceNumber,
  });
}
```

**renameFile:**
```typescript
export async function renameFile(params: {
  fileId: string;
  newName: string;
  parentFolderState: FolderNode;
}): Promise<void> {
  const children = [...params.parentFolderState.children];
  const fileIndex = children.findIndex(
    c => c.type === 'file' && c.id === params.fileId
  );

  if (fileIndex === -1) throw new Error('File not found');

  // Check name collision
  const nameExists = children.some(
    c => c.name === params.newName && c.id !== params.fileId
  );
  if (nameExists) throw new Error('An item with this name already exists');

  const file = children[fileIndex] as FileEntry;
  children[fileIndex] = {
    ...file,
    name: params.newName,
    modifiedAt: Date.now(),
  };

  await updateFolderMetadata({
    folderId: params.parentFolderState.id,
    children,
    folderKey: params.parentFolderState.folderKey,
    ipnsPrivateKey: params.parentFolderState.ipnsPrivateKey,
    ipnsName: params.parentFolderState.ipnsName,
    sequenceNumber: params.parentFolderState.sequenceNumber,
  });
}
```

Add helper functions:
- `calculateSubtreeDepth(folderId: string, folders: Record<string, FolderNode>): number`
- `isDescendantOf(folderId: string, potentialAncestorId: string, folders: Record<string, FolderNode>): boolean`
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. Move operations follow add-before-remove pattern.
  </verify>
  <done>
moveFolder and moveFile use add-before-remove pattern. Depth limit enforced. Name collision blocked with error.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useFolder hook for UI integration</name>
  <files>
    apps/web/src/hooks/useFolder.ts
    apps/web/src/hooks/index.ts
  </files>
  <action>
**useFolder.ts:**
Create React hook that wraps folder operations with loading/error state:

```typescript
import { useState, useCallback } from 'react';
import { useFolderStore } from '../stores/folder.store';
import { useVaultStore } from '../stores/vault.store';
import * as folderService from '../services/folder.service';

type FolderOperationState = {
  isLoading: boolean;
  error: string | null;
};

export function useFolder() {
  const [state, setState] = useState<FolderOperationState>({
    isLoading: false,
    error: null,
  });

  const folderStore = useFolderStore();
  const vaultStore = useVaultStore();

  const handleCreate = useCallback(async (name: string, parentId: string | null) => {
    setState({ isLoading: true, error: null });
    try {
      const userPublicKey = vaultStore.getUserPublicKey();  // From auth store or vault
      const { folder, ipnsPrivateKey, folderKey } = await folderService.createFolder({
        parentFolderId: parentId,
        name,
        userPublicKey,
      });

      // Get parent folder state
      const parentFolder = parentId ? folderStore.folders[parentId] : getRootFolderState();

      // Add to parent's children
      const newChildren = [...parentFolder.children, folder];
      await folderService.updateFolderMetadata({
        folderId: parentFolder.id,
        children: newChildren,
        folderKey: parentFolder.folderKey,
        ipnsPrivateKey: parentFolder.ipnsPrivateKey,
        ipnsName: parentFolder.ipnsName,
        sequenceNumber: parentFolder.sequenceNumber,
        encryptedIpnsPrivateKey: folder.ipnsPrivateKeyEncrypted,  // For backend tracking
        keyEpoch: vaultStore.currentKeyEpoch,
      });

      // Update local state
      folderStore.updateFolderChildren(parentFolder.id, newChildren);

      setState({ isLoading: false, error: null });
      return folder;
    } catch (err) {
      const error = err instanceof Error ? err.message : 'Failed to create folder';
      setState({ isLoading: false, error });
      throw err;
    }
  }, [folderStore, vaultStore]);

  const handleRename = useCallback(async (
    itemId: string,
    itemType: 'file' | 'folder',
    newName: string,
    parentId: string
  ) => {
    setState({ isLoading: true, error: null });
    try {
      const parentFolder = folderStore.folders[parentId];
      if (!parentFolder) throw new Error('Parent folder not found');

      if (itemType === 'folder') {
        await folderService.renameFolder({
          folderId: itemId,
          newName,
          parentFolderState: parentFolder,
        });
      } else {
        await folderService.renameFile({
          fileId: itemId,
          newName,
          parentFolderState: parentFolder,
        });
      }

      setState({ isLoading: false, error: null });
    } catch (err) {
      const error = err instanceof Error ? err.message : 'Failed to rename';
      setState({ isLoading: false, error });
      throw err;
    }
  }, [folderStore]);

  const handleMove = useCallback(async (
    itemId: string,
    itemType: 'file' | 'folder',
    sourceParentId: string,
    destParentId: string
  ) => {
    setState({ isLoading: true, error: null });
    try {
      const sourceFolder = folderStore.folders[sourceParentId];
      const destFolder = folderStore.folders[destParentId];

      if (!sourceFolder || !destFolder) {
        throw new Error('Source or destination folder not found');
      }

      if (itemType === 'folder') {
        await folderService.moveFolder({
          folderId: itemId,
          sourceFolderState: sourceFolder,
          destFolderState: destFolder,
          getDepth: (id) => calculateFolderDepth(id, folderStore.folders),
        });
      } else {
        await folderService.moveFile({
          fileId: itemId,
          sourceFolderState: sourceFolder,
          destFolderState: destFolder,
        });
      }

      setState({ isLoading: false, error: null });
    } catch (err) {
      const error = err instanceof Error ? err.message : 'Failed to move';
      setState({ isLoading: false, error });
      throw err;
    }
  }, [folderStore]);

  const handleDelete = useCallback(async (
    itemId: string,
    itemType: 'file' | 'folder',
    parentId: string
  ) => {
    setState({ isLoading: true, error: null });
    try {
      const parentFolder = folderStore.folders[parentId];
      if (!parentFolder) throw new Error('Parent folder not found');

      if (itemType === 'folder') {
        await folderService.deleteFolder({
          folderId: itemId,
          parentFolderState: parentFolder,
          getFolderState: (id) => folderStore.folders[id],
          unpinCid: async (cid) => { /* Call unpin API */ },
        });
        folderStore.removeFolder(itemId);
      } else {
        await folderService.deleteFile({
          fileId: itemId,
          parentFolderState: parentFolder,
        });
      }

      setState({ isLoading: false, error: null });
    } catch (err) {
      const error = err instanceof Error ? err.message : 'Failed to delete';
      setState({ isLoading: false, error });
      throw err;
    }
  }, [folderStore]);

  return {
    ...state,
    createFolder: handleCreate,
    renameItem: handleRename,
    moveItem: handleMove,
    deleteItem: handleDelete,
  };
}
```

**hooks/index.ts:**
```typescript
export * from './useFolder';
```

Add helper function `calculateFolderDepth(folderId: string, folders: Record<string, FolderNode>): number` that walks up the tree to root.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. Hook returns proper types for all operations.
  </verify>
  <done>
useFolder hook provides createFolder, renameItem, moveItem, deleteItem with loading/error state. All operations call folder.service functions.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes in apps/web
2. renameFolder updates parent metadata with new name
3. deleteFolder recursively unpins all file CIDs
4. moveFolder/moveFile use add-before-remove pattern
5. Depth limit (20) enforced on folder creation and move
6. Name collision blocked with descriptive error
7. useFolder hook wraps all operations with error handling
</verification>

<success_criteria>
- FOLD-01: createFolder creates new folders with IPNS keypair
- FOLD-02: deleteFolder recursively removes contents and unpins CIDs
- FOLD-03: Depth limit (20) enforced on create and move
- FOLD-04: renameFolder updates folder name in parent metadata
- FOLD-05: moveFolder moves between parents (add-before-remove)
- FILE-04: renameFile updates file name in parent metadata
- FILE-05: moveFile moves between folders (add-before-remove)
- All operations publish updated IPNS records
- useFolder hook ready for Phase 6 UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/05-folder-system/05-04-SUMMARY.md`
</output>
