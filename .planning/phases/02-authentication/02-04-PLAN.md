---
phase: 02-authentication
plan: 04
type: execute
wave: 3
depends_on: ['02-03']
files_modified:
  - apps/api/src/auth/auth.controller.ts
  - apps/api/src/auth/auth.service.ts
  - apps/api/src/auth/dto/link-method.dto.ts
  - apps/web/src/components/auth/LinkedMethods.tsx
  - apps/web/src/hooks/useLinkedMethods.ts
  - apps/web/src/routes/Settings.tsx
  - apps/web/src/routes/index.tsx
autonomous: false
user_setup: []

must_haves:
  truths:
    - 'User can link additional auth methods to their account'
    - 'User can see all linked auth methods in settings'
    - 'Linking Google when already logged in via Email adds Google to same account'
    - 'User can unlink auth methods (if more than one remains)'
    - 'All linked auth methods derive the same keypair (via Web3Auth group connections)'
  artifacts:
    - path: 'apps/api/src/auth/auth.controller.ts'
      provides: 'Link/unlink endpoints'
      contains: 'linkMethod'
    - path: 'apps/web/src/routes/Settings.tsx'
      provides: 'Settings page with linked methods'
      exports: ['Settings']
    - path: 'apps/web/src/components/auth/LinkedMethods.tsx'
      provides: 'Linked auth methods display'
      exports: ['LinkedMethods']
  key_links:
    - from: 'apps/web/src/components/auth/LinkedMethods.tsx'
      to: 'apps/api/src/auth/auth.controller.ts'
      via: 'GET /auth/methods'
      pattern: 'fetch.*auth/methods'
    - from: 'apps/web/src/components/auth/LinkedMethods.tsx'
      to: 'apps/api/src/auth/auth.controller.ts'
      via: 'POST /auth/link'
      pattern: 'authApi.linkMethod'
---

<objective>
Implement account linking so users can connect multiple auth methods (Google, Apple, GitHub, Email, Wallet) to the same vault.

Purpose: Users need to be able to access their vault from different auth methods without creating separate accounts.

Output: Working account linking with settings page showing linked methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication/02-RESEARCH.md
@.planning/phases/02-authentication/02-CONTEXT.md
@.planning/phases/02-authentication/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend endpoints for account linking</name>
  <files>
    apps/api/src/auth/auth.controller.ts
    apps/api/src/auth/auth.service.ts
    apps/api/src/auth/dto/link-method.dto.ts
  </files>
  <action>
Add endpoints for viewing, linking, and unlinking auth methods:

**link-method.dto.ts:**

```typescript
import { ApiProperty } from '@nestjs/swagger';

export class LinkMethodDto {
  @ApiProperty({ description: 'Web3Auth ID token from the new auth method' })
  idToken: string;

  @ApiProperty({ description: 'Login type', enum: ['social', 'external_wallet'] })
  loginType: 'social' | 'external_wallet';
}

export class AuthMethodResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty({ enum: ['google', 'apple', 'github', 'email_passwordless', 'external_wallet'] })
  type: string;

  @ApiProperty({ description: 'Email or wallet address' })
  identifier: string;

  @ApiProperty({ nullable: true })
  lastUsedAt: Date | null;

  @ApiProperty()
  createdAt: Date;
}

export class UnlinkMethodDto {
  @ApiProperty()
  methodId: string;
}
```

**auth.service.ts additions:**

- `getLinkedMethods(userId: string)`: Return all AuthMethod entities for user
- `linkMethod(userId: string, linkDto: LinkMethodDto)`:
  1. Verify the new idToken with Web3AuthVerifierService
  2. CRITICAL: Verify the new token's publicKey matches the user's publicKey
     (This ensures both auth methods derive the same keypair via Web3Auth group connections)
  3. If publicKey mismatch, throw error "Auth method not linked to this account in Web3Auth"
  4. Extract type and identifier from token payload
  5. Check if method already linked (by type + identifier)
  6. If not linked, create new AuthMethod entity
  7. Return updated list of methods
- `unlinkMethod(userId: string, methodId: string)`:
  1. Find method by id and userId
  2. Count remaining methods for user
  3. If only 1 method, throw error "Cannot unlink last auth method"
  4. Delete the method
  5. Return success

**auth.controller.ts additions:**

```typescript
@Get('methods')
@UseGuards(JwtAuthGuard)
@ApiOperation({ summary: 'Get linked auth methods' })
async getMethods(@Req() req: Request): Promise<AuthMethodResponseDto[]> {
  return this.authService.getLinkedMethods(req.user.id);
}

@Post('link')
@UseGuards(JwtAuthGuard)
@ApiOperation({ summary: 'Link new auth method to account' })
async linkMethod(
  @Req() req: Request,
  @Body() linkDto: LinkMethodDto,
): Promise<AuthMethodResponseDto[]> {
  return this.authService.linkMethod(req.user.id, linkDto);
}

@Post('unlink')
@UseGuards(JwtAuthGuard)
@ApiOperation({ summary: 'Unlink auth method from account' })
async unlinkMethod(
  @Req() req: Request,
  @Body() unlinkDto: UnlinkMethodDto,
): Promise<{ success: boolean }> {
  await this.authService.unlinkMethod(req.user.id, unlinkDto.methodId);
  return { success: true };
}
```

  </action>
  <verify>
`pnpm build` passes.
OpenAPI spec regenerates with new endpoints.
  </verify>
  <done>
GET /auth/methods returns linked auth methods.
POST /auth/link adds new auth method if publicKey matches.
POST /auth/unlink removes auth method (if not last).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create settings page with linked methods UI</name>
  <files>
    apps/web/src/routes/Settings.tsx
    apps/web/src/routes/index.tsx
    apps/web/src/components/auth/LinkedMethods.tsx
    apps/web/src/hooks/useLinkedMethods.ts
    apps/web/src/lib/api/auth.ts
  </files>
  <action>
Create the settings page and linked methods component:

**Update lib/api/auth.ts:**
Add API functions for auth methods:

```typescript
export type AuthMethod = {
  id: string;
  type: 'google' | 'apple' | 'github' | 'email_passwordless' | 'external_wallet';
  identifier: string;
  lastUsedAt: string | null;
  createdAt: string;
};

export const authApi = {
  // ... existing methods ...

  getMethods: async (): Promise<AuthMethod[]> => {
    const response = await apiClient.get('/auth/methods');
    return response.data;
  },

  linkMethod: async (data: {
    idToken: string;
    loginType: 'social' | 'external_wallet';
  }): Promise<AuthMethod[]> => {
    const response = await apiClient.post('/auth/link', data);
    return response.data;
  },

  unlinkMethod: async (methodId: string): Promise<void> => {
    await apiClient.post('/auth/unlink', { methodId });
  },
};
```

**useLinkedMethods.ts:**

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { authApi, AuthMethod } from '../lib/api/auth';

export function useLinkedMethods() {
  const queryClient = useQueryClient();

  const { data: methods = [], isLoading } = useQuery({
    queryKey: ['auth-methods'],
    queryFn: authApi.getMethods,
  });

  const linkMutation = useMutation({
    mutationFn: authApi.linkMethod,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['auth-methods'] });
    },
  });

  const unlinkMutation = useMutation({
    mutationFn: authApi.unlinkMethod,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['auth-methods'] });
    },
  });

  return {
    methods,
    isLoading,
    linkMethod: linkMutation.mutate,
    unlinkMethod: unlinkMutation.mutate,
    isLinking: linkMutation.isPending,
    isUnlinking: unlinkMutation.isPending,
  };
}
```

**LinkedMethods.tsx:**

```typescript
import { useLinkedMethods } from '../../hooks/useLinkedMethods';
import { useAuthFlow } from '../../lib/web3auth/hooks';

const METHOD_LABELS: Record<string, string> = {
  google: 'Google',
  apple: 'Apple',
  github: 'GitHub',
  email_passwordless: 'Email',
  external_wallet: 'Wallet',
};

export function LinkedMethods() {
  const { methods, isLoading, linkMethod, unlinkMethod, isLinking, isUnlinking } = useLinkedMethods();
  const { connect, getIdToken } = useAuthFlow();

  const handleLink = async () => {
    try {
      // Open Web3Auth modal to authenticate with new method
      await connect();
      const idToken = await getIdToken();

      // Link the new method
      await linkMethod({
        idToken,
        loginType: 'social', // TODO: detect from userInfo
      });
    } catch (error) {
      console.error('Failed to link method:', error);
    }
  };

  const handleUnlink = async (methodId: string) => {
    if (methods.length <= 1) {
      alert('Cannot unlink your only auth method');
      return;
    }
    await unlinkMethod(methodId);
  };

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="linked-methods">
      <h3>Linked Auth Methods</h3>
      <ul className="methods-list">
        {methods.map((method) => (
          <li key={method.id} className="method-item">
            <span className="method-type">{METHOD_LABELS[method.type] || method.type}</span>
            <span className="method-identifier">{method.identifier}</span>
            <button
              onClick={() => handleUnlink(method.id)}
              disabled={isUnlinking || methods.length <= 1}
              className="unlink-button"
            >
              Unlink
            </button>
          </li>
        ))}
      </ul>
      <button
        onClick={handleLink}
        disabled={isLinking}
        className="link-button"
      >
        {isLinking ? 'Linking...' : 'Link Another Method'}
      </button>
    </div>
  );
}
```

**Settings.tsx:**

```typescript
import { useNavigate } from 'react-router-dom';
import { LinkedMethods } from '../components/auth/LinkedMethods';
import { useAuth } from '../hooks/useAuth';
import { useEffect } from 'react';

export function Settings() {
  const { isAuthenticated, isLoading } = useAuth();
  const navigate = useNavigate();

  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      navigate('/');
    }
  }, [isAuthenticated, isLoading, navigate]);

  if (isLoading) {
    return <div className="loading">Loading...</div>;
  }

  return (
    <div className="settings-container">
      <header className="settings-header">
        <h1>Settings</h1>
        <button onClick={() => navigate('/dashboard')} className="back-button">
          Back to Dashboard
        </button>
      </header>
      <main className="settings-main">
        <LinkedMethods />
      </main>
    </div>
  );
}
```

**Update routes/index.tsx:**
Add settings route:

```typescript
<Route path="/settings" element={<Settings />} />
```

**Update Dashboard.tsx:**
Add link to settings:

```typescript
<button onClick={() => navigate('/settings')} className="settings-link">
  Settings
</button>
```

  </action>
  <verify>
`pnpm build` passes.
`pnpm dev` shows settings page at /settings.
Linked methods list displays.
  </verify>
  <done>
Settings page exists with LinkedMethods component.
Users can view their linked auth methods.
Link/Unlink buttons work (with API integration).
Dashboard has link to settings.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete authentication flow with account linking</what-built>
  <how-to-verify>
**Prerequisites:**
1. Ensure Web3Auth dashboard is configured with valid client ID
2. Set VITE_WEB3AUTH_CLIENT_ID in apps/web/.env
3. Set JWT_SECRET in apps/api/.env
4. Start database: `docker compose -f docker/docker-compose.yml up -d`

**Test Flow:**

1. Start backend: `cd apps/api && pnpm start:dev`
2. Start frontend: `cd apps/web && pnpm dev`
3. Visit http://localhost:5173

**Scenario 1: New User Login**

1. Click "Sign In" button
2. Web3Auth modal should appear with Google, Apple, GitHub, Email, Wallet options
3. Select any method and complete authentication
4. Should redirect to dashboard
5. Check browser cookies - should see refresh_token (httpOnly)

**Scenario 2: Session Persistence**

1. Refresh the page
2. Should remain on dashboard (token refreshed from cookie)

**Scenario 3: Logout**

1. Click "Logout" button
2. Should immediately return to login page
3. Check cookies - refresh_token should be cleared

**Scenario 4: Account Linking**

1. Log in with one method (e.g., Google)
2. Go to Settings page
3. Click "Link Another Method"
4. Complete login with different method (e.g., Email)
5. Both methods should appear in linked methods list

**Scenario 5: Returning User**

1. Log out, then return to login page
2. Button should show "Continue with [last method used]"

**Expected Results:**

- All auth methods work (social, email, wallet)
- Tokens properly managed (access in memory, refresh in cookie)
- Account linking works when methods share same Web3Auth keypair
- Clean logout clears all state
  </how-to-verify>
  <resume-signal>Type "approved" if all scenarios pass, or describe any issues found</resume-signal>
  </task>

</tasks>

<verification>
1. All scenarios in checkpoint task pass
2. Database has users, auth_methods, refresh_tokens tables with data
3. No console errors in browser or server
4. OpenAPI spec includes all auth endpoints
5. Token refresh works silently (no visible interruption)
</verification>

<success_criteria>

- AUTH-01: Email/password sign up works and returns tokens
- AUTH-02: OAuth (Google, Apple, GitHub) sign in works
- AUTH-03: Magic link (email passwordless) works
- AUTH-04: External wallet (MetaMask) works
- AUTH-05: Session persists via refresh tokens
- AUTH-06: Multiple auth methods can be linked to same vault
- AUTH-07: Logout clears all keys from memory
- API-01: Backend verifies Web3Auth JWT correctly
- API-02: Backend issues and rotates tokens
  </success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-04-SUMMARY.md`
</output>
