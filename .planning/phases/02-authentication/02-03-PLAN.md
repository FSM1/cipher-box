---
phase: 02-authentication
plan: 03
type: execute
wave: 2
depends_on: ['02-01', '02-02']
files_modified:
  - apps/web/src/routes/Login.tsx
  - apps/web/src/routes/Dashboard.tsx
  - apps/web/src/components/auth/AuthButton.tsx
  - apps/web/src/components/auth/LogoutButton.tsx
  - apps/web/src/hooks/useAuth.ts
  - apps/web/src/routes/index.tsx
  - apps/api/src/auth/auth.controller.ts
  - apps/api/src/auth/auth.service.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - 'User can click Sign In and see Web3Auth modal with all options'
    - 'After Web3Auth success, backend is called and tokens are stored'
    - 'User is redirected to dashboard after successful login'
    - "Returning user sees 'Continue with [method]' for their last used auth"
    - 'User can click logout and is returned to login page with keys cleared'
    - 'Refresh token is stored in HTTP-only cookie by backend'
    - 'Access token refreshes silently when expired'
  artifacts:
    - path: 'apps/web/src/routes/Login.tsx'
      provides: 'Landing page with Sign In button'
      contains: 'useAuthFlow'
    - path: 'apps/web/src/components/auth/AuthButton.tsx'
      provides: 'Sign In button component'
      exports: ['AuthButton']
    - path: 'apps/web/src/components/auth/LogoutButton.tsx'
      provides: 'Logout button component'
      exports: ['LogoutButton']
    - path: 'apps/web/src/hooks/useAuth.ts'
      provides: 'Complete auth flow hook'
      exports: ['useAuth']
  key_links:
    - from: 'apps/web/src/routes/Login.tsx'
      to: 'apps/web/src/hooks/useAuth.ts'
      via: 'hook call'
      pattern: 'useAuth'
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/lib/api/auth.ts'
      via: 'import'
      pattern: 'authApi.login'
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/lib/web3auth/hooks.ts'
      via: 'import'
      pattern: 'useAuthFlow'
---

<objective>
Wire the complete login/logout flow connecting Web3Auth modal to backend authentication, with cookie-based refresh tokens and silent token refresh.

Purpose: Connect frontend Web3Auth integration with backend auth endpoints to complete the authentication user journey.

Output: Working end-to-end login flow where user can sign in, access dashboard, and log out.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication/02-RESEARCH.md
@.planning/phases/02-authentication/02-CONTEXT.md
@.planning/phases/02-authentication/02-01-SUMMARY.md
@.planning/phases/02-authentication/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update backend to use HTTP-only cookies for refresh token</name>
  <files>
    apps/api/src/auth/auth.controller.ts
    apps/api/src/auth/auth.service.ts
  </files>
  <action>
Update the auth controller to set refresh token in HTTP-only cookie instead of returning in body:

**auth.controller.ts updates:**

- Inject `@Res({ passthrough: true })` Response object in login and refresh endpoints
- After successful login/refresh, set refresh token cookie:
  ```typescript
  res.cookie('refresh_token', refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    path: '/auth', // Only sent to auth endpoints
  });
  ```
- Return only accessToken in response body (not refreshToken)
- Update refresh endpoint to read refresh token from cookie:
  ```typescript
  @Post('refresh')
  async refresh(
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ) {
    const refreshToken = req.cookies['refresh_token'];
    if (!refreshToken) {
      throw new UnauthorizedException('No refresh token');
    }
    // ... rest of logic
  }
  ```
- Update logout endpoint to clear cookie:
  ```typescript
  res.clearCookie('refresh_token', { path: '/auth' });
  ```

**auth.service.ts updates:**

- Update login return type to include refreshToken (controller will handle cookie)
- Update refresh to accept refreshToken parameter (from controller)

**Update main.ts:**

- Add cookie-parser middleware:
  ```typescript
  import * as cookieParser from 'cookie-parser';
  // In bootstrap:
  app.use(cookieParser());
  ```
- Install cookie-parser: `pnpm add cookie-parser && pnpm add -D @types/cookie-parser`

**Update DTOs:**

- LoginResponseDto: remove refreshToken field (only accessToken, isNewUser)
- TokenResponseDto: remove refreshToken field (only accessToken)
  </action>
  <verify>
  `pnpm build` passes.
  Backend starts without errors.
  Login response no longer includes refreshToken in body.
  </verify>
  <done>
  Refresh token stored in HTTP-only cookie, not response body.
  Cookie has secure, httpOnly, sameSite settings.
  Logout clears the cookie.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create complete auth flow hook and UI components</name>
  <files>
    apps/web/src/hooks/useAuth.ts
    apps/web/src/components/auth/AuthButton.tsx
    apps/web/src/components/auth/LogoutButton.tsx
  </files>
  <action>
Create the complete authentication hook that orchestrates Web3Auth + backend:

**useAuth.ts:**

```typescript
import { useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthFlow } from '../lib/web3auth/hooks';
import { authApi } from '../lib/api/auth';
import { useAuthStore } from '../stores/auth.store';

export function useAuth() {
  const navigate = useNavigate();
  const { isConnected, isLoading, userInfo, connect, disconnect, getIdToken, getPublicKey } =
    useAuthFlow();
  const {
    accessToken,
    isAuthenticated,
    lastAuthMethod,
    setAccessToken,
    setLastAuthMethod,
    logout: clearAuthState,
  } = useAuthStore();

  // Complete login: Web3Auth -> Backend
  const login = useCallback(async () => {
    try {
      // 1. Open Web3Auth modal
      await connect();

      // 2. Get credentials from Web3Auth
      const idToken = await getIdToken();
      const publicKey = await getPublicKey();

      // Determine login type from userInfo
      const loginType = userInfo?.typeOfLogin === 'jwt' ? 'external_wallet' : 'social';

      // 3. Authenticate with backend
      const response = await authApi.login({
        idToken,
        publicKey,
        loginType,
      });

      // 4. Store access token
      setAccessToken(response.accessToken);
      setLastAuthMethod(userInfo?.typeOfLogin || 'unknown');

      // 5. Navigate to dashboard
      navigate('/dashboard');
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }, [connect, getIdToken, getPublicKey, userInfo, setAccessToken, setLastAuthMethod, navigate]);

  // Complete logout: Backend -> Web3Auth -> Clear state
  const logout = useCallback(async () => {
    try {
      // 1. Call backend logout (clears cookie)
      if (isAuthenticated) {
        await authApi.logout();
      }

      // 2. Disconnect Web3Auth
      await disconnect();

      // 3. Clear local state
      clearAuthState();

      // 4. Navigate to login
      navigate('/');
    } catch (error) {
      console.error('Logout failed:', error);
      // Still clear state even if backend fails
      clearAuthState();
      navigate('/');
    }
  }, [isAuthenticated, disconnect, clearAuthState, navigate]);

  // Try to restore session on mount
  useEffect(() => {
    const restoreSession = async () => {
      if (isConnected && !isAuthenticated) {
        try {
          // Try to refresh using cookie
          const response = await authApi.refresh();
          setAccessToken(response.accessToken);
        } catch {
          // No valid session, stay on login
        }
      }
    };
    restoreSession();
  }, [isConnected, isAuthenticated, setAccessToken]);

  return {
    isLoading,
    isAuthenticated,
    lastAuthMethod,
    userInfo,
    login,
    logout,
  };
}
```

**AuthButton.tsx:**

```typescript
import { useAuth } from '../../hooks/useAuth';
import { useAuthStore } from '../../stores/auth.store';

export function AuthButton() {
  const { login, isLoading, lastAuthMethod } = useAuth();

  const buttonText = lastAuthMethod
    ? `Continue with ${lastAuthMethod}`
    : 'Sign In';

  return (
    <button
      onClick={login}
      disabled={isLoading}
      className="auth-button"
    >
      {isLoading ? 'Connecting...' : buttonText}
    </button>
  );
}
```

Per 02-CONTEXT.md: Returning users see "Continue with [method]" for their last used auth method.

**LogoutButton.tsx:**

```typescript
import { useAuth } from '../../hooks/useAuth';

export function LogoutButton() {
  const { logout, isLoading } = useAuth();

  // Per 02-CONTEXT.md: Immediate logout on click, no confirmation
  return (
    <button
      onClick={logout}
      disabled={isLoading}
      className="logout-button"
    >
      Logout
    </button>
  );
}
```

  </action>
  <verify>
`pnpm build` passes.
Components export correctly.
useAuth hook orchestrates complete flow.
  </verify>
  <done>
useAuth hook connects Web3Auth modal to backend authentication.
AuthButton shows "Continue with [method]" for returning users.
LogoutButton triggers immediate logout without confirmation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Login and Dashboard pages</name>
  <files>
    apps/web/src/routes/Login.tsx
    apps/web/src/routes/Dashboard.tsx
    apps/web/src/routes/index.tsx
  </files>
  <action>
Update the route pages to use the new auth components:

**Login.tsx:**
Per 02-CONTEXT.md: Landing page first with brief intro/value prop and prominent Sign In button.

```typescript
import { AuthButton } from '../components/auth/AuthButton';
import { useAuth } from '../hooks/useAuth';
import { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

export function Login() {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      navigate('/dashboard');
    }
  }, [isAuthenticated, navigate]);

  return (
    <div className="login-container">
      <h1>CipherBox</h1>
      <p>Zero-knowledge encrypted cloud storage</p>
      <p className="login-description">
        Your files, encrypted on your device.
        We never see your data.
      </p>
      <AuthButton />
    </div>
  );
}
```

**Dashboard.tsx:**
Add logout button and protect the route:

```typescript
import { LogoutButton } from '../components/auth/LogoutButton';
import { useAuth } from '../hooks/useAuth';
import { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

export function Dashboard() {
  const { isAuthenticated, isLoading, userInfo } = useAuth();
  const navigate = useNavigate();

  // Redirect if not authenticated
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      navigate('/');
    }
  }, [isAuthenticated, isLoading, navigate]);

  if (isLoading) {
    return <div className="loading">Loading...</div>;
  }

  return (
    <div className="dashboard-container">
      <header className="dashboard-header">
        <h1>CipherBox</h1>
        <div className="user-info">
          {userInfo?.email && <span>{userInfo.email}</span>}
          <LogoutButton />
        </div>
      </header>
      <main className="dashboard-main">
        <aside className="folder-sidebar">
          <h2>Folders</h2>
          <p>Folder tree coming in Phase 5</p>
        </aside>
        <section className="file-area">
          <h2>Files</h2>
          <p>File browser coming in Phase 6</p>
        </section>
      </main>
    </div>
  );
}
```

**routes/index.tsx:**
Ensure routes are set up correctly (should already be):

- `/` -> Login
- `/dashboard` -> Dashboard
  </action>
  <verify>
  `pnpm build` passes.
  `pnpm dev` shows login page at /.
  Login page has AuthButton.
  Dashboard has LogoutButton and redirects if not authenticated.
  </verify>
  <done>
  Login page shows landing with value prop and Sign In button.
  Dashboard shows logout button and user info.
  Route protection redirects unauthenticated users.
  </done>
  </task>

</tasks>

<verification>
1. Start backend: `cd apps/api && pnpm start:dev`
2. Start frontend: `cd apps/web && pnpm dev`
3. Visit http://localhost:5173
4. See landing page with CipherBox branding and Sign In button
5. Click Sign In - Web3Auth modal should appear (may error without valid client ID)
6. After login (with valid Web3Auth config), should redirect to dashboard
7. Dashboard shows logout button
8. Click logout - returns to login page
9. Verify refresh token cookie is set (Dev Tools -> Application -> Cookies)
</verification>

<success_criteria>

- Login page shows value proposition with Sign In button
- AuthButton shows "Continue with [method]" for returning users
- Web3Auth modal opens on Sign In click
- After Web3Auth success, backend /auth/login is called
- Access token stored in memory, refresh token in HTTP-only cookie
- User redirected to dashboard after login
- Dashboard protected - unauthenticated users redirected to login
- Logout clears state and cookie, returns to login
- Token refresh happens silently on 401 responses
  </success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-03-SUMMARY.md`
</output>
