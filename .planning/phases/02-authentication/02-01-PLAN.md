---
phase: 02-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/auth/auth.module.ts
  - apps/api/src/auth/auth.controller.ts
  - apps/api/src/auth/auth.service.ts
  - apps/api/src/auth/entities/user.entity.ts
  - apps/api/src/auth/entities/refresh-token.entity.ts
  - apps/api/src/auth/entities/auth-method.entity.ts
  - apps/api/src/auth/dto/login.dto.ts
  - apps/api/src/auth/dto/token.dto.ts
  - apps/api/src/auth/services/web3auth-verifier.service.ts
  - apps/api/src/auth/services/token.service.ts
  - apps/api/src/auth/strategies/jwt.strategy.ts
  - apps/api/src/auth/guards/jwt-auth.guard.ts
  - apps/api/src/app.module.ts
  - apps/api/package.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - 'POST /auth/login accepts Web3Auth idToken and returns access+refresh tokens'
    - 'POST /auth/refresh rotates refresh token and returns new tokens'
    - 'POST /auth/logout invalidates refresh token'
    - 'Protected endpoints reject requests without valid JWT'
    - 'Web3Auth JWT is verified against correct JWKS endpoint based on login type'
  artifacts:
    - path: 'apps/api/src/auth/auth.module.ts'
      provides: 'Auth module with all dependencies registered'
      exports: ['AuthModule']
    - path: 'apps/api/src/auth/auth.controller.ts'
      provides: 'Auth endpoints'
      exports: ['AuthController']
    - path: 'apps/api/src/auth/entities/user.entity.ts'
      provides: 'User entity with publicKey'
      contains: 'class User'
    - path: 'apps/api/src/auth/entities/refresh-token.entity.ts'
      provides: 'Refresh token entity with hash storage'
      contains: 'class RefreshToken'
    - path: 'apps/api/src/auth/entities/auth-method.entity.ts'
      provides: 'Auth method entity linking user to login types'
      contains: 'class AuthMethod'
    - path: 'apps/api/src/auth/services/web3auth-verifier.service.ts'
      provides: 'Web3Auth JWT verification with dual JWKS'
      contains: 'verifyIdToken'
    - path: 'apps/api/src/auth/services/token.service.ts'
      provides: 'Token creation and rotation'
      contains: 'createTokens'
  key_links:
    - from: 'apps/api/src/auth/auth.controller.ts'
      to: 'apps/api/src/auth/auth.service.ts'
      via: 'constructor injection'
      pattern: 'AuthService'
    - from: 'apps/api/src/auth/auth.service.ts'
      to: 'apps/api/src/auth/services/web3auth-verifier.service.ts'
      via: 'constructor injection'
      pattern: 'Web3AuthVerifierService'
    - from: 'apps/api/src/auth/auth.service.ts'
      to: 'apps/api/src/auth/services/token.service.ts'
      via: 'constructor injection'
      pattern: 'TokenService'
    - from: 'apps/api/src/app.module.ts'
      to: 'apps/api/src/auth/auth.module.ts'
      via: 'imports array'
      pattern: 'AuthModule'
---

<objective>
Create the complete backend authentication module with Web3Auth JWT verification, user/token entities, and auth endpoints (login, refresh, logout).

Purpose: Backend must verify Web3Auth tokens and issue CipherBox access/refresh tokens before frontend can complete authentication flows.

Output: Working `/auth/login`, `/auth/refresh`, `/auth/logout` endpoints with database entities and JWT guards.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication/02-RESEARCH.md
@.planning/phases/02-authentication/02-CONTEXT.md
@apps/api/src/app.module.ts
@apps/api/src/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth entities and install dependencies</name>
  <files>
    apps/api/src/auth/entities/user.entity.ts
    apps/api/src/auth/entities/refresh-token.entity.ts
    apps/api/src/auth/entities/auth-method.entity.ts
    apps/api/package.json
  </files>
  <action>
Install required dependencies:
```bash
cd apps/api && pnpm add jose argon2 @nestjs/jwt @nestjs/passport passport passport-jwt && pnpm add -D @types/passport-jwt
```

Create TypeORM entities following the schema in API_SPECIFICATION.md:

**User entity (user.entity.ts):**

- `id`: UUID primary key with auto-generation
- `publicKey`: string, unique, not null - the secp256k1 public key from Web3Auth
- `createdAt`: timestamp with default now
- `updatedAt`: timestamp with auto-update
- Relations: OneToMany to RefreshToken, OneToMany to AuthMethod

**RefreshToken entity (refresh-token.entity.ts):**

- `id`: UUID primary key
- `userId`: UUID foreign key to User
- `tokenHash`: string - argon2 hash of the actual token
- `expiresAt`: timestamp
- `revokedAt`: nullable timestamp (null = active, set = revoked)
- `createdAt`: timestamp with default now
- Relations: ManyToOne to User

**AuthMethod entity (auth-method.entity.ts):**

- `id`: UUID primary key
- `userId`: UUID foreign key to User
- `type`: string literal type - 'google' | 'apple' | 'github' | 'email_passwordless' | 'external_wallet'
- `identifier`: string - email address, wallet address, or OAuth ID
- `lastUsedAt`: nullable timestamp
- `createdAt`: timestamp with default now
- Relations: ManyToOne to User

Use string literal types (not enums per CLAUDE.md). All entities use UUID for id fields.
</action>
<verify>
`pnpm build` in apps/api completes without TypeScript errors.
`pnpm exec tsc --noEmit` passes.
</verify>
<done>
Three entity files exist with correct fields, relations, and decorators. Dependencies installed.
</done>
</task>

<task type="auto">
  <name>Task 2: Create auth services (Web3Auth verifier and token service)</name>
  <files>
    apps/api/src/auth/services/web3auth-verifier.service.ts
    apps/api/src/auth/services/token.service.ts
    apps/api/src/auth/dto/login.dto.ts
    apps/api/src/auth/dto/token.dto.ts
  </files>
  <action>
Create the core authentication services following patterns from 02-RESEARCH.md:

**Web3AuthVerifierService (web3auth-verifier.service.ts):**

- Injectable NestJS service
- Use `jose` library for JWT verification
- Implement `verifyIdToken(idToken: string, expectedPublicKeyOrAddress: string, loginType: 'social' | 'external_wallet')`:
  - CRITICAL: Use correct JWKS endpoint based on loginType:
    - social: `https://api-auth.web3auth.io/jwks`
    - external_wallet: `https://authjs.web3auth.io/jwks`
  - Create remote JWK set with jose.createRemoteJWKSet()
  - Verify JWT with algorithm ES256
  - For social logins: Extract public_key from wallets array where type === 'web3auth_app_key'
  - For external wallets: Extract address from wallets array where type === 'ethereum'
  - Validate that extracted key/address matches expectedPublicKeyOrAddress
  - Return the verified payload

**TokenService (token.service.ts):**

- Injectable NestJS service
- Inject JwtService and Repository<RefreshToken>
- `createTokens(userId: string, publicKey: string)`:
  - Generate access token with JwtService.sign({ sub: userId, publicKey }, { expiresIn: '15m' })
  - Generate refresh token: 32 random bytes as hex string
  - Hash refresh token with argon2.hash()
  - Save RefreshToken entity with hash, userId, expiresAt (7 days)
  - Return { accessToken, refreshToken }
- `rotateRefreshToken(oldRefreshToken: string, userId: string)`:
  - Find all non-revoked tokens for user
  - Iterate and argon2.verify() to find matching token
  - If found and not expired: revoke it (set revokedAt), create new tokens
  - If not found or expired: throw UnauthorizedException
- `revokeAllUserTokens(userId: string)`:
  - Set revokedAt on all active tokens for user

**DTOs (login.dto.ts, token.dto.ts):**

- LoginDto: idToken (string), publicKey (string), loginType ('social' | 'external_wallet')
- LoginResponseDto: accessToken (string), refreshToken (string), isNewUser (boolean)
- RefreshDto: refreshToken (string)
- TokenResponseDto: accessToken (string), refreshToken (string)

Add Swagger decorators (@ApiProperty) to all DTO fields.
</action>
<verify>
`pnpm build` passes.
Services can be instantiated (verified by module compilation).
</verify>
<done>
Web3AuthVerifierService correctly selects JWKS endpoint based on login type.
TokenService creates, rotates, and revokes tokens with argon2 hashing.
DTOs have Swagger decorators.
</done>
</task>

<task type="auto">
  <name>Task 3: Create auth controller, JWT strategy, and wire module</name>
  <files>
    apps/api/src/auth/auth.controller.ts
    apps/api/src/auth/auth.service.ts
    apps/api/src/auth/auth.module.ts
    apps/api/src/auth/strategies/jwt.strategy.ts
    apps/api/src/auth/guards/jwt-auth.guard.ts
    apps/api/src/app.module.ts
  </files>
  <action>
Create the controller, strategy, guard, and wire everything together:

**JwtStrategy (jwt.strategy.ts):**

- Extend PassportStrategy(Strategy) from @nestjs/passport
- Extract JWT from Authorization Bearer header
- Use JWT_SECRET from ConfigService
- validate(payload: { sub: string, publicKey: string }) returns user from UserRepository

**JwtAuthGuard (jwt-auth.guard.ts):**

- Extend AuthGuard('jwt') from @nestjs/passport
- Simple guard that uses the JWT strategy

**AuthService (auth.service.ts):**

- Inject Web3AuthVerifierService, TokenService, UserRepository, AuthMethodRepository
- `login(loginDto: LoginDto)`:
  1. Verify idToken with Web3AuthVerifierService
  2. Find or create User by publicKey
  3. Find or create AuthMethod by user + loginType + identifier
  4. Update AuthMethod.lastUsedAt
  5. Create tokens with TokenService
  6. Return { accessToken, refreshToken, isNewUser }
- `refresh(refreshToken: string, userId: string)`:
  1. Call TokenService.rotateRefreshToken()
  2. Return new tokens
- `logout(userId: string)`:
  1. Call TokenService.revokeAllUserTokens()
  2. Return { success: true }

**AuthController (auth.controller.ts):**

- @ApiTags('Auth')
- POST /auth/login - public, accepts LoginDto, returns LoginResponseDto
- POST /auth/refresh - public, accepts RefreshDto, returns TokenResponseDto
- POST /auth/logout - protected with JwtAuthGuard, returns { success: boolean }
- Add Swagger decorators (@ApiOperation, @ApiResponse)

**AuthModule (auth.module.ts):**

- Import: PassportModule.register({ defaultStrategy: 'jwt' }), JwtModule.registerAsync (with JWT_SECRET from ConfigService, 15m expiry), TypeOrmModule.forFeature([User, RefreshToken, AuthMethod])
- Providers: AuthService, Web3AuthVerifierService, TokenService, JwtStrategy
- Controllers: AuthController
- Exports: AuthService, JwtModule

**Update AppModule:**

- Add AuthModule to imports
- Add entities to TypeORM entities array: [User, RefreshToken, AuthMethod]

**Update .env.example:**

- Add JWT_SECRET=your-jwt-secret-here
  </action>
  <verify>
  `pnpm build` passes.
  `pnpm start:dev` starts without errors.
  OpenAPI spec regenerates with /auth endpoints: `pnpm -w api:generate`.
  </verify>
  <done>
  POST /auth/login, /auth/refresh, /auth/logout endpoints visible in Swagger UI.
  JwtAuthGuard protects logout endpoint.
  AuthModule wired into AppModule.
  </done>
  </task>

</tasks>

<verification>
1. Start the backend: `cd apps/api && pnpm start:dev`
2. Verify Swagger UI shows Auth tag with login/refresh/logout endpoints
3. Regenerate API client: `pnpm -w api:generate`
4. Verify OpenAPI spec includes new endpoints: `grep -l "auth/login" packages/api-client/openapi.json`
5. Build passes: `pnpm -w build`
</verification>

<success_criteria>

- POST /auth/login accepts { idToken, publicKey, loginType } and returns tokens (manual test with mock token will fail JWT verification - that's expected)
- POST /auth/refresh accepts { refreshToken } and rotates tokens
- POST /auth/logout requires Bearer token and invalidates session
- Database creates users, refresh_tokens, auth_methods tables on sync
- OpenAPI spec updated with all auth endpoints
- API client regenerated with auth hooks
  </success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-01-SUMMARY.md`
</output>
