---
phase: 03-core-encryption
plan: 03
type: execute
wave: 2
depends_on: ['03-01', '03-02']
files_modified:
  - packages/crypto/src/keys/index.ts
  - packages/crypto/src/keys/derive.ts
  - packages/crypto/src/keys/hierarchy.ts
  - packages/crypto/src/vault/index.ts
  - packages/crypto/src/vault/init.ts
  - packages/crypto/src/vault/types.ts
  - packages/crypto/src/index.ts
  - packages/crypto/src/__tests__/hierarchy.test.ts
  - packages/crypto/src/__tests__/vault.test.ts
autonomous: true

must_haves:
  truths:
    - 'Vault initialization generates all required keys (root folder key, root IPNS keypair)'
    - 'Key hierarchy functions derive folder keys from parent keys'
    - 'Private keys exist only in memory (no storage APIs called)'
    - 'VaultKey type unifies social login and external wallet key sources'
  artifacts:
    - path: 'packages/crypto/src/keys/derive.ts'
      provides: 'HKDF key derivation'
      exports: ['deriveKey']
    - path: 'packages/crypto/src/keys/hierarchy.ts'
      provides: 'Key hierarchy functions'
      exports: ['deriveRootKey', 'deriveFolderKey', 'deriveFileKey']
    - path: 'packages/crypto/src/vault/init.ts'
      provides: 'Vault initialization'
      exports: ['initializeVault']
    - path: 'packages/crypto/src/vault/types.ts'
      provides: 'Vault types'
      exports: ['VaultInit', 'EncryptedVaultKeys']
  key_links:
    - from: 'packages/crypto/src/vault/init.ts'
      to: 'packages/crypto/src/utils/random.ts'
      via: 'key generation'
      pattern: 'generateFileKey|generateRandomBytes'
    - from: 'packages/crypto/src/vault/init.ts'
      to: 'packages/crypto/src/ed25519/keygen.ts'
      via: 'IPNS keypair'
      pattern: 'generateEd25519Keypair'
    - from: 'packages/crypto/src/vault/init.ts'
      to: 'packages/crypto/src/ecies/encrypt.ts'
      via: 'key wrapping'
      pattern: 'wrapKey'
---

<objective>
Implement vault initialization and key hierarchy management for the crypto module.

Purpose: When a user first signs in, we initialize their vault by generating a root folder key and root IPNS keypair. The key hierarchy functions enable deriving folder-specific keys and wrapping them for storage. This completes the crypto module for use by the frontend in Phase 4+.

Output: Working vault initialization that produces all keys needed for storage, plus key hierarchy utilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-encryption/03-CONTEXT.md
@.planning/phases/03-core-encryption/03-RESEARCH.md
@.planning/phases/03-core-encryption/03-01-SUMMARY.md
@.planning/phases/03-core-encryption/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HKDF key derivation</name>
  <files>
    packages/crypto/src/keys/index.ts
    packages/crypto/src/keys/derive.ts
  </files>
  <action>
    1. Create packages/crypto/src/keys/derive.ts:
       ```typescript
       export async function deriveKey(params: {
         inputKey: Uint8Array;
         salt: Uint8Array;
         info: Uint8Array;
         outputLength?: number; // defaults to 32
       }): Promise<Uint8Array>
       ```
       - Use Web Crypto API HKDF-SHA256
       - Reference implementation pattern from signatureKeyDerivation.ts
       - Import key as raw material with 'HKDF' algorithm
       - Use deriveBits to get output bytes
       - Default outputLength to 32 (256 bits)
       - Handle ArrayBuffer conversion properly for Web Crypto

    2. Create packages/crypto/src/keys/index.ts barrel export

    Note: This is the low-level HKDF function. Higher-level hierarchy functions in Task 2
    will use this for context-specific derivations.

  </action>
  <verify>
    - `pnpm build` compiles without errors
    - Function signature matches existing hkdfDerive in signatureKeyDerivation.ts
  </verify>
  <done>
    HKDF key derivation implemented using Web Crypto API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement key hierarchy functions</name>
  <files>
    packages/crypto/src/keys/hierarchy.ts
    packages/crypto/src/keys/index.ts
    packages/crypto/src/__tests__/hierarchy.test.ts
  </files>
  <action>
    1. Create packages/crypto/src/keys/hierarchy.ts:
       ```typescript
       import { deriveKey } from './derive';
       import { generateFileKey } from '../utils/random';

       // Derive a context-specific key from vault key
       // Used internally - not exposed publicly
       export async function deriveContextKey(
         masterKey: Uint8Array,
         context: string
       ): Promise<Uint8Array>
       ```
       - Salt: 'CipherBox-v1' as bytes
       - Info: context string as bytes
       - Returns 32-byte derived key

       ```typescript
       // Generate a new folder key (random, not derived)
       export async function generateFolderKey(): Promise<Uint8Array>
       ```
       - Returns random 32-byte key (same as file key)
       - Folder keys are random, then ECIES-wrapped with user's public key

       ```typescript
       // Generate a new file key (random, not derived)
       export async function generateFileKey(): Promise<Uint8Array>
       ```
       - Re-export from utils/random for API consistency
       - File keys are random per-file (no deduplication per CRYPT-06)

    2. Update packages/crypto/src/keys/index.ts to export all functions

    3. Create packages/crypto/src/__tests__/hierarchy.test.ts with vitest:
       - Test: deriveContextKey produces consistent output for same inputs
       - Test: deriveContextKey produces different output for different contexts
       - Test: generateFolderKey produces unique keys (randomness)
       - Test: generated keys are 32 bytes
       - Test: deriveKey matches expected HKDF-SHA256 behavior

    Design note per CONTEXT.md: File keys are random per-file, NOT deterministic from
    folder+filename. This is a security feature - no deduplication.

  </action>
  <verify>
    - `pnpm test` passes hierarchy tests
    - Derived keys are deterministic for same inputs
    - Generated keys are random and unique
  </verify>
  <done>
    Key hierarchy functions work, tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement vault initialization</name>
  <files>
    packages/crypto/src/vault/index.ts
    packages/crypto/src/vault/types.ts
    packages/crypto/src/vault/init.ts
    packages/crypto/src/index.ts
    packages/crypto/src/__tests__/vault.test.ts
  </files>
  <action>
    1. Create packages/crypto/src/vault/types.ts:
       ```typescript
       import type { Ed25519Keypair } from '../ed25519';

       // Result of vault initialization (plaintext, in-memory only)
       export type VaultInit = {
         rootFolderKey: Uint8Array;      // 32-byte AES key for root folder
         rootIpnsKeypair: Ed25519Keypair; // Ed25519 for signing root IPNS
       };

       // Keys encrypted for server storage
       export type EncryptedVaultKeys = {
         encryptedRootFolderKey: Uint8Array; // ECIES-wrapped with user's publicKey
         encryptedIpnsPrivateKey: Uint8Array; // ECIES-wrapped with user's publicKey
         rootIpnsPublicKey: Uint8Array;       // Public key for IPNS name derivation
       };
       ```

    2. Create packages/crypto/src/vault/init.ts:
       ```typescript
       import { generateFileKey } from '../utils/random';
       import { generateEd25519Keypair } from '../ed25519';
       import { wrapKey } from '../ecies';
       import type { VaultKey } from '../types';
       import type { VaultInit, EncryptedVaultKeys } from './types';

       // Initialize a new vault (called on first sign-in)
       export async function initializeVault(): Promise<VaultInit>
       ```
       - Generate random rootFolderKey (32 bytes)
       - Generate Ed25519 keypair for root IPNS
       - Return VaultInit with plaintext keys (kept in memory)

       ```typescript
       // Encrypt vault keys for server storage
       export async function encryptVaultKeys(
         vault: VaultInit,
         userPublicKey: Uint8Array
       ): Promise<EncryptedVaultKeys>
       ```
       - ECIES-wrap rootFolderKey with user's public key
       - ECIES-wrap IPNS private key with user's public key
       - Return EncryptedVaultKeys for sending to backend
       - This is what gets stored on server (zero-knowledge)

       ```typescript
       // Decrypt vault keys from server (called on login)
       export async function decryptVaultKeys(
         encrypted: EncryptedVaultKeys,
         userPrivateKey: Uint8Array
       ): Promise<VaultInit>
       ```
       - ECIES-unwrap rootFolderKey with user's private key
       - ECIES-unwrap IPNS private key with user's private key
       - Reconstruct VaultInit with plaintext keys

    3. Create packages/crypto/src/vault/index.ts barrel export

    4. Update packages/crypto/src/index.ts to export:
       - All from './vault'
       - All from './keys'
       - Keep all existing exports
       - Update CRYPTO_VERSION to '0.2.0'

    5. Create packages/crypto/src/__tests__/vault.test.ts with vitest:
       - Test: initializeVault returns valid VaultInit
       - Test: rootFolderKey is 32 bytes
       - Test: rootIpnsKeypair has correct sizes (32/32)
       - Test: encrypt/decrypt round-trip recovers original keys
       - Test: encrypted keys are different from plaintext (sanity check)
       - Test: decryption with wrong private key throws
       - Test: each initializeVault produces unique keys (randomness)
       - Generate test VaultKey using @noble/secp256k1 for tests

  </action>
  <verify>
    - `pnpm test` passes all vault tests
    - `pnpm build` succeeds
    - Package exports VaultInit, EncryptedVaultKeys types
    - Check dist/index.d.ts includes all vault functions
  </verify>
  <done>
    Vault initialization works, keys encrypt/decrypt correctly, all exports ready.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm -F @cipherbox/crypto test` - All tests pass (AES, ECIES, Ed25519, IPNS, hierarchy, vault)
2. `pnpm -F @cipherbox/crypto build` - Package builds without errors
3. Verify complete API in dist/index.d.ts:
   - AES: encryptAesGcm, decryptAesGcm
   - ECIES: wrapKey, unwrapKey
   - Ed25519: generateEd25519Keypair, signEd25519, verifyEd25519
   - IPNS: signIpnsData, IPNS_SIGNATURE_PREFIX
   - Keys: deriveKey, generateFolderKey, generateFileKey
   - Vault: initializeVault, encryptVaultKeys, decryptVaultKeys
   - Utils: generateRandomBytes, generateIv, hexToBytes, bytesToHex, clearBytes
   - Types: VaultKey, VaultInit, EncryptedVaultKeys, Ed25519Keypair, CryptoError
4. Run full test suite from monorepo root: `pnpm test`
</verification>

<success_criteria>

- [ ] HKDF key derivation works with Web Crypto API
- [ ] Key hierarchy functions generate/derive keys correctly
- [ ] Vault initialization produces all required keys
- [ ] Encrypt/decrypt vault keys round-trip works
- [ ] Private keys never written to storage (memory only)
- [ ] All tests pass
- [ ] Package exports complete crypto API
- [ ] CRYPTO_VERSION updated to '0.2.0'
      </success_criteria>

<output>
After completion, create `.planning/phases/03-core-encryption/03-03-SUMMARY.md`
</output>
