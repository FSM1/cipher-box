---
phase: 03-core-encryption
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/package.json
  - packages/crypto/src/ed25519/index.ts
  - packages/crypto/src/ed25519/keygen.ts
  - packages/crypto/src/ed25519/sign.ts
  - packages/crypto/src/ipns/index.ts
  - packages/crypto/src/ipns/sign-record.ts
  - packages/crypto/src/__tests__/ed25519.test.ts
  - packages/crypto/src/__tests__/ipns.test.ts
autonomous: true

must_haves:
  truths:
    - 'Ed25519 keypairs generate correctly (32-byte private, 32-byte public)'
    - 'Ed25519 signatures verify correctly'
    - 'IPNS records can be signed with Ed25519 keys'
  artifacts:
    - path: 'packages/crypto/src/ed25519/keygen.ts'
      provides: 'Ed25519 keypair generation'
      exports: ['generateEd25519Keypair']
    - path: 'packages/crypto/src/ed25519/sign.ts'
      provides: 'Ed25519 signing and verification'
      exports: ['signEd25519', 'verifyEd25519']
    - path: 'packages/crypto/src/ipns/sign-record.ts'
      provides: 'IPNS record signing utilities'
      exports: ['signIpnsData', 'IPNS_SIGNATURE_PREFIX']
  key_links:
    - from: 'packages/crypto/src/ed25519/keygen.ts'
      to: '@noble/ed25519'
      via: 'key generation'
      pattern: 'import.*from.*@noble/ed25519'
    - from: 'packages/crypto/src/ipns/sign-record.ts'
      to: 'packages/crypto/src/ed25519/sign.ts'
      via: 'signing function'
      pattern: 'signEd25519'
---

<objective>
Implement Ed25519 key generation and signing for IPNS record operations.

Purpose: IPNS records require Ed25519 signatures. Each folder has its own Ed25519 keypair, and the client signs IPNS updates before the backend relays them to IPFS. This enables zero-knowledge publishing where the server never holds signing keys.

Output: Working Ed25519 primitives with IPNS-specific signing helper, all tested.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-encryption/03-CONTEXT.md
@.planning/phases/03-core-encryption/03-RESEARCH.md
@packages/crypto/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Ed25519 dependencies and implement key generation</name>
  <files>
    packages/crypto/package.json
    packages/crypto/src/ed25519/index.ts
    packages/crypto/src/ed25519/keygen.ts
    packages/crypto/src/constants.ts
  </files>
  <action>
    1. Update packages/crypto/package.json to add dependencies:
       - `@noble/ed25519: ^2.x` (Ed25519 signing)
       - Note: `@noble/hashes` should already be added from Plan 01 (if not, add it)

    2. Update packages/crypto/src/constants.ts to add:
       - `ED25519_PUBLIC_KEY_SIZE = 32`
       - `ED25519_PRIVATE_KEY_SIZE = 32`
       - `ED25519_SIGNATURE_SIZE = 64`

    3. Create packages/crypto/src/ed25519/keygen.ts:
       ```typescript
       import * as ed from '@noble/ed25519';
       import { sha512 } from '@noble/hashes/sha512';

       // Enable sync methods (required for @noble/ed25519)
       ed.etc.sha512Sync = (...m) => sha512(ed.etc.concatBytes(...m));

       export type Ed25519Keypair = {
         publicKey: Uint8Array;  // 32 bytes
         privateKey: Uint8Array; // 32 bytes
       };

       export function generateEd25519Keypair(): Ed25519Keypair
       ```
       - Use `ed.utils.randomPrivateKey()` for private key
       - Use `ed.getPublicKey(privateKey)` for public key
       - Return object with both keys as Uint8Array

    4. Create packages/crypto/src/ed25519/index.ts barrel export

  </action>
  <verify>
    - `pnpm install` succeeds
    - `pnpm build` compiles without errors
    - Generated keypairs have correct sizes (32 bytes each)
  </verify>
  <done>
    Ed25519 dependencies installed, keypair generation implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Ed25519 signing and verification</name>
  <files>
    packages/crypto/src/ed25519/sign.ts
    packages/crypto/src/ed25519/index.ts
    packages/crypto/src/__tests__/ed25519.test.ts
  </files>
  <action>
    1. Create packages/crypto/src/ed25519/sign.ts:
       ```typescript
       import * as ed from '@noble/ed25519';

       export async function signEd25519(
         message: Uint8Array,
         privateKey: Uint8Array
       ): Promise<Uint8Array>
       ```
       - Use `ed.signAsync(message, privateKey)` (async for consistency)
       - Validate privateKey is 32 bytes
       - Return 64-byte signature
       - Throw generic CryptoError('Signing failed') on error

       ```typescript
       export async function verifyEd25519(
         signature: Uint8Array,
         message: Uint8Array,
         publicKey: Uint8Array
       ): Promise<boolean>
       ```
       - Use `ed.verifyAsync(signature, message, publicKey)`
       - Validate signature is 64 bytes, publicKey is 32 bytes
       - Return boolean (true if valid, false if invalid)
       - Do NOT throw on invalid signature (return false)

    2. Update packages/crypto/src/ed25519/index.ts to export sign functions

    3. Create packages/crypto/src/__tests__/ed25519.test.ts with vitest:
       - Test: generated keypair has correct sizes (32 bytes each)
       - Test: sign/verify round-trip succeeds
       - Test: verify with wrong public key returns false
       - Test: verify with modified message returns false
       - Test: verify with modified signature returns false
       - Test: validates private key length in sign
       - Test: validates public key length in verify
       - Test: multiple keypairs are unique (randomness)

  </action>
  <verify>
    - `pnpm test` passes all Ed25519 tests
    - Signatures are 64 bytes
    - Verification returns boolean (no exceptions for invalid signatures)
  </verify>
  <done>
    Ed25519 signing and verification works, tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement IPNS record signing utilities</name>
  <files>
    packages/crypto/src/ipns/index.ts
    packages/crypto/src/ipns/sign-record.ts
    packages/crypto/src/index.ts
    packages/crypto/src/__tests__/ipns.test.ts
  </files>
  <action>
    1. Create packages/crypto/src/ipns/sign-record.ts:
       ```typescript
       import { signEd25519 } from '../ed25519';

       // IPNS signature prefix per IPFS spec
       // "ipns-signature:" as bytes
       export const IPNS_SIGNATURE_PREFIX = new Uint8Array([
         0x69, 0x70, 0x6e, 0x73, 0x2d,  // "ipns-"
         0x73, 0x69, 0x67, 0x6e, 0x61,  // "signa"
         0x74, 0x75, 0x72, 0x65, 0x3a   // "ture:"
       ]);

       export async function signIpnsData(
         cborData: Uint8Array,
         privateKey: Uint8Array
       ): Promise<Uint8Array>
       ```
       - Concatenate IPNS_SIGNATURE_PREFIX + cborData
       - Sign concatenated data with Ed25519
       - Return 64-byte signature
       - This follows IPFS IPNS spec: https://specs.ipfs.tech/ipns/ipns-record/

       Note: We only provide signing here. The actual IPNS record marshaling (protobuf + CBOR)
       will be handled by the `ipns` npm package in Phase 5. This function signs the raw data.

    2. Create packages/crypto/src/ipns/index.ts barrel export

    3. Update packages/crypto/src/index.ts to export:
       - All from './ed25519'
       - All from './ipns'
       - Keep existing exports from aes, ecies, utils, types, constants

    4. Create packages/crypto/src/__tests__/ipns.test.ts with vitest:
       - Test: IPNS_SIGNATURE_PREFIX is correct bytes for "ipns-signature:"
       - Test: signIpnsData returns 64-byte signature
       - Test: signIpnsData is verifiable with Ed25519 verify (using prefixed data)
       - Test: same data signed with same key produces same signature (deterministic)
       - Test: different data produces different signature

  </action>
  <verify>
    - `pnpm test` passes all IPNS tests
    - `pnpm build` succeeds
    - Package exports include Ed25519 and IPNS functions
    - Check dist/index.d.ts includes all new exports
  </verify>
  <done>
    IPNS signing utilities work, tests pass, all exports correct.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm -F @cipherbox/crypto test` - All Ed25519 and IPNS tests pass
2. `pnpm -F @cipherbox/crypto build` - Package builds without errors
3. Verify exports in dist/index.d.ts include:
   - generateEd25519Keypair
   - signEd25519
   - verifyEd25519
   - signIpnsData
   - IPNS_SIGNATURE_PREFIX
4. Test manual round-trip:
   ```
   const crypto = require('./packages/crypto/dist')
   const kp = crypto.generateEd25519Keypair()
   const data = new TextEncoder().encode('test data')
   const sig = await crypto.signIpnsData(data, kp.privateKey)
   // sig should be 64 bytes
   ```
</verification>

<success_criteria>

- [ ] Ed25519 keypair generation produces 32-byte keys
- [ ] Ed25519 sign/verify round-trip works
- [ ] IPNS signing uses correct prefix ("ipns-signature:")
- [ ] Verification returns false (not exception) for invalid signatures
- [ ] All tests pass with `pnpm test`
- [ ] Package exports all Ed25519 and IPNS functions
      </success_criteria>

<output>
After completion, create `.planning/phases/03-core-encryption/03-02-SUMMARY.md`
</output>
