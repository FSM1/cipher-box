---
phase: 03-core-encryption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/package.json
  - packages/crypto/src/index.ts
  - packages/crypto/src/types.ts
  - packages/crypto/src/constants.ts
  - packages/crypto/src/aes/index.ts
  - packages/crypto/src/aes/encrypt.ts
  - packages/crypto/src/aes/decrypt.ts
  - packages/crypto/src/ecies/index.ts
  - packages/crypto/src/ecies/encrypt.ts
  - packages/crypto/src/ecies/decrypt.ts
  - packages/crypto/src/utils/index.ts
  - packages/crypto/src/utils/encoding.ts
  - packages/crypto/src/utils/memory.ts
  - packages/crypto/src/utils/random.ts
  - packages/crypto/src/__tests__/aes.test.ts
  - packages/crypto/src/__tests__/ecies.test.ts
autonomous: true

must_haves:
  truths:
    - 'Files encrypt/decrypt correctly with AES-256-GCM (test vectors pass)'
    - 'Keys wrap/unwrap correctly with ECIES secp256k1'
    - 'Each file uses unique random key and IV (no nonce reuse)'
  artifacts:
    - path: 'packages/crypto/src/aes/encrypt.ts'
      provides: 'AES-256-GCM encryption'
      exports: ['encryptAesGcm']
    - path: 'packages/crypto/src/aes/decrypt.ts'
      provides: 'AES-256-GCM decryption'
      exports: ['decryptAesGcm']
    - path: 'packages/crypto/src/ecies/encrypt.ts'
      provides: 'ECIES key wrapping'
      exports: ['wrapKey']
    - path: 'packages/crypto/src/ecies/decrypt.ts'
      provides: 'ECIES key unwrapping'
      exports: ['unwrapKey']
    - path: 'packages/crypto/src/utils/random.ts'
      provides: 'Secure random generation'
      exports: ['generateRandomBytes', 'generateFileKey', 'generateIv']
  key_links:
    - from: 'packages/crypto/src/aes/encrypt.ts'
      to: 'Web Crypto API'
      via: 'crypto.subtle.encrypt'
      pattern: "crypto\\.subtle\\.encrypt.*AES-GCM"
    - from: 'packages/crypto/src/ecies/encrypt.ts'
      to: 'eciesjs'
      via: 'encrypt function'
      pattern: 'import.*encrypt.*from.*eciesjs'
---

<objective>
Implement AES-256-GCM encryption/decryption and ECIES secp256k1 key wrapping in the `@cipherbox/crypto` package.

Purpose: Provides the symmetric and asymmetric encryption primitives required for all file and metadata encryption. AES-256-GCM encrypts file content and folder metadata. ECIES wraps file keys with user's public key so only the owner can decrypt.

Output: Working crypto primitives with tests validating encrypt/decrypt round-trips.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-encryption/03-CONTEXT.md
@.planning/phases/03-core-encryption/03-RESEARCH.md
@packages/crypto/package.json
@packages/crypto/src/index.ts
@apps/web/src/lib/crypto/signatureKeyDerivation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add crypto dependencies and package structure</name>
  <files>
    packages/crypto/package.json
    packages/crypto/src/types.ts
    packages/crypto/src/constants.ts
    packages/crypto/src/utils/index.ts
    packages/crypto/src/utils/encoding.ts
    packages/crypto/src/utils/memory.ts
    packages/crypto/src/utils/random.ts
  </files>
  <action>
    1. Update packages/crypto/package.json to add dependencies:
       - `eciesjs: ^0.4.16` (ECIES encryption)
       - `@noble/hashes: ^1.x` (for SHA-256 if needed)
       - Add `vitest: ^3.x` as devDependency
       - Add test script: `"test": "vitest run"`
       - Add test:watch script: `"test:watch": "vitest"`

    2. Create packages/crypto/src/types.ts with:
       - `VaultKey` type: { publicKey: Uint8Array (65 bytes uncompressed), privateKey: Uint8Array (32 bytes) }
       - `CryptoError` class extending Error with `code` property for categorization
       - Type for encryption result: `EncryptedData = { ciphertext: Uint8Array; iv: Uint8Array }`

    3. Create packages/crypto/src/constants.ts with:
       - `AES_KEY_SIZE = 32` (256 bits)
       - `AES_IV_SIZE = 12` (96 bits for GCM)
       - `AES_TAG_SIZE = 16` (128-bit auth tag)
       - `SECP256K1_PUBLIC_KEY_SIZE = 65` (uncompressed)
       - `SECP256K1_PRIVATE_KEY_SIZE = 32`

    4. Create packages/crypto/src/utils/encoding.ts with:
       - `hexToBytes(hex: string): Uint8Array` - handles 0x prefix
       - `bytesToHex(bytes: Uint8Array): string` - no prefix
       - `concatBytes(...arrays: Uint8Array[]): Uint8Array`
       - Reference existing pattern in signatureKeyDerivation.ts

    5. Create packages/crypto/src/utils/memory.ts with:
       - `clearBytes(data: Uint8Array | null): void` - zeros out buffer (best-effort)
       - Add comment about JavaScript memory clearing limitations

    6. Create packages/crypto/src/utils/random.ts with:
       - `generateRandomBytes(length: number): Uint8Array` - uses crypto.getRandomValues
       - `generateFileKey(): Uint8Array` - returns 32-byte random key
       - `generateIv(): Uint8Array` - returns 12-byte random IV
       - Throw CryptoError if crypto.getRandomValues unavailable

    7. Create packages/crypto/src/utils/index.ts barrel export for all utils

    Use async-first API pattern (all functions return Promise even if implementation is sync).

  </action>
  <verify>
    - `pnpm install` succeeds in packages/crypto
    - `pnpm build` succeeds with new files
    - Types compile without errors
  </verify>
  <done>
    Package dependencies installed, type definitions created, utility functions implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement AES-256-GCM encryption/decryption</name>
  <files>
    packages/crypto/src/aes/index.ts
    packages/crypto/src/aes/encrypt.ts
    packages/crypto/src/aes/decrypt.ts
    packages/crypto/src/__tests__/aes.test.ts
  </files>
  <action>
    1. Create packages/crypto/src/aes/encrypt.ts:
       ```typescript
       export async function encryptAesGcm(
         plaintext: Uint8Array,
         key: Uint8Array,
         iv: Uint8Array
       ): Promise<Uint8Array>
       ```
       - Import CryptoKey using crypto.subtle.importKey('raw', key, { name: 'AES-GCM' }, false, ['encrypt'])
       - Encrypt using crypto.subtle.encrypt({ name: 'AES-GCM', iv }, cryptoKey, plaintext)
       - Return ciphertext + auth tag as single Uint8Array
       - Validate key is 32 bytes, IV is 12 bytes
       - Throw generic CryptoError('Encryption failed') on any error (no oracle attacks)

    2. Create packages/crypto/src/aes/decrypt.ts:
       ```typescript
       export async function decryptAesGcm(
         ciphertext: Uint8Array,
         key: Uint8Array,
         iv: Uint8Array
       ): Promise<Uint8Array>
       ```
       - Import CryptoKey using crypto.subtle.importKey('raw', key, { name: 'AES-GCM' }, false, ['decrypt'])
       - Decrypt using crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cryptoKey, ciphertext)
       - Throw generic CryptoError('Decryption failed') on any error (masks auth tag failures)
       - Validate key is 32 bytes, IV is 12 bytes

    3. Create packages/crypto/src/aes/index.ts barrel export

    4. Create packages/crypto/src/__tests__/aes.test.ts with vitest:
       - Test: encrypt/decrypt round-trip with random data
       - Test: decrypt with wrong key throws
       - Test: decrypt with modified ciphertext throws (auth tag failure)
       - Test: each encryption produces different ciphertext (no IV reuse test)
       - Test: validates key length (reject non-32-byte keys)
       - Test: validates IV length (reject non-12-byte IVs)
       - Test: "Hello, CipherBox!" round-trip (matches DATA_FLOWS.md test vector)

  </action>
  <verify>
    - `pnpm test` passes all AES tests
    - No sensitive information in error messages
  </verify>
  <done>
    AES-256-GCM encrypt/decrypt works, tests pass, errors are generic.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement ECIES key wrapping with eciesjs</name>
  <files>
    packages/crypto/src/ecies/index.ts
    packages/crypto/src/ecies/encrypt.ts
    packages/crypto/src/ecies/decrypt.ts
    packages/crypto/src/index.ts
    packages/crypto/src/__tests__/ecies.test.ts
  </files>
  <action>
    1. Create packages/crypto/src/ecies/encrypt.ts:
       ```typescript
       import { encrypt } from 'eciesjs';

       export async function wrapKey(
         key: Uint8Array,
         recipientPublicKey: Uint8Array
       ): Promise<Uint8Array>
       ```
       - Use eciesjs encrypt function
       - Validate recipientPublicKey is 65 bytes (uncompressed secp256k1)
       - Throw generic CryptoError('Key wrapping failed') on any error
       - Make function async for API consistency even though eciesjs is sync

    2. Create packages/crypto/src/ecies/decrypt.ts:
       ```typescript
       import { decrypt } from 'eciesjs';

       export async function unwrapKey(
         wrappedKey: Uint8Array,
         privateKey: Uint8Array
       ): Promise<Uint8Array>
       ```
       - Use eciesjs decrypt function
       - Validate privateKey is 32 bytes
       - Throw generic CryptoError('Key unwrapping failed') on any error

    3. Create packages/crypto/src/ecies/index.ts barrel export

    4. Update packages/crypto/src/index.ts to export all public APIs:
       - Export all from './aes'
       - Export all from './ecies'
       - Export all from './utils' (only safe functions)
       - Export types from './types'
       - Export constants from './constants'
       - Update CRYPTO_VERSION to '0.1.0'

    5. Create packages/crypto/src/__tests__/ecies.test.ts with vitest:
       - Test: wrap/unwrap round-trip recovers original 32-byte key
       - Test: unwrap with wrong private key throws
       - Test: validates public key length (reject non-65-byte)
       - Test: validates private key length (reject non-32-byte)
       - Test: same key wrapped multiple times produces different ciphertext (ephemeral key)
       - Use @noble/secp256k1 to generate test keypairs (already in project)

  </action>
  <verify>
    - `pnpm test` passes all ECIES tests
    - `pnpm build` produces valid dist output
    - Package exports are correct (check dist/index.d.ts)
  </verify>
  <done>
    ECIES wrap/unwrap works, tests pass, package exports all crypto primitives.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm -F @cipherbox/crypto test` - All crypto tests pass
2. `pnpm -F @cipherbox/crypto build` - Package builds without errors
3. Test round-trip manually in Node REPL if needed:
   ```
   const crypto = require('./packages/crypto/dist')
   const key = crypto.generateFileKey()
   const iv = crypto.generateIv()
   const data = new TextEncoder().encode('test')
   const enc = await crypto.encryptAesGcm(data, key, iv)
   const dec = await crypto.decryptAesGcm(enc, key, iv)
   new TextDecoder().decode(dec) === 'test'
   ```
</verification>

<success_criteria>

- [ ] AES-256-GCM encrypt/decrypt round-trip works
- [ ] ECIES wrap/unwrap round-trip works
- [ ] Tests validate error cases (wrong key, modified ciphertext)
- [ ] Error messages are generic (no oracle attack vectors)
- [ ] Random key/IV generation uses crypto.getRandomValues
- [ ] Package exports all necessary functions
- [ ] All tests pass with `pnpm test`
      </success_criteria>

<output>
After completion, create `.planning/phases/03-core-encryption/03-01-SUMMARY.md`
</output>
