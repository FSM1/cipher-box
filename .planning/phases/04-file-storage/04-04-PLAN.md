---
phase: 04-file-storage
plan: 04
type: execute
wave: 3
depends_on: ['04-01', '04-03']
files_modified:
  - apps/web/src/services/download.service.ts
  - apps/web/src/stores/download.store.ts
  - apps/web/src/hooks/useFileDownload.ts
  - apps/web/src/lib/api/ipfs.ts
  - apps/web/src/services/delete.service.ts
  - apps/web/src/hooks/useFileDelete.ts
autonomous: true

must_haves:
  truths:
    - 'User can download encrypted file from IPFS and decrypt it'
    - 'User sees progress indicator during download'
    - 'Decrypted file triggers browser Save As dialog'
    - 'Original filename preserved from metadata'
  artifacts:
    - path: 'apps/web/src/services/download.service.ts'
      provides: 'File download and decryption orchestration'
      exports: ['downloadFile']
    - path: 'apps/web/src/stores/download.store.ts'
      provides: 'Download progress state management'
      exports: ['useDownloadStore']
    - path: 'apps/web/src/hooks/useFileDownload.ts'
      provides: 'React hook for file download'
      exports: ['useFileDownload']
  key_links:
    - from: 'apps/web/src/services/download.service.ts'
      to: '@cipherbox/crypto'
      via: 'import decryptAesGcm, unwrapKey'
      pattern: "from '@cipherbox/crypto'"
    - from: 'apps/web/src/services/download.service.ts'
      to: 'Pinata gateway'
      via: 'fetch from gateway URL'
      pattern: 'gateway.pinata.cloud'
---

<objective>
Create frontend file download with decryption, progress tracking, and browser download trigger.

Purpose: Enable users to download encrypted files from IPFS, decrypt them client-side, and save to their device.
Output: Download service with decryption, progress store, and useFileDownload hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-file-storage/04-CONTEXT.md
@.planning/phases/04-file-storage/04-RESEARCH.md

# Prior plan summaries (when available)

# @.planning/phases/04-file-storage/04-01-SUMMARY.md

# @.planning/phases/04-file-storage/04-03-SUMMARY.md

# Crypto package exports

@packages/crypto/src/index.ts

# Upload service for file metadata type

@apps/web/src/services/upload.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create download service with decryption</name>
  <files>
    apps/web/src/services/download.service.ts
    apps/web/src/lib/api/ipfs.ts
  </files>
  <action>
    1. Add gateway fetch to IPFS client (apps/web/src/lib/api/ipfs.ts):
       ```typescript
       // Add this function to existing ipfs.ts file

       // Pinata gateway URL from environment
       const GATEWAY_URL = import.meta.env.VITE_PINATA_GATEWAY_URL || 'https://gateway.pinata.cloud/ipfs';

       export type DownloadProgressCallback = (loaded: number, total: number) => void;

       export async function fetchFromIpfs(
         cid: string,
         onProgress?: DownloadProgressCallback
       ): Promise<Uint8Array> {
         const response = await fetch(`${GATEWAY_URL}/${cid}`);

         if (!response.ok) {
           throw new Error(`Failed to fetch from IPFS: ${response.status}`);
         }

         // If no progress callback or no content-length, just return arrayBuffer
         const contentLength = response.headers.get('Content-Length');
         if (!onProgress || !contentLength) {
           const buffer = await response.arrayBuffer();
           return new Uint8Array(buffer);
         }

         // Stream with progress
         const total = parseInt(contentLength, 10);
         const reader = response.body?.getReader();
         if (!reader) {
           throw new Error('ReadableStream not supported');
         }

         const chunks: Uint8Array[] = [];
         let loaded = 0;

         while (true) {
           const { done, value } = await reader.read();
           if (done) break;

           chunks.push(value);
           loaded += value.length;
           onProgress(loaded, total);
         }

         // Combine chunks
         const result = new Uint8Array(loaded);
         let offset = 0;
         for (const chunk of chunks) {
           result.set(chunk, offset);
           offset += chunk.length;
         }

         return result;
       }
       ```

    2. Create download service (apps/web/src/services/download.service.ts):
       ```typescript
       import {
         decryptAesGcm,
         unwrapKey,
         hexToBytes,
         clearBytes,
       } from '@cipherbox/crypto';
       import { fetchFromIpfs, DownloadProgressCallback } from '../lib/api/ipfs';
       import { UploadedFile } from './upload.service';

       /**
        * File metadata required for download and decryption.
        * This matches the UploadedFile type but only needs the fields for download.
        */
       export type FileMetadata = Pick<UploadedFile, 'cid' | 'iv' | 'wrappedKey' | 'originalName'>;

       /**
        * Downloads and decrypts a file from IPFS.
        *
        * @param metadata - File metadata containing CID, IV, and wrapped key
        * @param privateKey - User's private key for unwrapping the file key
        * @param onProgress - Optional progress callback (loaded, total bytes)
        * @returns Decrypted file content
        */
       export async function downloadFile(
         metadata: FileMetadata,
         privateKey: Uint8Array,
         onProgress?: DownloadProgressCallback
       ): Promise<Uint8Array> {
         // 1. Fetch encrypted file from IPFS
         const ciphertext = await fetchFromIpfs(metadata.cid, onProgress);

         // 2. Convert hex strings to bytes
         const iv = hexToBytes(metadata.iv);
         const wrappedKey = hexToBytes(metadata.wrappedKey);

         // 3. Unwrap file key using user's private key
         const fileKey = await unwrapKey(wrappedKey, privateKey);

         try {
           // 4. Decrypt file content
           const plaintext = await decryptAesGcm(ciphertext, fileKey, iv);
           return plaintext;
         } finally {
           // 5. Clear file key from memory
           clearBytes(fileKey);
         }
       }

       /**
        * Triggers browser download dialog for decrypted content.
        *
        * @param content - Decrypted file content
        * @param filename - Original filename
        * @param mimeType - Optional MIME type (defaults to octet-stream)
        */
       export function triggerBrowserDownload(
         content: Uint8Array,
         filename: string,
         mimeType: string = 'application/octet-stream'
       ): void {
         const blob = new Blob([content], { type: mimeType });
         const url = URL.createObjectURL(blob);

         const link = document.createElement('a');
         link.href = url;
         link.download = filename;
         document.body.appendChild(link);
         link.click();
         document.body.removeChild(link);

         // Clean up blob URL
         URL.revokeObjectURL(url);
       }

       /**
        * Downloads, decrypts, and triggers browser download for a file.
        *
        * @param metadata - File metadata
        * @param privateKey - User's private key
        * @param onProgress - Optional progress callback
        */
       export async function downloadAndSaveFile(
         metadata: FileMetadata,
         privateKey: Uint8Array,
         onProgress?: DownloadProgressCallback
       ): Promise<void> {
         const plaintext = await downloadFile(metadata, privateKey, onProgress);
         triggerBrowserDownload(plaintext, metadata.originalName);
       }
       ```

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/web build` compiles without errors
  </verify>
  <done>
    download.service.ts exports downloadFile, triggerBrowserDownload, downloadAndSaveFile using @cipherbox/crypto
  </done>
</task>

<task type="auto">
  <name>Task 2: Create download store and useFileDownload hook</name>
  <files>
    apps/web/src/stores/download.store.ts
    apps/web/src/hooks/useFileDownload.ts
  </files>
  <action>
    1. Create download store (apps/web/src/stores/download.store.ts):
       ```typescript
       import { create } from 'zustand';

       type DownloadStatus = 'idle' | 'downloading' | 'decrypting' | 'success' | 'error';

       type DownloadState = {
         status: DownloadStatus;
         progress: number;      // 0-100
         loadedBytes: number;
         totalBytes: number;
         currentFile: string | null;
         error: string | null;

         startDownload: (filename: string) => void;
         setProgress: (loaded: number, total: number) => void;
         setDecrypting: () => void;
         setSuccess: () => void;
         setError: (error: string) => void;
         reset: () => void;
       };

       export const useDownloadStore = create<DownloadState>((set) => ({
         status: 'idle',
         progress: 0,
         loadedBytes: 0,
         totalBytes: 0,
         currentFile: null,
         error: null,

         startDownload: (filename) => set({
           status: 'downloading',
           progress: 0,
           loadedBytes: 0,
           totalBytes: 0,
           currentFile: filename,
           error: null,
         }),

         setProgress: (loaded, total) => {
           const progress = total > 0 ? Math.round((loaded * 100) / total) : 0;
           set({ loadedBytes: loaded, totalBytes: total, progress });
         },

         setDecrypting: () => set({ status: 'decrypting' }),

         setSuccess: () => set({
           status: 'success',
           progress: 100,
           currentFile: null,
         }),

         setError: (error) => set({
           status: 'error',
           error,
           currentFile: null,
         }),

         reset: () => set({
           status: 'idle',
           progress: 0,
           loadedBytes: 0,
           totalBytes: 0,
           currentFile: null,
           error: null,
         }),
       }));
       ```

    2. Create useFileDownload hook (apps/web/src/hooks/useFileDownload.ts):
       ```typescript
       import { useCallback } from 'react';
       import { downloadAndSaveFile, FileMetadata } from '../services/download.service';
       import { useDownloadStore } from '../stores/download.store';
       import { useAuthStore } from '../stores/auth.store';

       export function useFileDownload() {
         const {
           status,
           progress,
           loadedBytes,
           totalBytes,
           currentFile,
           error,
           startDownload,
           setProgress,
           setDecrypting,
           setSuccess,
           setError,
           reset,
         } = useDownloadStore();

         const { derivedKeypair } = useAuthStore();

         const download = useCallback(
           async (metadata: FileMetadata): Promise<void> => {
             if (!derivedKeypair) {
               throw new Error('No keypair available - please log in again');
             }

             try {
               startDownload(metadata.originalName);

               // Download with progress tracking
               await downloadAndSaveFile(
                 metadata,
                 derivedKeypair.privateKey,
                 (loaded, total) => {
                   setProgress(loaded, total);
                 }
               );

               setDecrypting();

               // Small delay for UX - show decrypting state
               await new Promise((resolve) => setTimeout(resolve, 100));

               setSuccess();
             } catch (err) {
               const message = (err as Error).message || 'Download failed';
               setError(message);
               console.error('Download failed:', err);
               throw err;
             }
           },
           [derivedKeypair, startDownload, setProgress, setDecrypting, setSuccess, setError]
         );

         return {
           // State
           status,
           progress,
           loadedBytes,
           totalBytes,
           currentFile,
           error,
           isDownloading: status === 'downloading' || status === 'decrypting',

           // Actions
           download,
           reset,
         };
       }
       ```

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/web build` compiles without errors
  </verify>
  <done>
    Download store tracks progress, useFileDownload hook provides unified download interface
  </done>
</task>

<task type="auto">
  <name>Task 3: Add delete file functionality</name>
  <files>
    apps/web/src/services/delete.service.ts
    apps/web/src/hooks/useFileDelete.ts
  </files>
  <action>
    1. Create delete service (apps/web/src/services/delete.service.ts):
       ```typescript
       import { unpinFromIpfs } from '../lib/api/ipfs';
       import { useQuotaStore } from '../stores/quota.store';

       /**
        * Deletes a file by unpinning from IPFS and updating quota.
        *
        * @param cid - CID of the file to delete
        * @param sizeBytes - Size of the file (for quota update)
        */
       export async function deleteFile(cid: string, sizeBytes: number): Promise<void> {
         // 1. Unpin from IPFS via backend
         await unpinFromIpfs(cid);

         // 2. Update local quota
         const quotaStore = useQuotaStore.getState();
         quotaStore.removeUsage(sizeBytes);
       }

       /**
        * Deletes multiple files by unpinning from IPFS.
        *
        * @param files - Array of { cid, size } objects
        */
       export async function deleteFiles(
         files: Array<{ cid: string; size: number }>
       ): Promise<{ succeeded: string[]; failed: string[] }> {
         const succeeded: string[] = [];
         const failed: string[] = [];

         for (const file of files) {
           try {
             await deleteFile(file.cid, file.size);
             succeeded.push(file.cid);
           } catch (error) {
             console.error(`Failed to delete ${file.cid}:`, error);
             failed.push(file.cid);
           }
         }

         return { succeeded, failed };
       }
       ```

    2. Create useFileDelete hook (apps/web/src/hooks/useFileDelete.ts):
       ```typescript
       import { useCallback, useState } from 'react';
       import { deleteFile, deleteFiles } from '../services/delete.service';

       export function useFileDelete() {
         const [isDeleting, setIsDeleting] = useState(false);
         const [error, setError] = useState<string | null>(null);

         const deleteSingle = useCallback(
           async (cid: string, sizeBytes: number): Promise<void> => {
             setIsDeleting(true);
             setError(null);

             try {
               await deleteFile(cid, sizeBytes);
             } catch (err) {
               const message = (err as Error).message || 'Delete failed';
               setError(message);
               throw err;
             } finally {
               setIsDeleting(false);
             }
           },
           []
         );

         const deleteMultiple = useCallback(
           async (
             files: Array<{ cid: string; size: number }>
           ): Promise<{ succeeded: string[]; failed: string[] }> => {
             setIsDeleting(true);
             setError(null);

             try {
               const result = await deleteFiles(files);
               if (result.failed.length > 0) {
                 setError(`Failed to delete ${result.failed.length} file(s)`);
               }
               return result;
             } finally {
               setIsDeleting(false);
             }
           },
           []
         );

         return {
           isDeleting,
           error,
           deleteFile: deleteSingle,
           deleteFiles: deleteMultiple,
           clearError: () => setError(null),
         };
       }
       ```

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/web build` compiles without errors
  </verify>
  <done>
    Delete service unpins files and updates quota, useFileDelete hook provides single and bulk delete
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `pnpm -F @cipherbox/web build`
2. Imports resolve: @cipherbox/crypto imports work
3. Stores initialize: downloadStore can be used
4. Hooks compile: useFileDownload and useFileDelete return expected interface
</verification>

<success_criteria>

- download.service.ts fetches from IPFS gateway, decrypts using @cipherbox/crypto
- download.store.ts tracks download progress (loaded/total bytes, status)
- useFileDownload hook provides unified download interface
- triggerBrowserDownload opens Save As dialog with original filename
- delete.service.ts calls /ipfs/unpin and updates quota store
- useFileDelete hook supports single and bulk delete
- Progress shown during download for larger files
- Decryption clears file key from memory after use
  </success_criteria>

<output>
After completion, create `.planning/phases/04-file-storage/04-04-SUMMARY.md`
</output>
