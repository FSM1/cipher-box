---
phase: 04-file-storage
plan: 03
type: execute
wave: 2
depends_on: ['04-01', '04-02']
files_modified:
  - apps/web/src/services/upload.service.ts
  - apps/web/src/services/file-crypto.service.ts
  - apps/web/src/stores/quota.store.ts
  - apps/web/src/stores/upload.store.ts
  - apps/web/src/hooks/useFileUpload.ts
  - apps/web/src/lib/api/vault.ts
  - apps/web/src/lib/api/ipfs.ts
  - apps/web/package.json
autonomous: true

must_haves:
  truths:
    - 'User can select file(s) and upload them encrypted to IPFS'
    - 'User sees batch progress bar during upload'
    - 'Upload auto-retries 3 times on failure'
    - 'Quota exceeded shows clear error message before upload'
    - 'Cancel button aborts in-flight upload'
  artifacts:
    - path: 'apps/web/src/services/upload.service.ts'
      provides: 'File upload orchestration with retry'
      exports: ['uploadFile', 'uploadFiles']
    - path: 'apps/web/src/services/file-crypto.service.ts'
      provides: 'Client-side file encryption using @cipherbox/crypto'
      exports: ['encryptFile']
    - path: 'apps/web/src/stores/quota.store.ts'
      provides: 'Storage quota state management'
      exports: ['useQuotaStore']
    - path: 'apps/web/src/stores/upload.store.ts'
      provides: 'Upload progress state management'
      exports: ['useUploadStore']
    - path: 'apps/web/src/hooks/useFileUpload.ts'
      provides: 'React hook for file upload with progress'
      exports: ['useFileUpload']
  key_links:
    - from: 'apps/web/src/services/upload.service.ts'
      to: 'apps/web/src/services/file-crypto.service.ts'
      via: 'import encryptFile'
      pattern: 'encryptFile.*file-crypto'
    - from: 'apps/web/src/services/file-crypto.service.ts'
      to: '@cipherbox/crypto'
      via: 'import from package'
      pattern: "from '@cipherbox/crypto'"
    - from: 'apps/web/src/services/upload.service.ts'
      to: '/api/ipfs/add'
      via: 'axios POST'
      pattern: '/ipfs/add'
---

<objective>
Create frontend file upload with client-side encryption, progress tracking, and quota management.

Purpose: Enable users to upload files encrypted client-side with progress feedback, retry logic, and quota enforcement.
Output: Upload service with encryption, progress store, quota store, and useFileUpload hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-file-storage/04-CONTEXT.md
@.planning/phases/04-file-storage/04-RESEARCH.md

# Prior plan summaries (when available)

# @.planning/phases/04-file-storage/04-01-SUMMARY.md

# @.planning/phases/04-file-storage/04-02-SUMMARY.md

# Crypto package exports

@packages/crypto/src/index.ts

# Existing frontend structure

@apps/web/src/stores/auth.store.ts
@apps/web/src/api/custom-instance.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file encryption service using @cipherbox/crypto</name>
  <files>
    apps/web/src/services/file-crypto.service.ts
  </files>
  <action>
    1. Create file-crypto.service.ts (apps/web/src/services/file-crypto.service.ts):

       ```typescript
       import {
         generateFileKey,
         generateIv,
         encryptAesGcm,
         wrapKey,
         clearBytes,
         bytesToHex,
       } from '@cipherbox/crypto';

       export type EncryptedFileResult = {
         ciphertext: Uint8Array;
         iv: string;           // hex-encoded for API
         wrappedKey: string;   // hex-encoded for storage
         originalSize: number;
         encryptedSize: number;
       };

       export async function encryptFile(
         file: File,
         userPublicKey: Uint8Array
       ): Promise<EncryptedFileResult> {
         // 1. Generate unique file key and IV
         const fileKey = generateFileKey();
         const iv = generateIv();

         // 2. Read file as ArrayBuffer
         const plaintext = new Uint8Array(await file.arrayBuffer());
         const originalSize = plaintext.length;

         // 3. Encrypt with AES-256-GCM
         const ciphertext = await encryptAesGcm(plaintext, fileKey, iv);

         // 4. Wrap file key with user's public key (ECIES)
         const wrappedKey = await wrapKey(fileKey, userPublicKey);

         // 5. Clear sensitive key from memory
         clearBytes(fileKey);

         return {
           ciphertext,
           iv: bytesToHex(iv),
           wrappedKey: bytesToHex(wrappedKey),
           originalSize,
           encryptedSize: ciphertext.length,
         };
       }
       ```

    2. Export type for use by upload service

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/web build` compiles without errors
  </verify>
  <done>
    file-crypto.service.ts exports encryptFile function using @cipherbox/crypto
  </done>
</task>

<task type="auto">
  <name>Task 2: Create quota and upload stores with API client</name>
  <files>
    apps/web/src/stores/quota.store.ts
    apps/web/src/stores/upload.store.ts
    apps/web/src/lib/api/vault.ts
    apps/web/src/lib/api/ipfs.ts
    apps/web/package.json
  </files>
  <action>
    1. Install axios for upload progress: `cd apps/web && pnpm add axios`

    2. Create vault API client (apps/web/src/lib/api/vault.ts):
       ```typescript
       import { useAuthStore } from '../../stores/auth.store';

       const BASE_URL = '/api';

       export type QuotaResponse = {
         usedBytes: number;
         limitBytes: number;
         remainingBytes: number;
       };

       export async function getQuota(): Promise<QuotaResponse> {
         const { accessToken } = useAuthStore.getState();
         const response = await fetch(`${BASE_URL}/vault/quota`, {
           headers: { Authorization: `Bearer ${accessToken}` },
         });
         if (!response.ok) throw new Error('Failed to fetch quota');
         return response.json();
       }

       export async function initVault(dto: {
         ownerPublicKey: string;
         encryptedRootFolderKey: string;
         encryptedRootIpnsPrivateKey: string;
         rootIpnsName: string;
       }) {
         const { accessToken } = useAuthStore.getState();
         const response = await fetch(`${BASE_URL}/vault/init`, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             Authorization: `Bearer ${accessToken}`,
           },
           body: JSON.stringify(dto),
         });
         if (!response.ok) throw new Error('Failed to init vault');
         return response.json();
       }
       ```

    3. Create IPFS API client (apps/web/src/lib/api/ipfs.ts):
       ```typescript
       import axios, { AxiosProgressEvent, CancelToken } from 'axios';
       import { useAuthStore } from '../../stores/auth.store';

       const BASE_URL = '/api';

       export type AddResponse = { cid: string; size: number };

       export async function addToIpfs(
         encryptedFile: Blob,
         onProgress?: (percent: number) => void,
         cancelToken?: CancelToken
       ): Promise<AddResponse> {
         const { accessToken } = useAuthStore.getState();

         const formData = new FormData();
         formData.append('file', encryptedFile);

         const response = await axios.post<AddResponse>(
           `${BASE_URL}/ipfs/add`,
           formData,
           {
             headers: { Authorization: `Bearer ${accessToken}` },
             onUploadProgress: (event: AxiosProgressEvent) => {
               if (event.total && onProgress) {
                 const percent = Math.round((event.loaded * 100) / event.total);
                 onProgress(percent);
               }
             },
             cancelToken,
           }
         );

         return response.data;
       }

       export async function unpinFromIpfs(cid: string): Promise<void> {
         const { accessToken } = useAuthStore.getState();
         await axios.post(
           `${BASE_URL}/ipfs/unpin`,
           { cid },
           { headers: { Authorization: `Bearer ${accessToken}` } }
         );
       }
       ```

    4. Create quota store (apps/web/src/stores/quota.store.ts):
       ```typescript
       import { create } from 'zustand';
       import { getQuota, QuotaResponse } from '../lib/api/vault';

       type QuotaState = {
         usedBytes: number;
         limitBytes: number;
         remainingBytes: number;
         loading: boolean;
         error: string | null;

         fetchQuota: () => Promise<void>;
         addUsage: (bytes: number) => void;
         removeUsage: (bytes: number) => void;
         canUpload: (bytes: number) => boolean;
       };

       export const useQuotaStore = create<QuotaState>((set, get) => ({
         usedBytes: 0,
         limitBytes: 500 * 1024 * 1024, // 500 MiB
         remainingBytes: 500 * 1024 * 1024,
         loading: false,
         error: null,

         fetchQuota: async () => {
           set({ loading: true, error: null });
           try {
             const quota = await getQuota();
             set({
               usedBytes: quota.usedBytes,
               limitBytes: quota.limitBytes,
               remainingBytes: quota.remainingBytes,
               loading: false,
             });
           } catch (e) {
             set({ error: 'Failed to fetch quota', loading: false });
           }
         },

         addUsage: (bytes) => set((state) => ({
           usedBytes: state.usedBytes + bytes,
           remainingBytes: state.remainingBytes - bytes,
         })),

         removeUsage: (bytes) => set((state) => ({
           usedBytes: Math.max(0, state.usedBytes - bytes),
           remainingBytes: Math.min(state.limitBytes, state.remainingBytes + bytes),
         })),

         canUpload: (bytes) => {
           const { remainingBytes } = get();
           return bytes <= remainingBytes;
         },
       }));
       ```

    5. Create upload store (apps/web/src/stores/upload.store.ts):
       ```typescript
       import { create } from 'zustand';
       import axios from 'axios';

       type UploadStatus = 'idle' | 'encrypting' | 'uploading' | 'success' | 'error' | 'cancelled';

       type UploadState = {
         status: UploadStatus;
         progress: number;          // 0-100 for current batch
         currentFile: string | null;
         totalFiles: number;
         completedFiles: number;
         error: string | null;
         cancelSource: ReturnType<typeof axios.CancelToken.source> | null;

         startUpload: (totalFiles: number) => void;
         setEncrypting: (filename: string) => void;
         setUploading: (filename: string, progress: number) => void;
         fileComplete: () => void;
         setSuccess: () => void;
         setError: (error: string) => void;
         cancel: () => void;
         reset: () => void;
       };

       export const useUploadStore = create<UploadState>((set, get) => ({
         status: 'idle',
         progress: 0,
         currentFile: null,
         totalFiles: 0,
         completedFiles: 0,
         error: null,
         cancelSource: null,

         startUpload: (totalFiles) => set({
           status: 'encrypting',
           progress: 0,
           totalFiles,
           completedFiles: 0,
           error: null,
           cancelSource: axios.CancelToken.source(),
         }),

         setEncrypting: (filename) => set({ status: 'encrypting', currentFile: filename }),

         setUploading: (filename, progress) => {
           const { completedFiles, totalFiles } = get();
           const baseProgress = (completedFiles / totalFiles) * 100;
           const fileProgress = (progress / totalFiles);
           set({
             status: 'uploading',
             currentFile: filename,
             progress: Math.round(baseProgress + fileProgress),
           });
         },

         fileComplete: () => set((state) => ({
           completedFiles: state.completedFiles + 1,
           progress: Math.round(((state.completedFiles + 1) / state.totalFiles) * 100),
         })),

         setSuccess: () => set({ status: 'success', progress: 100, currentFile: null }),
         setError: (error) => set({ status: 'error', error, currentFile: null }),

         cancel: () => {
           const { cancelSource } = get();
           if (cancelSource) {
             cancelSource.cancel('Upload cancelled by user');
           }
           set({ status: 'cancelled', currentFile: null });
         },

         reset: () => set({
           status: 'idle',
           progress: 0,
           currentFile: null,
           totalFiles: 0,
           completedFiles: 0,
           error: null,
           cancelSource: null,
         }),
       }));
       ```

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/web build` compiles without errors
  </verify>
  <done>
    Quota store tracks usage, upload store tracks progress, API clients for vault and IPFS exist
  </done>
</task>

<task type="auto">
  <name>Task 3: Create upload service with retry logic and useFileUpload hook</name>
  <files>
    apps/web/src/services/upload.service.ts
    apps/web/src/hooks/useFileUpload.ts
  </files>
  <action>
    1. Create upload service (apps/web/src/services/upload.service.ts):
       ```typescript
       import { encryptFile, EncryptedFileResult } from './file-crypto.service';
       import { addToIpfs, AddResponse } from '../lib/api/ipfs';
       import { useQuotaStore } from '../stores/quota.store';
       import { useUploadStore } from '../stores/upload.store';
       import { CancelToken } from 'axios';

       const MAX_RETRIES = 3;
       const RETRY_BASE_DELAY = 1000; // 1 second

       export type UploadedFile = {
         cid: string;
         size: number;
         iv: string;
         wrappedKey: string;
         originalName: string;
         originalSize: number;
       };

       async function withRetry<T>(
         fn: () => Promise<T>,
         maxRetries: number = MAX_RETRIES,
         baseDelay: number = RETRY_BASE_DELAY
       ): Promise<T> {
         let lastError: Error;

         for (let attempt = 0; attempt < maxRetries; attempt++) {
           try {
             return await fn();
           } catch (error) {
             lastError = error as Error;
             // Don't retry if cancelled
             if ((error as Error).message === 'Upload cancelled by user') {
               throw error;
             }
             if (attempt < maxRetries - 1) {
               const delay = baseDelay * Math.pow(2, attempt);
               await new Promise((resolve) => setTimeout(resolve, delay));
             }
           }
         }

         throw lastError!;
       }

       export async function uploadFile(
         file: File,
         userPublicKey: Uint8Array,
         onProgress?: (percent: number) => void,
         cancelToken?: CancelToken
       ): Promise<UploadedFile> {
         // 1. Encrypt the file
         const encrypted = await encryptFile(file, userPublicKey);

         // 2. Upload to IPFS with retry
         const blob = new Blob([encrypted.ciphertext], { type: 'application/octet-stream' });
         const result = await withRetry(() =>
           addToIpfs(blob, onProgress, cancelToken)
         );

         return {
           cid: result.cid,
           size: result.size,
           iv: encrypted.iv,
           wrappedKey: encrypted.wrappedKey,
           originalName: file.name,
           originalSize: encrypted.originalSize,
         };
       }

       export async function uploadFiles(
         files: File[],
         userPublicKey: Uint8Array
       ): Promise<UploadedFile[]> {
         const uploadStore = useUploadStore.getState();
         const quotaStore = useQuotaStore.getState();

         // Calculate total size
         const totalSize = files.reduce((sum, f) => sum + f.size, 0);

         // Pre-check quota
         if (!quotaStore.canUpload(totalSize)) {
           throw new Error(
             `Not enough space (${Math.round(quotaStore.usedBytes / 1024 / 1024)} of ${Math.round(quotaStore.limitBytes / 1024 / 1024)}MB used)`
           );
         }

         uploadStore.startUpload(files.length);
         const results: UploadedFile[] = [];

         try {
           // Sequential uploads per CONTEXT.md decision
           for (const file of files) {
             const cancelSource = useUploadStore.getState().cancelSource;
             if (useUploadStore.getState().status === 'cancelled') {
               throw new Error('Upload cancelled by user');
             }

             uploadStore.setEncrypting(file.name);

             const result = await uploadFile(
               file,
               userPublicKey,
               (percent) => uploadStore.setUploading(file.name, percent),
               cancelSource?.token
             );

             results.push(result);
             uploadStore.fileComplete();
             quotaStore.addUsage(result.size);
           }

           uploadStore.setSuccess();
           return results;
         } catch (error) {
           const message = (error as Error).message;
           if (message !== 'Upload cancelled by user') {
             uploadStore.setError(message);
             console.error('Upload failed:', error);
           }
           throw error;
         }
       }
       ```

    2. Create useFileUpload hook (apps/web/src/hooks/useFileUpload.ts):
       ```typescript
       import { useCallback } from 'react';
       import { uploadFiles, UploadedFile } from '../services/upload.service';
       import { useUploadStore } from '../stores/upload.store';
       import { useQuotaStore } from '../stores/quota.store';
       import { useAuthStore } from '../stores/auth.store';

       export function useFileUpload() {
         const {
           status,
           progress,
           currentFile,
           totalFiles,
           completedFiles,
           error,
           cancel,
           reset,
         } = useUploadStore();

         const { usedBytes, limitBytes, remainingBytes, canUpload, fetchQuota } = useQuotaStore();
         const { derivedKeypair } = useAuthStore();

         const upload = useCallback(
           async (files: File[]): Promise<UploadedFile[]> => {
             if (!derivedKeypair) {
               throw new Error('No keypair available - please log in again');
             }

             // Refresh quota before upload
             await fetchQuota();

             return uploadFiles(files, derivedKeypair.publicKey);
           },
           [derivedKeypair, fetchQuota]
         );

         return {
           // State
           status,
           progress,
           currentFile,
           totalFiles,
           completedFiles,
           error,
           isUploading: status === 'encrypting' || status === 'uploading',

           // Quota
           usedBytes,
           limitBytes,
           remainingBytes,
           canUpload,

           // Actions
           upload,
           cancel,
           reset,
         };
       }
       ```

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/web build` compiles without errors
  </verify>
  <done>
    Upload service with retry logic and useFileUpload hook exist, supporting batch uploads with progress
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `pnpm -F @cipherbox/web build`
2. Imports resolve: @cipherbox/crypto imports work
3. Stores initialize: quotaStore and uploadStore can be used
4. Hook compiles: useFileUpload returns expected interface
</verification>

<success_criteria>

- file-crypto.service.ts encrypts files using @cipherbox/crypto package
- upload.service.ts handles single and batch uploads with retry (3 attempts, exponential backoff)
- quota.store.ts tracks used/limit/remaining bytes
- upload.store.ts tracks progress, status, current file
- useFileUpload hook provides unified upload interface
- Quota check happens before upload starts
- Cancel aborts in-flight upload via axios CancelToken
- Sequential uploads (one file at a time) per CONTEXT.md decision
  </success_criteria>

<output>
After completion, create `.planning/phases/04-file-storage/04-03-SUMMARY.md`
</output>
