---
phase: 04-file-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/ipfs/ipfs.module.ts
  - apps/api/src/ipfs/ipfs.controller.ts
  - apps/api/src/ipfs/ipfs.service.ts
  - apps/api/src/ipfs/dto/add.dto.ts
  - apps/api/src/ipfs/dto/unpin.dto.ts
  - apps/api/src/ipfs/dto/index.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - 'Authenticated user can POST encrypted blob to /ipfs/add and receive CID'
    - 'Authenticated user can POST CID to /ipfs/unpin and CID is removed from Pinata'
    - 'Unauthenticated requests return 401'
    - 'Files larger than 100MB are rejected with 413'
  artifacts:
    - path: 'apps/api/src/ipfs/ipfs.module.ts'
      provides: 'IpfsModule with controller and service'
      exports: ['IpfsModule']
    - path: 'apps/api/src/ipfs/ipfs.controller.ts'
      provides: '/ipfs/add and /ipfs/unpin endpoints'
      exports: ['IpfsController']
    - path: 'apps/api/src/ipfs/ipfs.service.ts'
      provides: 'Pinata API client for pin/unpin'
      exports: ['IpfsService']
  key_links:
    - from: 'apps/api/src/ipfs/ipfs.controller.ts'
      to: 'apps/api/src/ipfs/ipfs.service.ts'
      via: 'NestJS dependency injection'
      pattern: 'constructor.*IpfsService'
    - from: 'apps/api/src/ipfs/ipfs.service.ts'
      to: 'https://api.pinata.cloud'
      via: 'fetch with Bearer token'
      pattern: 'api.pinata.cloud'
    - from: 'apps/api/src/app.module.ts'
      to: 'apps/api/src/ipfs/ipfs.module.ts'
      via: 'imports array'
      pattern: 'IpfsModule'
---

<objective>
Create backend IPFS relay endpoints for adding and unpinning encrypted blobs via Pinata.

Purpose: Enable the frontend to upload encrypted files to IPFS and remove them when deleted, without exposing Pinata credentials to the client.
Output: Two API endpoints (/ipfs/add, /ipfs/unpin) that proxy to Pinata's pinning API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-file-storage/04-CONTEXT.md
@.planning/phases/04-file-storage/04-RESEARCH.md

# Prior phase context

@.planning/phases/03-core-encryption/03-03-SUMMARY.md

# Existing backend structure

@apps/api/src/app.module.ts
@apps/api/src/auth/guards/jwt-auth.guard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IpfsModule with Pinata service</name>
  <files>
    apps/api/src/ipfs/ipfs.module.ts
    apps/api/src/ipfs/ipfs.service.ts
    apps/api/src/ipfs/dto/add.dto.ts
    apps/api/src/ipfs/dto/unpin.dto.ts
    apps/api/src/ipfs/dto/index.ts
    apps/api/package.json
  </files>
  <action>
    1. Install form-data package: `cd apps/api && pnpm add form-data`

    2. Create IpfsService (apps/api/src/ipfs/ipfs.service.ts):
       - Inject ConfigService to read PINATA_JWT from env
       - Method `pinFile(data: Buffer, metadata?: Record<string, string>): Promise<{ cid: string; size: number }>`:
         - Use form-data package to build multipart request
         - POST to https://api.pinata.cloud/pinning/pinFileToIPFS
         - Include Authorization: Bearer ${PINATA_JWT} header
         - Return { cid: IpfsHash, size: PinSize } from response
       - Method `unpinFile(cid: string): Promise<void>`:
         - DELETE to https://api.pinata.cloud/pinning/unpin/${cid}
         - Include Authorization header
         - Return void on success, throw on failure
       - Handle Pinata errors and wrap in appropriate NestJS exceptions

    3. Create DTOs:
       - AddResponseDto: { cid: string; size: number }
       - UnpinDto: { cid: string } with class-validator IsString
       - UnpinResponseDto: { success: boolean }

    4. Create IpfsModule:
       - Import ConfigModule
       - Provide IpfsService
       - Export IpfsService (for VaultModule in plan 02)

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/api build` compiles without errors
  </verify>
  <done>
    IpfsService exists with pinFile and unpinFile methods, IpfsModule exports the service
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IPFS controller with /add and /unpin endpoints</name>
  <files>
    apps/api/src/ipfs/ipfs.controller.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    1. Create IpfsController (apps/api/src/ipfs/ipfs.controller.ts):
       - Apply @ApiTags('IPFS') decorator
       - Apply @UseGuards(JwtAuthGuard) at controller level

       - POST /ipfs/add endpoint:
         - Use @UseInterceptors(FileInterceptor('file', { limits: { fileSize: 100 * 1024 * 1024 } }))
         - Accept @UploadedFile() file: Express.Multer.File
         - Call ipfsService.pinFile(file.buffer)
         - Return { cid, size }
         - Add OpenAPI decorators: @ApiConsumes('multipart/form-data'), @ApiBody with file schema

       - POST /ipfs/unpin endpoint:
         - Accept @Body() dto: UnpinDto
         - Call ipfsService.unpinFile(dto.cid)
         - Return { success: true }

    2. Update apps/api/src/app.module.ts:
       - Add IpfsModule to imports array
       - Add Ipfs to the entities array (not needed yet, but prepare)

    3. Ensure Express.Multer types work:
       - May need @types/multer dev dependency if not already present

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/api build` compiles without errors
    OpenAPI spec includes /ipfs/add and /ipfs/unpin endpoints
  </verify>
  <done>
    IpfsController exposes /ipfs/add (multipart upload) and /ipfs/unpin (JSON body) endpoints, both protected by JwtAuthGuard
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for IPFS service</name>
  <files>
    apps/api/src/ipfs/ipfs.service.spec.ts
  </files>
  <action>
    1. Create test file apps/api/src/ipfs/ipfs.service.spec.ts:
       - Mock fetch globally for Pinata API calls
       - Test pinFile:
         - Returns { cid, size } on success
         - Throws on Pinata error (non-2xx response)
         - Includes correct Authorization header
       - Test unpinFile:
         - Returns void on success (204)
         - Throws on Pinata error
         - Handles 404 (already unpinned) gracefully

    2. Use Jest's mockImplementation for fetch:
       ```typescript
       global.fetch = jest.fn();
       ```

    3. Test edge cases:
       - Empty file rejection
       - Pinata timeout handling

  </action>
  <verify>
    `cd /Users/myankelev/Code/random/cipher-box && pnpm -F @cipherbox/api test -- --testPathPattern=ipfs.service.spec` passes
  </verify>
  <done>
    IPFS service has unit tests covering pin, unpin, and error handling
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `pnpm -F @cipherbox/api build`
2. Tests pass: `pnpm -F @cipherbox/api test`
3. OpenAPI spec updated: Check apps/api/openapi.json includes /ipfs/add and /ipfs/unpin
4. Endpoints require auth: Unauthenticated requests return 401
</verification>

<success_criteria>

- IpfsModule exists and is imported in AppModule
- POST /ipfs/add accepts multipart file upload, returns { cid, size }
- POST /ipfs/unpin accepts { cid }, returns { success: true }
- Both endpoints protected by JwtAuthGuard
- File size limit enforced at 100MB
- Unit tests pass for IpfsService
  </success_criteria>

<output>
After completion, create `.planning/phases/04-file-storage/04-01-SUMMARY.md`
</output>
