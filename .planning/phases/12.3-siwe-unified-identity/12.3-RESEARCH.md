# Phase 12.3: SIWE + Unified Identity - Research

**Researched:** 2026-02-14
**Domain:** SIWE (EIP-4361), wallet connection (EIP-6963/EIP-1193), auth unification, database schema evolution
**Confidence:** HIGH (viem/wagmi already installed and verified, SIWE spec is stable, codebase thoroughly analyzed)

## Summary

This phase adds wallet-based SIWE login to CipherBox alongside existing Google/email auth, unifies all auth methods under a single identity, removes legacy ADR-001 code (EIP-712 signature-derived keys), and simplifies auth types. The research covers four domains: (1) SIWE message creation and backend verification, (2) wallet connection via wagmi which is already installed, (3) database schema changes for wallet address storage and auth type simplification, and (4) the full inventory of ADR-001 code to remove.

Key architectural insight: SIWE wallet login follows the same CipherBox identity provider pattern as Google/email. The backend verifies the SIWE signature, issues a CipherBox JWT (`sub=userId`), the frontend uses this JWT for Core Kit `loginWithJWT()`, then sends it back for backend session creation. This keeps the wallet login flow identical to existing flows at the Core Kit level -- only the initial verification step differs.

Viem (v2.44.4, already installed) provides `createSiweMessage`, `parseSiweMessage`, `validateSiweMessage`, and standalone `verifyMessage` utilities. Wagmi (v3.3.4, already installed) provides `useConnect`, `useSignMessage`, and EIP-6963 multi-provider discovery via the `injected()` connector. No new major dependencies are needed.

**Primary recommendation:** Use viem for SIWE message creation/verification and wagmi for wallet connection UI hooks. Do NOT add the `siwe` npm package (it pulls in ethers as a peer dependency). Add a new `POST /auth/identity/wallet` endpoint that mirrors the existing identity/google and identity/email patterns. Store wallet addresses as SHA-256 hash + AES-encrypted plaintext in a new column pair on `auth_methods`.

## Standard Stack

### Core (already installed)

| Library                  | Version | Purpose                                                                                                                                                               | Why Standard                                                            |
| ------------------------ | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| `viem`                   | 2.44.4  | SIWE message creation (`createSiweMessage`), parsing (`parseSiweMessage`), field validation (`validateSiweMessage`), signature verification (`verifyMessage` utility) | Already installed; native SIWE support; no extra dependencies           |
| `wagmi`                  | 3.3.4   | React hooks for wallet connection (`useConnect`, `useAccount`, `useSignMessage`, `useDisconnect`), EIP-6963 multi-provider discovery                                  | Already installed; EIP-6963 support built-in via `injected()` connector |
| `jose`                   | 6.1.3   | JWT signing for CipherBox identity tokens (existing)                                                                                                                  | Already used for identity provider JWTs                                 |
| `@web3auth/mpc-core-kit` | 3.5.0   | Core Kit `loginWithJWT()` for wallet users (existing)                                                                                                                 | Already used for Google/email login flows                               |

### Supporting (already installed)

| Library                 | Version | Purpose                                             | When to Use             |
| ----------------------- | ------- | --------------------------------------------------- | ----------------------- |
| `@tanstack/react-query` | 5.62.0  | QueryClientProvider needed by wagmi's WagmiProvider | Already used in the app |
| `@noble/secp256k1`      | 3.0.0   | Public key derivation from Core Kit TSS export      | Already used            |

### Not Needed

| Library      | Why NOT                                                                                             |
| ------------ | --------------------------------------------------------------------------------------------------- |
| `siwe` (npm) | Requires ethers as peer dependency; viem provides equivalent functionality natively                 |
| `connectkit` | Unnecessary UI layer; wagmi hooks + custom UI is lighter and matches CipherBox's terminal aesthetic |
| `rainbowkit` | Same as connectkit -- adds heavy UI component library that doesn't match our design                 |
| `ethers`     | Not needed; viem handles all SIWE operations                                                        |

### Installation

```bash
# No new packages needed -- viem and wagmi are already installed
# Only need to configure wagmi (WagmiProvider, config)
```

## Architecture Patterns

### SIWE Wallet Login Flow (End-to-End)

```text
Frontend                           Backend (NestJS)
--------                           ----------------
1. User clicks [CONNECT WALLET]
2. wagmi useConnect() shows
   installed wallets (EIP-6963)
3. User selects wallet
4. wagmi connects, gets address
   ──────────────────────────>
5.                                 GET /auth/identity/wallet/nonce
6.                                 Generate crypto-random nonce (32 chars)
7.                                 Store nonce in Redis with TTL=5min
   <──────────────────────────     Return { nonce }
8. Frontend creates SIWE message
   using viem createSiweMessage()
9. wagmi useSignMessage() prompts
   user to sign in wallet
10. User signs in MetaMask/etc
    ──────────────────────────>
11.                                POST /auth/identity/wallet
12.                                { message, signature }
13.                                parseSiweMessage(message)
14.                                validateSiweMessage(parsed, {
15.                                  domain, nonce, time })
16.                                verifyMessage({
17.                                  address: parsed.address,
18.                                  message, signature })
19.                                Consume nonce from Redis
20.                                Find or create user by
21.                                  wallet address hash
22.                                Issue CipherBox JWT
23.                                  (sub=userId, walletAddress)
    <──────────────────────────     Return { idToken, userId, isNewUser }
24. Frontend calls loginWithJWT()
    on Core Kit with CipherBox JWT
25. Core Kit derives MPC key
26. Frontend calls POST /auth/login
    with { idToken, publicKey,
    loginType: 'corekit' }
    (same as Google/email flow)
27. Backend creates session tokens
```

### Key Architectural Decisions

1. **Wallet login uses same identity provider pattern**: `POST /auth/identity/wallet` mirrors `POST /auth/identity/google` and `POST /auth/identity/email/verify-otp`. All produce CipherBox JWTs consumed by Core Kit.

2. **Nonce stored server-side in Redis**: Prevents replay attacks. The nonce is consumed (deleted) on successful verification. TTL=5min prevents stale nonces.

3. **verifierId for Core Kit**: Use `userId` (same as Google/email), NOT wallet address. This ensures the same MPC key regardless of login method for the same CipherBox user.

4. **Wallet address storage**: `auth_methods.identifier` stores SHA-256 hash of checksummed wallet address for lookup. New `auth_methods.encrypted_identifier` column stores AES-encrypted plaintext for display in settings.

### Recommended Project Structure Changes

```text
apps/api/src/auth/
+-- controllers/
|   +-- identity.controller.ts    # ADD: wallet nonce + verify endpoints
+-- services/
|   +-- siwe.service.ts           # NEW: SIWE message verification
+-- dto/
|   +-- identity.dto.ts           # ADD: WalletNonceDto, WalletVerifyDto

apps/web/src/
+-- lib/
|   +-- wagmi/
|   |   +-- config.ts             # NEW: wagmi createConfig with injected()
|   |   +-- provider.tsx          # NEW: WagmiProvider wrapper
|   +-- web3auth/
|       +-- hooks.ts              # ADD: loginWithWallet()
+-- components/auth/
|   +-- WalletLoginButton.tsx     # NEW: wallet connection + SIWE signing
|   +-- LinkedMethods.tsx         # UPDATE: full auth method management
+-- routes/
    +-- Login.tsx                  # UPDATE: add wallet login option
    +-- Settings.tsx               # UPDATE: add Account & Security section
```

### wagmi Configuration (Minimal)

```typescript
// apps/web/src/lib/wagmi/config.ts
import { createConfig, http } from 'wagmi';
import { mainnet } from 'wagmi/chains';
import { injected } from 'wagmi/connectors';

export const wagmiConfig = createConfig({
  chains: [mainnet],
  connectors: [
    injected(), // Auto-discovers all EIP-6963 wallets
  ],
  transports: {
    [mainnet.id]: http(), // Needed for wagmi but we don't make RPC calls
  },
});
```

**Important**: CipherBox does NOT use Ethereum for transactions. The chain config is required by wagmi but only used for SIWE `chainId` field. We use `mainnet` (chainId=1) as the canonical chain for SIWE messages.

### Provider Tree Update

```tsx
// main.tsx
<StrictMode>
  <WagmiProvider config={wagmiConfig}>
    <CoreKitProvider>
      <QueryClientProvider client={queryClient}>
        <App />
      </QueryClientProvider>
    </CoreKitProvider>
  </WagmiProvider>
</StrictMode>
```

**Note**: WagmiProvider must wrap QueryClientProvider (wagmi v3 uses React Query internally). Since we already have QueryClientProvider, wagmi will share it.

### Anti-Patterns to Avoid

- **Do NOT create a publicClient for SIWE verification on backend**: viem's `verifyMessage` utility works standalone for EOA addresses. No RPC connection needed.
- **Do NOT use the `siwe` npm package**: It requires ethers as a peer dependency. Use viem's native SIWE utilities instead.
- **Do NOT store wallet addresses in plaintext**: Use SHA-256 hash for lookup, AES-encrypted for display.
- **Do NOT use wallet address as Core Kit verifierId**: Use `userId` to ensure all auth methods produce the same MPC key.
- **Do NOT add WalletConnect**: It requires a WalletConnect project ID and adds complexity. EIP-6963 `injected()` connector discovers all browser-installed wallets. WalletConnect can be added later if needed.

## Don't Hand-Roll

| Problem                     | Don't Build                    | Use Instead                              | Why                                                                 |
| --------------------------- | ------------------------------ | ---------------------------------------- | ------------------------------------------------------------------- |
| SIWE message format         | Custom EIP-4361 string builder | `viem.createSiweMessage()`               | EIP-4361 has specific formatting rules, line breaks, field ordering |
| SIWE message parsing        | Regex-based parser             | `viem.parseSiweMessage()`                | Edge cases in URI parsing, date formats, optional fields            |
| SIWE signature verification | Manual ecrecover               | `viem.verifyMessage()`                   | Handles EIP-191 prefix, hex encoding, address checksumming          |
| Nonce generation            | `Math.random()`                | `crypto.randomBytes(16).toString('hex')` | Cryptographic randomness required for security                      |
| Wallet discovery            | `window.ethereum` check        | wagmi `injected()` connector (EIP-6963)  | Handles multiple installed wallets, provider conflicts              |
| Wallet address checksumming | Manual EIP-55                  | `viem.getAddress()`                      | Complex rules, case-sensitive, error-prone to implement             |

**Key insight**: The SIWE standard has many subtle requirements (RFC 3986 URIs, RFC 3339 dates, minimum nonce length, specific line format) that make hand-rolling error-prone. viem handles all of this.

## Common Pitfalls

### Pitfall 1: SIWE Nonce Reuse / Missing Server-Side Nonce Storage

**What goes wrong:** Frontend generates nonce client-side, or nonce is not consumed after use, enabling replay attacks.
**Why it happens:** Developers treat SIWE as purely client-side auth, skipping server-side nonce management.
**How to avoid:** Generate nonce on backend (`GET /auth/identity/wallet/nonce`), store in Redis with 5min TTL, consume (delete) on successful verification. Each nonce is single-use.
**Warning signs:** No Redis/cache interaction in SIWE flow; nonce generated in browser code.

### Pitfall 2: Wallet Address Case Sensitivity

**What goes wrong:** `0xAbC...` and `0xabc...` treated as different addresses; duplicate accounts created.
**Why it happens:** Ethereum addresses are case-insensitive but EIP-55 adds a checksum in mixed case.
**How to avoid:** Always normalize with `viem.getAddress()` (produces checksummed) before hashing for storage. Compare hashes, not raw strings.
**Warning signs:** Users can't log in after switching wallets/browsers; duplicate auth_methods rows.

### Pitfall 3: wagmi + React Query Provider Conflicts

**What goes wrong:** App crashes or queries don't work because wagmi and app use separate QueryClient instances.
**Why it happens:** wagmi v3 uses React Query internally. If WagmiProvider wraps its own QueryClientProvider, and the app has another, they conflict.
**How to avoid:** Put WagmiProvider OUTSIDE the existing QueryClientProvider. wagmi will find and use the existing QueryClient via context.
**Warning signs:** React Query devtools show two query caches; stale data in wallet hooks.

### Pitfall 4: Cross-Account Linking Collision

**What goes wrong:** User A's wallet gets linked to User B's account, or two separate CipherBox accounts have the same wallet.
**Why it happens:** When linking, code doesn't check if the auth method identifier already belongs to another user.
**How to avoid:** Before linking, query `auth_methods` for existing rows with the same `identifier_hash`. If found with different `userId`, reject with "This wallet is already linked to another account."
**Warning signs:** Database unique constraint violations; users losing access to vaults.

### Pitfall 5: ADR-001 Removal Breaking Imports

**What goes wrong:** After removing signatureKeyDerivation.ts, builds fail because other files import from it.
**Why it happens:** ADR-001 code is referenced in multiple places (auth store, hooks, login flow, types).
**How to avoid:** Use grep to find ALL references before deleting. Remove in dependency order: consumers first, then the module itself.
**Warning signs:** TypeScript compilation errors after deletion.

### Pitfall 6: Auth Method Type Enum Mismatch

**What goes wrong:** Frontend sends `loginType: 'wallet'` but backend expects `'external_wallet'`, or vice versa.
**Why it happens:** The simplification from 5 types to 3 types (`google`, `email`, `wallet`) must be done atomically across frontend + backend + database + OpenAPI client.
**How to avoid:** Update DTO validation, entity types, frontend types, and regenerate API client (`pnpm api:generate`) as a single atomic change.
**Warning signs:** 400 Bad Request on login; validation errors in DTO.

## Code Examples

### Backend: SIWE Verification Service

```typescript
// apps/api/src/auth/services/siwe.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { randomBytes, createHash, createCipheriv, createDecipheriv } from 'crypto';
import { ConfigService } from '@nestjs/config';
import {
  createSiweMessage,
  parseSiweMessage,
  validateSiweMessage,
  verifyMessage,
  getAddress,
  type SiweMessage,
} from 'viem';

// Note: viem must be installed in apps/api too (currently only in apps/web)
// OR use the siwe-verification logic with just crypto primitives
// SEE IMPORTANT NOTE below about viem on backend

@Injectable()
export class SiweService {
  constructor(private configService: ConfigService) {}

  /**
   * Generate a cryptographically random nonce for SIWE.
   * Must be at least 8 alphanumeric characters per EIP-4361.
   */
  generateNonce(): string {
    return randomBytes(16).toString('hex'); // 32 hex chars
  }

  /**
   * Verify a SIWE message and signature.
   * Returns the verified wallet address (checksummed).
   */
  async verifySiweMessage(
    message: string,
    signature: `0x${string}`,
    expectedNonce: string,
    expectedDomain: string
  ): Promise<string> {
    // 1. Parse the SIWE message
    const parsed = parseSiweMessage(message);
    if (!parsed.address) {
      throw new UnauthorizedException('Invalid SIWE message: missing address');
    }

    // 2. Validate message fields (domain, nonce, expiry, etc.)
    const isValid = validateSiweMessage({
      message: parsed,
      domain: expectedDomain,
      nonce: expectedNonce,
    });
    if (!isValid) {
      throw new UnauthorizedException('SIWE message validation failed');
    }

    // 3. Verify cryptographic signature (EOA only, no RPC needed)
    const signatureValid = await verifyMessage({
      address: parsed.address,
      message,
      signature,
    });
    if (!signatureValid) {
      throw new UnauthorizedException('Invalid SIWE signature');
    }

    // 4. Return checksummed address
    return getAddress(parsed.address);
  }

  /**
   * Hash a wallet address for database lookup.
   * Uses SHA-256 of the checksummed (EIP-55) address.
   */
  hashWalletAddress(address: string): string {
    const checksummed = getAddress(address);
    return createHash('sha256').update(checksummed).digest('hex');
  }

  /**
   * Encrypt a wallet address for display purposes.
   * Uses AES-256-GCM with a server-side key.
   */
  encryptWalletAddress(address: string): string {
    const key = this.getEncryptionKey();
    const iv = randomBytes(12);
    const cipher = createCipheriv('aes-256-gcm', key, iv);
    const encrypted = Buffer.concat([cipher.update(address, 'utf8'), cipher.final()]);
    const tag = cipher.getAuthTag();
    // Format: iv:tag:ciphertext (all hex)
    return `${iv.toString('hex')}:${tag.toString('hex')}:${encrypted.toString('hex')}`;
  }

  /**
   * Decrypt a wallet address for display.
   */
  decryptWalletAddress(encryptedAddress: string): string {
    const [ivHex, tagHex, ciphertextHex] = encryptedAddress.split(':');
    const key = this.getEncryptionKey();
    const decipher = createDecipheriv('aes-256-gcm', key, Buffer.from(ivHex, 'hex'));
    decipher.setAuthTag(Buffer.from(tagHex, 'hex'));
    return decipher.update(ciphertextHex, 'hex', 'utf8') + decipher.final('utf8');
  }

  private getEncryptionKey(): Buffer {
    const keyHex = this.configService.get<string>('WALLET_ADDRESS_ENCRYPTION_KEY');
    if (!keyHex) {
      throw new Error('WALLET_ADDRESS_ENCRYPTION_KEY not configured');
    }
    return Buffer.from(keyHex, 'hex'); // 32 bytes = 64 hex chars
  }
}
```

**IMPORTANT NOTE on viem in backend**: viem is currently only a frontend dependency. For backend SIWE verification, there are two approaches:

1. **Add viem to apps/api** -- cleanest, uses the same APIs. viem works fine in Node.js/NestJS.
2. **Use ethers or manual verification** -- avoid adding viem to backend. SIWE verification for EOA is just `ecrecover(hashMessage(message), signature) === address`. Could use `@noble/secp256k1` (already in the crypto package) to do this manually.

**Recommendation**: Add viem to apps/api. It's a well-maintained, tree-shakable library that the project already uses on the frontend. The alternative of reimplementing SIWE verification manually is error-prone.

### Frontend: Wallet Login Button

```typescript
// apps/web/src/components/auth/WalletLoginButton.tsx
import { useConnect, useAccount, useSignMessage, useDisconnect } from 'wagmi';
import { createSiweMessage } from 'viem/siwe';
import { authApi } from '../../lib/api/auth';

export function WalletLoginButton({
  onLogin,
  disabled,
}: {
  onLogin: (idToken: string, userId: string, walletAddress: string) => Promise<void>;
  disabled?: boolean;
}) {
  const { connect, connectors, isPending: isConnecting } = useConnect();
  const { address, isConnected } = useAccount();
  const { signMessageAsync } = useSignMessage();
  const { disconnect } = useDisconnect();

  const handleWalletLogin = async (connector: (typeof connectors)[0]) => {
    try {
      // 1. Connect wallet
      connect({ connector });
      // Note: useAccount won't update until next render
      // Need to handle this with useEffect or mutation callback
    } catch (err) {
      console.error('Wallet connection failed:', err);
    }
  };

  // After connection, trigger SIWE flow
  const handleSiweLogin = async () => {
    if (!address) return;

    // 1. Get nonce from backend
    const { nonce } = await authApi.identityWalletNonce();

    // 2. Create SIWE message
    const message = createSiweMessage({
      address,
      chainId: 1,
      domain: window.location.host,
      nonce,
      uri: window.location.origin,
      version: '1',
      statement: 'Sign in to CipherBox encrypted storage',
    });

    // 3. Sign message with wallet
    const signature = await signMessageAsync({ message });

    // 4. Verify on backend, get CipherBox JWT
    const { idToken, userId } = await authApi.identityWalletVerify({
      message,
      signature,
    });

    // 5. Disconnect wagmi (we don't need persistent wallet connection)
    disconnect();

    // 6. Continue with Core Kit login
    await onLogin(idToken, userId, address);
  };

  // Render wallet options...
}
```

### Backend: Identity Controller Wallet Endpoints

```typescript
// Addition to identity.controller.ts

@Get('identity/wallet/nonce')
@HttpCode(HttpStatus.OK)
@UseGuards(ThrottlerGuard)
@Throttle({ default: { limit: 10, ttl: 60000 } })
async getWalletNonce(): Promise<{ nonce: string }> {
  const nonce = this.siweService.generateNonce();
  // Store nonce in Redis with 5min TTL
  await this.redis.set(`siwe:nonce:${nonce}`, '1', 'EX', 300);
  return { nonce };
}

@Post('identity/wallet')
@HttpCode(HttpStatus.OK)
@UseGuards(ThrottlerGuard)
@Throttle({ default: { limit: 5, ttl: 900000 } })
async walletLogin(@Body() dto: WalletVerifyDto): Promise<IdentityTokenResponseDto> {
  // 1. Parse the message to extract nonce
  const parsed = parseSiweMessage(dto.message);

  // 2. Consume nonce from Redis (single-use)
  const nonceKey = `siwe:nonce:${parsed.nonce}`;
  const nonceExists = await this.redis.del(nonceKey);
  if (!nonceExists) {
    throw new UnauthorizedException('Invalid or expired nonce');
  }

  // 3. Verify SIWE message + signature
  const domain = this.configService.get<string>('SIWE_DOMAIN');
  const walletAddress = await this.siweService.verifySiweMessage(
    dto.message,
    dto.signature,
    parsed.nonce!,
    domain,
  );

  // 4. Find or create user by wallet address hash
  const addressHash = this.siweService.hashWalletAddress(walletAddress);
  const { user, isNewUser } = await this.findOrCreateUserByWallet(
    addressHash,
    walletAddress,
  );

  // 5. Issue CipherBox JWT (sub=userId)
  const idToken = await this.jwtIssuerService.signIdentityJwt(user.id);

  return { idToken, userId: user.id, isNewUser };
}
```

### Database Schema Changes

```sql
-- Migration: Add wallet address storage columns to auth_methods

-- 1. Add identifier_hash for fast lookup (SHA-256 of wallet address)
ALTER TABLE "auth_methods"
  ADD COLUMN "identifier_hash" varchar(64);

-- 2. Add encrypted_identifier for display (AES-256-GCM encrypted)
ALTER TABLE "auth_methods"
  ADD COLUMN "encrypted_identifier" text;

-- 3. Index for wallet address hash lookup
CREATE INDEX "IDX_auth_methods_identifier_hash"
  ON "auth_methods" ("identifier_hash");

-- 4. Remove derivationVersion from users table (ADR-001 cleanup)
ALTER TABLE "users" DROP COLUMN "derivationVersion";

-- 5. Backfill identifier_hash for existing auth methods (optional)
-- Not needed since DB will be wiped
```

### Auth Method Type Changes

```typescript
// BEFORE (auth-method.entity.ts)
export type AuthMethodType =
  | 'google'
  | 'apple'
  | 'github'
  | 'email_passwordless'
  | 'external_wallet';

// AFTER
export type AuthMethodType =
  | 'google'
  | 'email' // Simplified from 'email_passwordless'
  | 'wallet'; // Simplified from 'external_wallet'

// BEFORE (login.dto.ts)
export type LoginType = 'social' | 'external_wallet' | 'corekit';

// AFTER
export type LoginType = 'corekit';
// All auth methods now go through identity provider -> CipherBox JWT -> corekit
// The 'social' and 'external_wallet' types are no longer needed
```

## ADR-001 Removal Inventory

Complete list of files and code to remove (verified via grep):

### Files to Delete

| File                                                  | Content                                                     |
| ----------------------------------------------------- | ----------------------------------------------------------- |
| `apps/web/src/lib/crypto/signatureKeyDerivation.ts`   | Entire ADR-001 module (329 lines)                           |
| `.planning/adr/001-external-wallet-key-derivation.md` | ADR document (keep for historical reference? User decision) |

### Code to Remove from Existing Files

| File                                                      | What to Remove                                                                                                                                                                    |
| --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `apps/web/src/stores/auth.store.ts`                       | `DerivedKeypair` type, `derivedKeypair` state, `isExternalWallet` state, `setDerivedKeypair`, `setIsExternalWallet`, `clearDerivedKeypair` actions, keypair zero-fill in `logout` |
| `apps/web/src/hooks/useAuth.ts`                           | `setDerivedKeypair` import/usage (line 42-43), `setIsExternalWallet` import                                                                                                       |
| `apps/web/src/lib/web3auth/hooks.ts`                      | `getMigrationKey()` function, `importTssKey` parameter in `loginWithJWT` call                                                                                                     |
| `apps/web/src/lib/api/auth.ts`                            | `walletAddress` and `derivationVersion` fields from `LoginRequest` type                                                                                                           |
| `apps/api/src/auth/entities/user.entity.ts`               | `derivationVersion` column (lines 20-29)                                                                                                                                          |
| `apps/api/src/auth/dto/login.dto.ts`                      | `walletAddress` field, `derivationVersion` field, `'external_wallet'` from LoginType union                                                                                        |
| `apps/api/src/auth/dto/link-method.dto.ts`                | `'external_wallet'` from login type enum                                                                                                                                          |
| `apps/api/src/auth/auth.service.ts`                       | `derivationVersion` logic in `login()` (lines 96-110), `'external_wallet'` references                                                                                             |
| `apps/api/src/auth/services/web3auth-verifier.service.ts` | `'external_wallet'` JWKS endpoint, `external_wallet` branch in `verifyIdToken()`, `extractAuthMethodType()` external_wallet case                                                  |
| `apps/api/src/auth/entities/auth-method.entity.ts`        | `'external_wallet'` from AuthMethodType                                                                                                                                           |
| `apps/api/src/auth/auth.controller.ts`                    | No direct ADR-001 references, but DTOs it uses will change                                                                                                                        |
| `apps/api/src/migrations/1700000000000-FullSchema.ts`     | `"derivationVersion"` column in users table CREATE statement                                                                                                                      |
| `apps/api/src/vault/vault.service.ts`                     | Check for any `derivationVersion` references                                                                                                                                      |
| `packages/crypto/src/types.ts`                            | Check for ADR-001 related types                                                                                                                                                   |
| `scripts/generate-test-vectors.ts`                        | Check for ADR-001 references                                                                                                                                                      |

### Migration Files Needed

1. **Drop `derivationVersion` column** from `users` table
2. **Add `identifier_hash` column** to `auth_methods` table
3. **Add `encrypted_identifier` column** to `auth_methods` table
4. **Update `type` values** in `auth_methods` (rename `email_passwordless` -> `email`, `external_wallet` -> `wallet`)
5. **Update FullSchema migration** for fresh installs (since DB will be wiped, just update the baseline)

**Since DB will be wiped**: Can update the FullSchema migration directly instead of creating incremental migrations. But creating proper migrations is still recommended for staging environment transitions.

## State of the Art

| Old Approach                              | Current Approach                  | When Changed     | Impact                                        |
| ----------------------------------------- | --------------------------------- | ---------------- | --------------------------------------------- |
| `siwe` npm + ethers                       | viem native SIWE utilities        | viem 2.x (2024)  | No ethers dependency needed                   |
| `window.ethereum` injection               | EIP-6963 multi-provider discovery | 2023             | Multiple wallets work simultaneously          |
| PnP Modal for wallet login                | Core Kit + custom SIWE            | Phase 12 (now)   | Full UX control, unified identity             |
| ADR-001 EIP-712 derived keys              | SIWE -> CipherBox JWT -> Core Kit | Phase 12.3 (now) | Wallet users get same MPC key as social users |
| LoginType: social/external_wallet/corekit | LoginType: corekit (only)         | Phase 12.3 (now) | All auth goes through identity provider       |

**Deprecated/outdated:**

- `signatureKeyDerivation.ts` (ADR-001): Replaced by SIWE-based login through Core Kit
- `'social'` and `'external_wallet'` login types: All logins now go through CipherBox identity provider -> corekit path
- `derivationVersion` column: No longer needed when wallet users use Core Kit MPC keys instead of signature-derived keys

## Open Questions

1. **viem on backend (apps/api)**
   - What we know: viem works in Node.js and NestJS (confirmed by community). It's already a frontend dependency.
   - What's unclear: Whether adding viem to apps/api creates bundle size concerns or polyfill issues.
   - Recommendation: Add viem to apps/api dependencies. It's tree-shakable, and we only import SIWE utilities + `verifyMessage`. If bundle size is a concern, the SIWE verification logic (EIP-191 personal_sign recovery) could be implemented with `@noble/secp256k1` directly, but this is more error-prone.

2. **wagmi QueryClient sharing**
   - What we know: wagmi v3 uses React Query internally and can share an existing QueryClient.
   - What's unclear: Exact provider nesting order and whether wagmi's internal queries interfere with existing health check queries.
   - Recommendation: Test the provider nesting carefully. WagmiProvider should be outermost (wrapping QueryClientProvider), and wagmi will discover the QueryClient from React context.

3. **WALLET_ADDRESS_ENCRYPTION_KEY management**
   - What we know: Need a 32-byte AES key for encrypting wallet addresses for display.
   - What's unclear: Key rotation strategy, whether to derive from an existing secret.
   - Recommendation: Generate a dedicated 32-byte key (`openssl rand -hex 32`), store as env var. Key rotation is low priority since DB will be wiped. For production, consider deriving from a KMS-managed key.

4. **First-time wallet user flow (Claude's discretion)**
   - What we know: Wallet login creates CipherBox account. User may want to add email for recovery later.
   - Recommendation: Auto-create account silently on first SIWE login. Show a non-blocking suggestion in the vault UI: "Add an email for account recovery" (dismissible). This is the least-friction approach and matches how most Web3 apps work.

5. **Apple/GitHub auth method types retained?**
   - What we know: Current AuthMethodType includes 'apple' and 'github' but these aren't used.
   - Recommendation: Keep them in the type union for future extensibility. They take up no space and removing them is a one-line change later.

## Sources

### Primary (HIGH confidence)

- viem v2.44.4 installed locally -- SIWE utilities verified via source code on GitHub
- wagmi v3.3.4 installed locally -- EIP-6963 `injected()` connector confirmed
- CipherBox codebase -- full audit of auth flow, entities, DTOs, services, controllers
- [EIP-4361 specification](https://eips.ethereum.org/EIPS/eip-4361)
- Phase 12 Core Kit research -- `.planning/phases/12-multi-factor-authentication/12-RESEARCH-corekit.md`
- Phase 12 learnings -- `.learnings/2026-02-13-phase12-corekit-identity-provider.md`

### Secondary (MEDIUM confidence)

- viem SIWE source code on GitHub (createSiweMessage, validateSiweMessage, verifySiweMessage)
  - [createSiweMessage.ts](https://github.com/wevm/viem/blob/main/src/utils/siwe/createSiweMessage.ts)
  - [validateSiweMessage.ts](https://github.com/wevm/viem/blob/main/src/utils/siwe/validateSiweMessage.ts)
  - [verifySiweMessage.ts](https://github.com/wevm/viem/blob/main/src/actions/siwe/verifySiweMessage.ts)
- [wagmi connect-wallet guide](https://wagmi.sh/react/guides/connect-wallet)
- [SIWE official documentation](https://docs.siwe.xyz/)
- [viem Node.js compatibility confirmed](https://github.com/wevm/viem/discussions/1414)

### Tertiary (LOW confidence)

- ConnectKit vs RainbowKit comparison -- web search results (no direct benchmarks found)
- [NestJS + SIWE example](https://github.com/codeninja819/nestjs-siwe) (not audited)

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH -- all libraries already installed and verified
- Architecture: HIGH -- follows established identity provider pattern from Phase 12
- SIWE verification: HIGH -- viem source code reviewed, API well-documented
- ADR-001 removal scope: HIGH -- comprehensive grep across entire codebase
- Wallet address storage: MEDIUM -- encryption approach is sound but key management details TBD
- wagmi provider integration: MEDIUM -- confirmed to work but exact nesting needs testing

**Research date:** 2026-02-14
**Valid until:** 2026-03-14 (stable -- viem/wagmi are mature, SIWE spec is final)
