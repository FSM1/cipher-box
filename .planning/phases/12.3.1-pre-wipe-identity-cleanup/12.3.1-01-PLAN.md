---
phase: 12.3.1-pre-wipe-identity-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/vault/derive-ipns.ts
  - packages/crypto/src/vault/init.ts
  - packages/crypto/src/vault/types.ts
  - packages/crypto/src/vault/index.ts
  - packages/crypto/src/index.ts
  - packages/crypto/src/__tests__/vault-ipns.test.ts
  - packages/crypto/src/__tests__/vault.test.ts
autonomous: true

must_haves:
  truths:
    - 'deriveVaultIpnsKeypair(privateKey) always returns the same IPNS keypair and name for the same input'
    - 'deriveVaultIpnsKeypair uses a different HKDF info than deriveRegistryIpnsKeypair (no collision)'
    - 'initializeVault(userPrivateKey) produces a deterministic root IPNS keypair instead of a random one'
    - 'initializeVault still generates a random rootFolderKey (not deterministic)'
    - 'EncryptedVaultKeys no longer contains rootIpnsPublicKey (it is derivable)'
    - 'encryptVaultKeys returns only encryptedRootFolderKey and encryptedIpnsPrivateKey'
    - 'decryptVaultKeys derives the public key from the IPNS private key instead of reading it from EncryptedVaultKeys'
  artifacts:
    - path: 'packages/crypto/src/vault/derive-ipns.ts'
      provides: 'deriveVaultIpnsKeypair function'
      exports: ['deriveVaultIpnsKeypair']
    - path: 'packages/crypto/src/vault/init.ts'
      provides: 'Updated initializeVault, encryptVaultKeys, decryptVaultKeys'
      exports: ['initializeVault', 'encryptVaultKeys', 'decryptVaultKeys']
    - path: 'packages/crypto/src/vault/types.ts'
      provides: 'EncryptedVaultKeys without rootIpnsPublicKey'
      exports: ['EncryptedVaultKeys', 'VaultInit']
    - path: 'packages/crypto/src/__tests__/vault-ipns.test.ts'
      provides: 'Tests for deterministic vault IPNS derivation'
      min_lines: 40
  key_links:
    - from: 'packages/crypto/src/vault/derive-ipns.ts'
      to: 'packages/crypto/src/keys/derive.ts'
      via: 'HKDF deriveKey import'
      pattern: 'import.*deriveKey.*from.*keys/derive'
    - from: 'packages/crypto/src/vault/init.ts'
      to: 'packages/crypto/src/vault/derive-ipns.ts'
      via: 'deriveVaultIpnsKeypair call'
      pattern: 'deriveVaultIpnsKeypair'
    - from: 'packages/crypto/src/vault/init.ts'
      to: '@noble/ed25519'
      via: 'getPublicKeyAsync to derive public key from private key in decryptVaultKeys'
      pattern: 'getPublicKeyAsync'
---

<objective>
Create deterministic vault IPNS keypair derivation in the @cipherbox/crypto package, mirroring the existing device registry IPNS derivation pattern from Phase 12.2. Also update EncryptedVaultKeys type, encryptVaultKeys, and decryptVaultKeys to remove the now-redundant rootIpnsPublicKey field.

Purpose: Enables self-sovereign vault recovery (recovery phrase -> privateKey -> derive vault IPNS key -> resolve IPNS -> decrypt vault). Eliminates random keygen for the root vault IPNS keypair, making the vault discoverable from just the user's private key. Removing rootIpnsPublicKey from EncryptedVaultKeys ensures consumers derive it instead of relying on a stored value.

Output: `deriveVaultIpnsKeypair()` function, updated `initializeVault()`, updated `encryptVaultKeys()`/`decryptVaultKeys()`, and updated `EncryptedVaultKeys` type.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing HKDF IPNS derivation pattern to mirror

@packages/crypto/src/registry/derive-ipns.ts
@packages/crypto/src/keys/derive.ts

# Current vault init (random keygen) to update

@packages/crypto/src/vault/init.ts
@packages/crypto/src/vault/types.ts
@packages/crypto/src/ed25519/keygen.ts

# Existing barrel exports

@packages/crypto/src/vault/index.ts
@packages/crypto/src/index.ts

# Existing vault tests that must be updated

@packages/crypto/src/**tests**/vault.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deriveVaultIpnsKeypair, update initializeVault, encryptVaultKeys, decryptVaultKeys, and EncryptedVaultKeys type</name>
  <files>
    packages/crypto/src/vault/derive-ipns.ts
    packages/crypto/src/vault/init.ts
    packages/crypto/src/vault/types.ts
    packages/crypto/src/vault/index.ts
    packages/crypto/src/index.ts
  </files>
  <action>
Create `packages/crypto/src/vault/derive-ipns.ts` following the exact pattern of `packages/crypto/src/registry/derive-ipns.ts`:
- Import `deriveKey` from `../keys/derive`
- Import `* as ed` from `@noble/ed25519`
- Import `deriveIpnsName` from `../ipns/derive-name`
- Import `CryptoError` and `SECP256K1_PRIVATE_KEY_SIZE` from constants
- Use salt: `new TextEncoder().encode('CipherBox-v1')` (same salt as registry -- HKDF with different info is sufficient for domain separation)
- Use info: `new TextEncoder().encode('cipherbox-vault-ipns-v1')` (DIFFERENT from registry's `cipherbox-device-registry-ipns-v1`)
- Export `async function deriveVaultIpnsKeypair(userPrivateKey: Uint8Array)` returning `{ privateKey: Uint8Array; publicKey: Uint8Array; ipnsName: string }`
- Validate input key length (must be SECP256K1_PRIVATE_KEY_SIZE = 32 bytes)
- Steps: HKDF -> 32-byte Ed25519 seed -> getPublicKeyAsync -> deriveIpnsName -> return

Update `packages/crypto/src/vault/types.ts` -- **remove rootIpnsPublicKey from EncryptedVaultKeys**:

- The `EncryptedVaultKeys` type currently has three fields: `encryptedRootFolderKey`, `encryptedIpnsPrivateKey`, `rootIpnsPublicKey`
- Remove the `rootIpnsPublicKey: Uint8Array` field entirely
- The type should only have `encryptedRootFolderKey` and `encryptedIpnsPrivateKey`
- Remove the comment "Public key for IPNS name derivation (not secret)"
- Keep `VaultInit` type unchanged

Update `packages/crypto/src/vault/init.ts`:

- Change `initializeVault()` to `initializeVault(userPrivateKey: Uint8Array)` -- now REQUIRES privateKey
- Replace `generateEd25519Keypair()` call with `await deriveVaultIpnsKeypair(userPrivateKey)`
- Map the result: `rootIpnsKeypair = { privateKey: derived.privateKey, publicKey: derived.publicKey }`
- Keep `rootFolderKey = generateFileKey()` (still random -- folder key has no reason to be deterministic)
- Remove `generateEd25519Keypair` import if no longer used
- Update JSDoc to document the new behavior and the userPrivateKey parameter

- Update `encryptVaultKeys()`: Remove `rootIpnsPublicKey: vault.rootIpnsKeypair.publicKey` from the return object. The function should return only `{ encryptedRootFolderKey, encryptedIpnsPrivateKey }` (matching the updated `EncryptedVaultKeys` type).

- Update `decryptVaultKeys()`: The function currently reads `encrypted.rootIpnsPublicKey` to reconstruct the keypair. Since `rootIpnsPublicKey` is removed from `EncryptedVaultKeys`, derive the public key from the decrypted IPNS private key instead:
  - Import `* as ed` from `@noble/ed25519`
  - After unwrapping `ipnsPrivateKey`, call `const ipnsPublicKey = await ed.getPublicKeyAsync(ipnsPrivateKey)`
  - Set `rootIpnsKeypair = { privateKey: ipnsPrivateKey, publicKey: ipnsPublicKey }`
  - Remove the line that reads `encrypted.rootIpnsPublicKey`

Update barrel exports in `packages/crypto/src/vault/index.ts` to also export `deriveVaultIpnsKeypair` from `./derive-ipns`

Update `packages/crypto/src/index.ts` barrel to re-export `deriveVaultIpnsKeypair` if not already covered by vault barrel
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto build` -- should compile without errors.
Grep for `generateEd25519Keypair` in vault/init.ts -- should NOT appear (replaced by deriveVaultIpnsKeypair).
Grep for `cipherbox-vault-ipns-v1` in derive-ipns.ts -- should appear exactly once.
Grep for `rootIpnsPublicKey` in vault/types.ts -- should NOT appear.
Grep for `rootIpnsPublicKey` in vault/init.ts -- should NOT appear.
Grep for `getPublicKeyAsync` in vault/init.ts -- should appear (in decryptVaultKeys).
</verify>
<done>
deriveVaultIpnsKeypair exists. initializeVault requires userPrivateKey and derives IPNS deterministically. EncryptedVaultKeys no longer has rootIpnsPublicKey. encryptVaultKeys returns only two encrypted fields. decryptVaultKeys derives public key from private key. Package compiles.
</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for deterministic vault IPNS derivation and update existing vault.test.ts</name>
  <files>
    packages/crypto/src/__tests__/vault-ipns.test.ts
    packages/crypto/src/__tests__/vault.test.ts
  </files>
  <action>
Create `packages/crypto/src/__tests__/vault-ipns.test.ts` following the pattern of `packages/crypto/src/__tests__/registry.test.ts`:

Test cases for `deriveVaultIpnsKeypair`:

1. **Determinism**: Same privateKey produces same keypair and ipnsName every time (call twice, compare all three outputs)
2. **Different keys produce different results**: Two different 32-byte private keys produce different IPNS names
3. **No collision with registry derivation**: For the same privateKey, `deriveVaultIpnsKeypair` and `deriveRegistryIpnsKeypair` produce DIFFERENT IPNS names (this is critical -- both use HKDF with the same salt but different info)
4. **Invalid key size rejected**: 31-byte key throws CryptoError with code 'INVALID_KEY_SIZE'
5. **IPNS name format**: Result ipnsName starts with 'k51' (standard libp2p-key multihash)

Test cases for updated `initializeVault`:

6. **Deterministic IPNS**: `initializeVault(privateKey)` produces same rootIpnsKeypair for same privateKey (call twice, compare)
7. **Random rootFolderKey**: `initializeVault(privateKey)` produces DIFFERENT rootFolderKey each time (call twice, compare -- they should NOT match)
8. **Keypair consistency**: The rootIpnsKeypair.publicKey from initializeVault matches the publicKey from deriveVaultIpnsKeypair for the same input

Use `crypto.getRandomValues(new Uint8Array(32))` or a fixed test vector for the private key.
Import from `@cipherbox/crypto` (or relative paths if the package barrel isn't available in test context -- check existing test patterns in the repo).

**Update existing `packages/crypto/src/**tests**/vault.test.ts`** to work with the new signatures:

- All `initializeVault()` calls (no args) must become `initializeVault(privateKey)` where `privateKey` is a test secp256k1 private key (use `secp256k1.utils.randomPrivateKey()` which is already imported)
- Update the "should produce unique keys on each initialization" test: IPNS keypairs are now DETERMINISTIC for the same private key, so when using the SAME private key, the IPNS keypairs WILL be equal. To test uniqueness, use DIFFERENT private keys for each call.
- Remove the `rootIpnsPublicKey` assertion in the encryptVaultKeys test (line 83: `expect(encrypted).toHaveProperty('rootIpnsPublicKey')` -- this property no longer exists)
- Remove the "should preserve IPNS public key in plaintext" test entirely (lines 99-107) -- rootIpnsPublicKey is no longer in EncryptedVaultKeys
- In the decryptVaultKeys round-trip test, the decrypted public key is now derived from the private key via ed25519 getPublicKeyAsync, so the assertion `decrypted.rootIpnsKeypair.publicKey` should still equal `vault.rootIpnsKeypair.publicKey` (both derived from the same private key)
- All other encrypt/decrypt tests should continue to work since they don't reference rootIpnsPublicKey directly
  </action>
  <verify>
  Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto test` -- all tests pass including new ones.
  </verify>
  <done>
  8 new test cases pass for vault IPNS derivation. Existing vault.test.ts updated: initializeVault calls pass privateKey, rootIpnsPublicKey assertions removed, determinism test uses different keys. All tests pass.
  </done>
  </task>

</tasks>

<verification>
- `pnpm --filter @cipherbox/crypto build` compiles successfully
- `pnpm --filter @cipherbox/crypto test` passes all tests
- `deriveVaultIpnsKeypair(key)` called twice returns identical results
- `deriveVaultIpnsKeypair(key)` and `deriveRegistryIpnsKeypair(key)` return DIFFERENT IPNS names for the same key
- `initializeVault(key)` returns deterministic IPNS keypair but random folder key
- `EncryptedVaultKeys` type has only `encryptedRootFolderKey` and `encryptedIpnsPrivateKey`
- `encryptVaultKeys` does not return `rootIpnsPublicKey`
- `decryptVaultKeys` derives public key from private key via `getPublicKeyAsync`
</verification>

<success_criteria>

- deriveVaultIpnsKeypair function exists with HKDF info "cipherbox-vault-ipns-v1"
- initializeVault now requires userPrivateKey parameter (breaking change from random keygen)
- EncryptedVaultKeys type no longer has rootIpnsPublicKey field
- encryptVaultKeys returns only encryptedRootFolderKey and encryptedIpnsPrivateKey
- decryptVaultKeys derives public key from IPNS private key (no longer reads from EncryptedVaultKeys)
- All existing crypto tests updated and passing
- New tests verify determinism, domain separation, and error handling
  </success_criteria>

<output>
After completion, create `.planning/phases/12.3.1-pre-wipe-identity-cleanup/12.3.1-01-SUMMARY.md`
</output>
