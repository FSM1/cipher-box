---
phase: 12.3.1-pre-wipe-identity-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/vault/derive-ipns.ts
  - packages/crypto/src/vault/init.ts
  - packages/crypto/src/vault/types.ts
  - packages/crypto/src/vault/index.ts
  - packages/crypto/src/index.ts
  - packages/crypto/src/__tests__/vault-ipns.test.ts
autonomous: true

must_haves:
  truths:
    - 'deriveVaultIpnsKeypair(privateKey) always returns the same IPNS keypair and name for the same input'
    - 'deriveVaultIpnsKeypair uses a different HKDF info than deriveRegistryIpnsKeypair (no collision)'
    - 'initializeVault(userPrivateKey) produces a deterministic root IPNS keypair instead of a random one'
    - 'initializeVault still generates a random rootFolderKey (not deterministic)'
  artifacts:
    - path: 'packages/crypto/src/vault/derive-ipns.ts'
      provides: 'deriveVaultIpnsKeypair function'
      exports: ['deriveVaultIpnsKeypair']
    - path: 'packages/crypto/src/vault/init.ts'
      provides: 'Updated initializeVault accepting userPrivateKey'
      exports: ['initializeVault']
    - path: 'packages/crypto/src/__tests__/vault-ipns.test.ts'
      provides: 'Tests for deterministic vault IPNS derivation'
      min_lines: 40
  key_links:
    - from: 'packages/crypto/src/vault/derive-ipns.ts'
      to: 'packages/crypto/src/keys/derive.ts'
      via: 'HKDF deriveKey import'
      pattern: 'import.*deriveKey.*from.*keys/derive'
    - from: 'packages/crypto/src/vault/init.ts'
      to: 'packages/crypto/src/vault/derive-ipns.ts'
      via: 'deriveVaultIpnsKeypair call'
      pattern: 'deriveVaultIpnsKeypair'
---

<objective>
Create deterministic vault IPNS keypair derivation in the @cipherbox/crypto package, mirroring the existing device registry IPNS derivation pattern from Phase 12.2.

Purpose: Enables self-sovereign vault recovery (recovery phrase -> privateKey -> derive vault IPNS key -> resolve IPNS -> decrypt vault). Eliminates random keygen for the root vault IPNS keypair, making the vault discoverable from just the user's private key.

Output: `deriveVaultIpnsKeypair()` function and updated `initializeVault()` that uses it.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing HKDF IPNS derivation pattern to mirror

@packages/crypto/src/registry/derive-ipns.ts
@packages/crypto/src/keys/derive.ts

# Current vault init (random keygen) to update

@packages/crypto/src/vault/init.ts
@packages/crypto/src/vault/types.ts
@packages/crypto/src/ed25519/keygen.ts

# Existing barrel exports

@packages/crypto/src/vault/index.ts
@packages/crypto/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deriveVaultIpnsKeypair and update initializeVault</name>
  <files>
    packages/crypto/src/vault/derive-ipns.ts
    packages/crypto/src/vault/init.ts
    packages/crypto/src/vault/types.ts
    packages/crypto/src/vault/index.ts
    packages/crypto/src/index.ts
  </files>
  <action>
Create `packages/crypto/src/vault/derive-ipns.ts` following the exact pattern of `packages/crypto/src/registry/derive-ipns.ts`:
- Import `deriveKey` from `../keys/derive`
- Import `* as ed` from `@noble/ed25519`
- Import `deriveIpnsName` from `../ipns/derive-name`
- Import `CryptoError` and `SECP256K1_PRIVATE_KEY_SIZE` from constants
- Use salt: `new TextEncoder().encode('CipherBox-v1')` (same salt as registry -- HKDF with different info is sufficient for domain separation)
- Use info: `new TextEncoder().encode('cipherbox-vault-ipns-v1')` (DIFFERENT from registry's `cipherbox-device-registry-ipns-v1`)
- Export `async function deriveVaultIpnsKeypair(userPrivateKey: Uint8Array)` returning `{ privateKey: Uint8Array; publicKey: Uint8Array; ipnsName: string }`
- Validate input key length (must be SECP256K1_PRIVATE_KEY_SIZE = 32 bytes)
- Steps: HKDF -> 32-byte Ed25519 seed -> getPublicKeyAsync -> deriveIpnsName -> return

Update `packages/crypto/src/vault/init.ts`:

- Change `initializeVault()` to `initializeVault(userPrivateKey: Uint8Array)` -- now REQUIRES privateKey
- Replace `generateEd25519Keypair()` call with `await deriveVaultIpnsKeypair(userPrivateKey)`
- Map the result: `rootIpnsKeypair = { privateKey: derived.privateKey, publicKey: derived.publicKey }`
- Keep `rootFolderKey = generateFileKey()` (still random -- folder key has no reason to be deterministic)
- Remove `generateEd25519Keypair` import if no longer used
- Update JSDoc to document the new behavior and the userPrivateKey parameter

Update `packages/crypto/src/vault/types.ts` -- no changes expected (VaultInit type should still work as-is since it has rootFolderKey and rootIpnsKeypair)

Update barrel exports in `packages/crypto/src/vault/index.ts` to also export `deriveVaultIpnsKeypair` from `./derive-ipns`

Update `packages/crypto/src/index.ts` barrel to re-export `deriveVaultIpnsKeypair` if not already covered by vault barrel
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto build` -- should compile without errors.
Grep for `generateEd25519Keypair` in vault/init.ts -- should NOT appear (replaced by deriveVaultIpnsKeypair).
Grep for `cipherbox-vault-ipns-v1` in derive-ipns.ts -- should appear exactly once.
</verify>
<done>
deriveVaultIpnsKeypair exists, initializeVault requires userPrivateKey and derives IPNS deterministically, package compiles.
</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for deterministic vault IPNS derivation</name>
  <files>
    packages/crypto/src/__tests__/vault-ipns.test.ts
  </files>
  <action>
Create `packages/crypto/src/__tests__/vault-ipns.test.ts` following the pattern of `packages/crypto/src/__tests__/registry.test.ts`:

Test cases for `deriveVaultIpnsKeypair`:

1. **Determinism**: Same privateKey produces same keypair and ipnsName every time (call twice, compare all three outputs)
2. **Different keys produce different results**: Two different 32-byte private keys produce different IPNS names
3. **No collision with registry derivation**: For the same privateKey, `deriveVaultIpnsKeypair` and `deriveRegistryIpnsKeypair` produce DIFFERENT IPNS names (this is critical -- both use HKDF with the same salt but different info)
4. **Invalid key size rejected**: 31-byte key throws CryptoError with code 'INVALID_KEY_SIZE'
5. **IPNS name format**: Result ipnsName starts with 'k51' (standard libp2p-key multihash)

Test cases for updated `initializeVault`:

6. **Deterministic IPNS**: `initializeVault(privateKey)` produces same rootIpnsKeypair for same privateKey (call twice, compare)
7. **Random rootFolderKey**: `initializeVault(privateKey)` produces DIFFERENT rootFolderKey each time (call twice, compare -- they should NOT match)
8. **Keypair consistency**: The rootIpnsKeypair.publicKey from initializeVault matches the publicKey from deriveVaultIpnsKeypair for the same input

Use `crypto.getRandomValues(new Uint8Array(32))` or a fixed test vector for the private key.
Import from `@cipherbox/crypto` (or relative paths if the package barrel isn't available in test context -- check existing test patterns in the repo).
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto test` -- all tests pass including new ones.
</verify>
<done>
8 test cases pass. Determinism, domain separation from registry, random folder key, and error cases all verified.
</done>
</task>

</tasks>

<verification>
- `pnpm --filter @cipherbox/crypto build` compiles successfully
- `pnpm --filter @cipherbox/crypto test` passes all tests
- `deriveVaultIpnsKeypair(key)` called twice returns identical results
- `deriveVaultIpnsKeypair(key)` and `deriveRegistryIpnsKeypair(key)` return DIFFERENT IPNS names for the same key
- `initializeVault(key)` returns deterministic IPNS keypair but random folder key
</verification>

<success_criteria>

- deriveVaultIpnsKeypair function exists with HKDF info "cipherbox-vault-ipns-v1"
- initializeVault now requires userPrivateKey parameter (breaking change from random keygen)
- All existing crypto tests still pass
- New tests verify determinism, domain separation, and error handling
  </success_criteria>

<output>
After completion, create `.planning/phases/12.3.1-pre-wipe-identity-cleanup/12.3.1-01-SUMMARY.md`
</output>
