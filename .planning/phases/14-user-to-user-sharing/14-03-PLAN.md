---
phase: 14-user-to-user-sharing
plan: 03
type: execute
wave: 3
depends_on: ['14-02']
files_modified:
  - apps/web/src/stores/share.store.ts
  - apps/web/src/services/share.service.ts
  - apps/web/src/routes/SettingsPage.tsx
  - apps/web/src/styles/settings.css
autonomous: true

must_haves:
  truths:
    - 'Share store holds received and sent shares in Zustand state'
    - 'Share service calls API to create, list, revoke, and manage shares'
    - 'User can see their public key in Settings with a copy button'
    - 'Copy button copies the full 0x04-prefixed public key to clipboard'
  artifacts:
    - path: 'apps/web/src/stores/share.store.ts'
      provides: 'Zustand store for share state'
      exports: ['useShareStore']
    - path: 'apps/web/src/services/share.service.ts'
      provides: 'Share service with API calls and key re-wrapping'
      exports:
        [
          'fetchReceivedShares',
          'fetchSentShares',
          'createShare',
          'revokeShare',
          'hideShare',
          'fetchShareKeys',
          'addShareKeys',
        ]
    - path: 'apps/web/src/routes/SettingsPage.tsx'
      provides: 'Settings page with public key display section'
      contains: 'your public key'
  key_links:
    - from: 'apps/web/src/services/share.service.ts'
      to: 'apps/web/src/api/'
      via: 'generated API client calls'
      pattern: 'import.*from.*api'
    - from: 'apps/web/src/stores/share.store.ts'
      to: 'apps/web/src/services/share.service.ts'
      via: 'store actions call service'
      pattern: 'fetchReceivedShares|createShare'
---

<objective>
Build the frontend share infrastructure (store + service) and add public key display to Settings.

Purpose: The share store and service provide the client-side state management and API integration for all sharing operations. The Settings public key display lets users share their key with others for out-of-band exchange.
Output: Zustand share store, share service with re-wrapping logic, Settings page with public key section.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-user-to-user-sharing/14-CONTEXT.md
@.planning/phases/14-user-to-user-sharing/14-RESEARCH.md
@.planning/phases/14-user-to-user-sharing/14-02-SUMMARY.md
@apps/web/src/stores/folder.store.ts
@apps/web/src/services/folder.service.ts
@apps/web/src/routes/SettingsPage.tsx
@apps/web/src/stores/auth.store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create share store and share service</name>
  <files>
    apps/web/src/stores/share.store.ts
    apps/web/src/services/share.service.ts
  </files>
  <action>
    **share.store.ts** -- Zustand store following folder.store.ts pattern:

    ```typescript
    type ReceivedShare = {
      shareId: string;
      sharerPublicKey: string;
      itemType: 'folder' | 'file';
      ipnsName: string;
      itemName: string;
      encryptedKey: string; // hex-encoded ECIES ciphertext
      createdAt: string;
    };

    type SentShare = {
      shareId: string;
      recipientPublicKey: string;
      itemType: 'folder' | 'file';
      ipnsName: string;
      itemName: string;
      createdAt: string;
    };

    type ShareState = {
      receivedShares: ReceivedShare[];
      sentShares: SentShare[];
      isLoadingReceived: boolean;
      isLoadingSent: boolean;
      lastFetchedAt: number | null;

      // Actions
      setReceivedShares: (shares: ReceivedShare[]) => void;
      setSentShares: (shares: SentShare[]) => void;
      setLoadingReceived: (loading: boolean) => void;
      setLoadingSent: (loading: boolean) => void;
      addSentShare: (share: SentShare) => void;
      removeSentShare: (shareId: string) => void;
      removeReceivedShare: (shareId: string) => void;
      clearShares: () => void;
    };
    ```

    Export as `useShareStore` using `create<ShareState>()`.

    **share.service.ts** -- Service with these exported functions:

    1. `fetchReceivedShares(): Promise<ReceivedShare[]>` -- Call GET /shares/received via generated API client. Map response to ReceivedShare[].

    2. `fetchSentShares(): Promise<SentShare[]>` -- Call GET /shares/sent via generated API client. Map response to SentShare[].

    3. `lookupUser(publicKeyHex: string): Promise<{ userId: string; publicKey: string } | null>` -- Call GET /shares/lookup?publicKey=X. Return null on 404.

    4. `createShare(params: { recipientPublicKey: string; itemType: 'folder' | 'file'; ipnsName: string; itemName: string; encryptedKey: string; childKeys?: Array<{ keyType: 'file' | 'folder'; itemId: string; encryptedKey: string }>; }): Promise<{ shareId: string }>` -- Call POST /shares.

    5. `revokeShare(shareId: string): Promise<void>` -- Call DELETE /shares/:shareId.

    6. `hideShare(shareId: string): Promise<void>` -- Call PATCH /shares/:shareId/hide.

    7. `fetchShareKeys(shareId: string): Promise<Array<{ keyType: 'file' | 'folder'; itemId: string; encryptedKey: string }>>` -- Call GET /shares/:shareId/keys.

    8. `addShareKeys(shareId: string, keys: Array<{ keyType: 'file' | 'folder'; itemId: string; encryptedKey: string }>): Promise<void>` -- Call POST /shares/:shareId/keys.

    9. `getSentSharesForItem(ipnsName: string): Promise<SentShare[]>` -- Filter sent shares by ipnsName (calls fetchSentShares and filters, or uses a dedicated cached lookup from the store).

    Use the generated API client from `apps/web/src/api/` for all HTTP calls. Check the generated client after Plan 02 completes to determine exact import paths and function names. If the generated client uses Orval patterns (like other services in this codebase), follow the same wrapper pattern used in `apps/web/src/services/device-approval.service.ts`.

  </action>
  <verify>
    Run `pnpm --filter web build` succeeds.
    Verify share.store.ts exports useShareStore.
    Verify share.service.ts exports all 9 functions.
  </verify>
  <done>
    Share store and service exist, compile successfully, and provide typed API access for all sharing operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add public key display section to Settings page</name>
  <files>
    apps/web/src/routes/SettingsPage.tsx
    apps/web/src/styles/settings.css
  </files>
  <action>
    Add a new section to SettingsPage.tsx BELOW the VaultExport section. Per CONTEXT.md decisions:

    **Section structure:**
    ```tsx
    <section className="settings-section" style={{ marginTop: 'var(--spacing-md)' }}>
      <h3 className="settings-section-heading">
        {'// your public key'}
      </h3>
      <p className="settings-section-description">
        {'// share this key with others to receive shared files'}
      </p>
      <div className="settings-pubkey-box">
        <code className="settings-pubkey-value">
          {publicKeyHex}
        </code>
      </div>
      <button
        type="button"
        className="settings-pubkey-copy"
        onClick={handleCopyPublicKey}
      >
        {copied ? '--copied' : '--copy'}
      </button>
    </section>
    ```

    Implementation details:
    - Get publicKey from `useAuthStore` (it stores the hex public key)
    - Format as `0x${publicKey}` (add 0x prefix if not already present)
    - Copy button uses `navigator.clipboard.writeText()` with a `copied` state that resets after 2 seconds via setTimeout
    - Clean up timeout on unmount with useEffect cleanup

    **CSS additions to settings.css:**
    ```css
    .settings-pubkey-box {
      border: 1px solid var(--color-green-primary);
      padding: var(--spacing-sm) var(--spacing-md);
      margin: var(--spacing-sm) 0;
      word-break: break-all;
      font-family: var(--font-mono);
      font-size: 0.75rem;
      line-height: 1.4;
      color: var(--color-green-primary);
      background: transparent;
    }

    .settings-pubkey-copy {
      background: transparent;
      border: 1px solid var(--color-green-primary);
      color: var(--color-green-primary);
      padding: var(--spacing-xs) var(--spacing-sm);
      font-family: var(--font-mono);
      font-size: 0.75rem;
      cursor: pointer;
      text-transform: lowercase;
    }

    .settings-pubkey-copy:hover {
      background: var(--color-green-primary);
      color: var(--color-bg);
    }

    .settings-pubkey-copy:focus-visible {
      outline: 1px solid var(--color-green-primary);
      outline-offset: 1px;
    }
    ```

    Follow the terminal aesthetic: `//` comment style headers, `--copy` command style button, monospace font, green-on-dark colors. Match existing settings page styling patterns.

    Check where the settings.css import exists -- if it's already imported in SettingsPage.tsx, just add the new rules. Otherwise, check how other settings styles are loaded (may be in a global CSS file).

  </action>
  <verify>
    Run `pnpm --filter web build` succeeds.
    Verify the pubkey section renders in SettingsPage by checking the JSX structure.
  </verify>
  <done>
    Settings page displays user's secp256k1 public key in a bordered monospace box with a copy-to-clipboard button. Terminal aesthetic matches existing settings styling.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` passes
- Share store exports useShareStore with receivedShares and sentShares state
- Share service exports functions for all CRUD operations
- Settings page has public key section with copy button
- No TypeScript errors in any modified files
</verification>

<success_criteria>

1. Share store holds received and sent shares with loading state
2. Share service provides typed API calls matching all backend endpoints
3. Settings page shows user's public key with functional copy button
4. Terminal aesthetic maintained: `//` comments, `--copy` button, monospace, green theme
5. Web app builds successfully
   </success_criteria>

<output>
After completion, create `.planning/phases/14-user-to-user-sharing/14-03-SUMMARY.md`
</output>
