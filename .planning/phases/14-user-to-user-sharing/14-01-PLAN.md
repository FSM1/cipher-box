---
phase: 14-user-to-user-sharing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/ecies/rewrap.ts
  - packages/crypto/src/ecies/index.ts
  - packages/crypto/src/__tests__/rewrap.test.ts
  - apps/api/src/shares/entities/share.entity.ts
  - apps/api/src/shares/entities/share-key.entity.ts
  - apps/api/src/shares/entities/index.ts
autonomous: true

must_haves:
  truths:
    - 'reWrapKey correctly unwraps with owner key and re-wraps with recipient key'
    - 'Share entity maps to shares table with correct column types and constraints'
    - 'ShareKey entity maps to share_keys table with cascade delete on share removal'
  artifacts:
    - path: 'packages/crypto/src/ecies/rewrap.ts'
      provides: 'reWrapKey() function for sharing'
      exports: ['reWrapKey']
    - path: 'packages/crypto/src/__tests__/rewrap.test.ts'
      provides: 'Test vectors for re-wrapping correctness'
      contains: 'reWrapKey'
    - path: 'apps/api/src/shares/entities/share.entity.ts'
      provides: 'Share TypeORM entity'
      contains: 'class Share'
    - path: 'apps/api/src/shares/entities/share-key.entity.ts'
      provides: 'ShareKey TypeORM entity'
      contains: 'class ShareKey'
  key_links:
    - from: 'packages/crypto/src/ecies/rewrap.ts'
      to: 'packages/crypto/src/ecies/encrypt.ts'
      via: 'imports wrapKey'
      pattern: 'import.*wrapKey.*from.*encrypt'
    - from: 'packages/crypto/src/ecies/rewrap.ts'
      to: 'packages/crypto/src/ecies/decrypt.ts'
      via: 'imports unwrapKey'
      pattern: 'import.*unwrapKey.*from.*decrypt'
    - from: 'apps/api/src/shares/entities/share.entity.ts'
      to: 'apps/api/src/auth/entities/user.entity.ts'
      via: 'ManyToOne user relations'
      pattern: 'ManyToOne.*User'
---

<objective>
Create the cryptographic foundation (reWrapKey) and database entities (Share, ShareKey) for user-to-user sharing.

Purpose: These are the two independent foundation pieces that all subsequent sharing plans depend on. The crypto utility enables client-side key re-wrapping; the entities define the server-side share record storage.
Output: reWrapKey function with tests, Share and ShareKey TypeORM entities ready for service/controller wiring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-user-to-user-sharing/14-CONTEXT.md
@.planning/phases/14-user-to-user-sharing/14-RESEARCH.md
@packages/crypto/src/ecies/encrypt.ts
@packages/crypto/src/ecies/decrypt.ts
@packages/crypto/src/ecies/index.ts
@packages/crypto/src/__tests__/ecies.test.ts
@packages/crypto/src/constants.ts
@packages/crypto/src/types.ts
@apps/api/src/ipns/entities/folder-ipns.entity.ts
@apps/api/src/auth/entities/user.entity.ts
@apps/api/src/app.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reWrapKey crypto utility with tests</name>
  <files>
    packages/crypto/src/ecies/rewrap.ts
    packages/crypto/src/ecies/index.ts
    packages/crypto/src/__tests__/rewrap.test.ts
  </files>
  <action>
    Create `packages/crypto/src/ecies/rewrap.ts`:

    ```typescript
    export async function reWrapKey(
      ownerWrappedKey: Uint8Array,
      ownerPrivateKey: Uint8Array,
      recipientPublicKey: Uint8Array
    ): Promise<Uint8Array>
    ```

    Implementation:
    1. Import `unwrapKey` from `./decrypt` and `wrapKey` from `./encrypt`
    2. Unwrap the key using ownerPrivateKey: `const plainKey = await unwrapKey(ownerWrappedKey, ownerPrivateKey)`
    3. Re-wrap with recipientPublicKey: `const reWrapped = await wrapKey(plainKey, recipientPublicKey)`
    4. Zero the plaintext key: `plainKey.fill(0)`
    5. Return reWrapped
    6. On any error, throw CryptoError with code 'KEY_REWRAP_FAILED' and generic message 'Key re-wrapping failed'

    Update `packages/crypto/src/ecies/index.ts` to add: `export { reWrapKey } from './rewrap';`

    Create test file `packages/crypto/src/__tests__/rewrap.test.ts`:
    - Test 1: "re-wrapped key decrypts to same value" -- Generate Alice and Bob keypairs using `@noble/secp256k1` keygen. Create random 32-byte key, wrap with Alice's pubkey, reWrapKey to Bob, unwrap with Bob's privkey, verify equals original.
    - Test 2: "re-wrapping preserves key across multiple recipients" -- Same key wrapped for Alice, Bob, and Charlie. All unwrap to identical plaintext.
    - Test 3: "reWrapKey fails with wrong owner private key" -- Should throw CryptoError.
    - Test 4: "reWrapKey fails with invalid recipient public key" -- Should throw CryptoError.

    Use the same test patterns as `packages/crypto/src/__tests__/ecies.test.ts` for keypair generation. Use `@noble/secp256k1` `utils.randomPrivateKey()` and `getPublicKey()` for test key generation (check existing test file for exact API -- v3 uses `secp256k1.keygen()` per STATE.md decision).

  </action>
  <verify>
    Run `pnpm --filter @cipherbox/crypto test -- --grep rewrap` and all 4 tests pass.
    Run `pnpm --filter @cipherbox/crypto build` succeeds.
  </verify>
  <done>
    reWrapKey exported from @cipherbox/crypto, 4 test vectors pass, build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Share and ShareKey TypeORM entities</name>
  <files>
    apps/api/src/shares/entities/share.entity.ts
    apps/api/src/shares/entities/share-key.entity.ts
    apps/api/src/shares/entities/index.ts
  </files>
  <action>
    Create the shares entity directory: `apps/api/src/shares/entities/`

    **share.entity.ts** -- Follow the `FolderIpns` entity pattern exactly:

    ```typescript
    @Entity('shares')
    @Unique(['sharerId', 'recipientId', 'ipnsName'])
    export class Share {
      @PrimaryGeneratedColumn('uuid')
      id!: string;

      @Index()
      @Column({ type: 'uuid', name: 'sharer_id' })
      sharerId!: string;

      @ManyToOne(() => User, { onDelete: 'CASCADE' })
      @JoinColumn({ name: 'sharer_id' })
      sharer!: User;

      @Index()
      @Column({ type: 'uuid', name: 'recipient_id' })
      recipientId!: string;

      @ManyToOne(() => User, { onDelete: 'CASCADE' })
      @JoinColumn({ name: 'recipient_id' })
      recipient!: User;

      @Column({ type: 'varchar', length: 10, name: 'item_type' })
      itemType!: 'folder' | 'file';

      @Index()
      @Column({ type: 'varchar', length: 255, name: 'ipns_name' })
      ipnsName!: string;

      @Column({ type: 'varchar', length: 255, name: 'item_name' })
      itemName!: string;

      @Column({ type: 'bytea', name: 'encrypted_key' })
      encryptedKey!: Buffer;

      @Column({ type: 'boolean', name: 'hidden_by_recipient', default: false })
      hiddenByRecipient!: boolean;

      @Column({ type: 'timestamp', name: 'revoked_at', nullable: true })
      revokedAt!: Date | null;

      @OneToMany(() => ShareKey, (shareKey) => shareKey.share, { cascade: true })
      shareKeys!: ShareKey[];

      @CreateDateColumn({ name: 'created_at' })
      createdAt!: Date;

      @UpdateDateColumn({ name: 'updated_at' })
      updatedAt!: Date;
    }
    ```

    Key design notes:
    - `itemName` stored as plaintext for display (per RESEARCH.md recommendation -- privacy impact is minimal, server already knows user IDs)
    - `revokedAt` for soft-delete lazy rotation pattern (null = active, timestamp = revoked pending rotation)
    - `hiddenByRecipient` for recipient to dismiss unwanted shares
    - Unique constraint on (sharer, recipient, ipnsName) prevents duplicate shares
    - CASCADE delete on user removal cleans up all shares

    **share-key.entity.ts**:

    ```typescript
    @Entity('share_keys')
    @Unique(['shareId', 'keyType', 'itemId'])
    export class ShareKey {
      @PrimaryGeneratedColumn('uuid')
      id!: string;

      @Index()
      @Column({ type: 'uuid', name: 'share_id' })
      shareId!: string;

      @ManyToOne(() => Share, (share) => share.shareKeys, { onDelete: 'CASCADE' })
      @JoinColumn({ name: 'share_id' })
      share!: Share;

      @Column({ type: 'varchar', length: 10, name: 'key_type' })
      keyType!: 'file' | 'folder';

      @Index()
      @Column({ type: 'varchar', length: 255, name: 'item_id' })
      itemId!: string;

      @Column({ type: 'bytea', name: 'encrypted_key' })
      encryptedKey!: Buffer;

      @CreateDateColumn({ name: 'created_at' })
      createdAt!: Date;
    }
    ```

    Key design notes:
    - CASCADE delete from Share ensures revoking a share removes all re-wrapped keys
    - `keyType` distinguishes file keys from subfolder keys
    - `itemId` is the file UUID or subfolder UUID
    - Unique on (shareId, keyType, itemId) prevents duplicate key entries

    **index.ts** barrel:
    ```typescript
    export { Share } from './share.entity';
    export { ShareKey } from './share-key.entity';
    ```

    Do NOT register these entities in app.module.ts yet -- that happens in Plan 02 when the shares module is created.

  </action>
  <verify>
    Run `pnpm --filter api build` succeeds (entities compile without errors).
    Verify entities import User from the correct path.
  </verify>
  <done>
    Share and ShareKey entities exist with correct TypeORM decorators, constraints, and relations. Build passes.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @cipherbox/crypto test` passes (including new rewrap tests)
- `pnpm --filter @cipherbox/crypto build` succeeds
- `pnpm --filter api build` succeeds
- Share entity has Unique constraint on (sharerId, recipientId, ipnsName)
- ShareKey entity has CASCADE delete referencing Share
- reWrapKey correctly round-trips through unwrap + re-wrap
</verification>

<success_criteria>

1. reWrapKey function exported from @cipherbox/crypto with 4 passing test vectors
2. Share entity with all columns matching RESEARCH.md schema (including revokedAt for lazy rotation)
3. ShareKey entity with CASCADE delete and unique constraint
4. Both crypto and API packages build successfully
   </success_criteria>

<output>
After completion, create `.planning/phases/14-user-to-user-sharing/14-01-SUMMARY.md`
</output>
