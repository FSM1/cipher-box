---
phase: 14-user-to-user-sharing
plan: 02
type: execute
wave: 2
depends_on: ['14-01']
files_modified:
  - apps/api/src/shares/dto/create-share.dto.ts
  - apps/api/src/shares/dto/share-key.dto.ts
  - apps/api/src/shares/dto/index.ts
  - apps/api/src/shares/shares.service.ts
  - apps/api/src/shares/shares.controller.ts
  - apps/api/src/shares/shares.module.ts
  - apps/api/src/app.module.ts
  - apps/web/src/api/ (regenerated)
autonomous: true

must_haves:
  truths:
    - 'POST /shares creates a share record with re-wrapped keys'
    - 'GET /shares/received returns shares for the authenticated user'
    - 'GET /shares/sent returns shares created by the authenticated user'
    - 'GET /shares/:shareId/keys returns re-wrapped child keys for a share'
    - 'POST /shares/:shareId/keys adds new re-wrapped keys to an existing share'
    - 'DELETE /shares/:shareId soft-deletes a share (sets revokedAt)'
    - 'PATCH /shares/:shareId/hide marks a share as hidden by recipient'
    - 'GET /users/lookup?publicKey=X verifies publicKey belongs to registered user'
  artifacts:
    - path: 'apps/api/src/shares/shares.service.ts'
      provides: 'Share CRUD operations'
      exports: ['SharesService']
    - path: 'apps/api/src/shares/shares.controller.ts'
      provides: 'Share REST endpoints'
      exports: ['SharesController']
    - path: 'apps/api/src/shares/shares.module.ts'
      provides: 'NestJS shares module'
      exports: ['SharesModule']
    - path: 'apps/api/src/shares/dto/create-share.dto.ts'
      provides: 'Share creation DTO with validation'
      contains: 'class CreateShareDto'
  key_links:
    - from: 'apps/api/src/shares/shares.controller.ts'
      to: 'apps/api/src/shares/shares.service.ts'
      via: 'DI injection'
      pattern: 'constructor.*SharesService'
    - from: 'apps/api/src/shares/shares.module.ts'
      to: 'apps/api/src/app.module.ts'
      via: 'module import'
      pattern: 'SharesModule'
    - from: 'apps/api/src/shares/shares.service.ts'
      to: 'apps/api/src/shares/entities/share.entity.ts'
      via: 'TypeORM repository injection'
      pattern: 'InjectRepository.*Share'
---

<objective>
Build the complete backend shares module with all API endpoints and regenerate the API client.

Purpose: This provides the server-side infrastructure for creating, listing, revoking, and managing share records. The API client regeneration gives the frontend typed access to all share endpoints.
Output: Fully functional NestJS shares module with 8 endpoints, registered in app.module, with regenerated typed API client.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-user-to-user-sharing/14-CONTEXT.md
@.planning/phases/14-user-to-user-sharing/14-RESEARCH.md
@.planning/phases/14-user-to-user-sharing/14-01-SUMMARY.md
@apps/api/src/device-approval/device-approval.controller.ts
@apps/api/src/device-approval/device-approval.service.ts
@apps/api/src/device-approval/device-approval.module.ts
@apps/api/src/device-approval/dto/create-approval.dto.ts
@apps/api/src/auth/entities/user.entity.ts
@apps/api/src/app.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DTOs and shares service</name>
  <files>
    apps/api/src/shares/dto/create-share.dto.ts
    apps/api/src/shares/dto/share-key.dto.ts
    apps/api/src/shares/dto/index.ts
    apps/api/src/shares/shares.service.ts
  </files>
  <action>
    **create-share.dto.ts** -- Validated DTO for POST /shares:

    ```typescript
    import { IsString, IsIn, IsArray, ValidateNested, IsOptional } from 'class-validator';
    import { Type } from 'class-transformer';

    class ChildKeyDto {
      @IsString()
      @IsIn(['file', 'folder'])
      keyType!: 'file' | 'folder';

      @IsString()
      itemId!: string;

      @IsString()
      encryptedKey!: string; // hex-encoded ECIES ciphertext
    }

    export class CreateShareDto {
      @IsString()
      recipientPublicKey!: string; // 0x04... uncompressed secp256k1

      @IsString()
      @IsIn(['folder', 'file'])
      itemType!: 'folder' | 'file';

      @IsString()
      ipnsName!: string; // k51... IPNS name of the shared item

      @IsString()
      itemName!: string; // Display name for the shared item

      @IsString()
      encryptedKey!: string; // hex-encoded root key wrapped for recipient

      @IsArray()
      @ValidateNested({ each: true })
      @Type(() => ChildKeyDto)
      @IsOptional()
      childKeys?: ChildKeyDto[]; // Re-wrapped descendant keys
    }
    ```

    **share-key.dto.ts** -- DTO for POST /shares/:shareId/keys (adding keys to existing share):

    ```typescript
    import { IsString, IsIn, IsArray, ValidateNested } from 'class-validator';
    import { Type } from 'class-transformer';

    class ShareKeyEntryDto {
      @IsString()
      @IsIn(['file', 'folder'])
      keyType!: 'file' | 'folder';

      @IsString()
      itemId!: string;

      @IsString()
      encryptedKey!: string; // hex-encoded
    }

    export class AddShareKeysDto {
      @IsArray()
      @ValidateNested({ each: true })
      @Type(() => ShareKeyEntryDto)
      keys!: ShareKeyEntryDto[];
    }
    ```

    **index.ts** barrel exporting both DTOs.

    **shares.service.ts** -- Service with these methods:

    1. `createShare(sharerId: string, dto: CreateShareDto): Promise<Share>` -- Look up recipient by publicKey in users table. Validate recipient exists and is not the sharer. Check for existing active share (same sharer, recipient, ipnsName). Create Share record with encryptedKey as Buffer.from(dto.encryptedKey, 'hex'). If childKeys provided, create ShareKey records. Return the created share.

    2. `getReceivedShares(recipientId: string): Promise<Share[]>` -- Find shares where recipientId matches and revokedAt IS NULL and hiddenByRecipient is false. Include the sharer relation to get sharerPublicKey. Return ordered by createdAt DESC.

    3. `getSentShares(sharerId: string): Promise<Share[]>` -- Find shares where sharerId matches and revokedAt IS NULL. Include recipient relation. Return ordered by createdAt DESC.

    4. `getShareKeys(shareId: string, userId: string): Promise<ShareKey[]>` -- Verify the share exists and userId is either sharer or recipient. Return all ShareKey records for that share.

    5. `addShareKeys(shareId: string, sharerId: string, dto: AddShareKeysDto): Promise<void>` -- Verify share exists and userId is the sharer. For each key entry, upsert ShareKey record (insert or update encrypted_key if already exists for that itemId).

    6. `revokeShare(shareId: string, sharerId: string): Promise<void>` -- Verify share exists and userId is the sharer. Soft-delete: set revokedAt to current timestamp. Do NOT delete ShareKey records yet (lazy rotation will hard-delete later).

    7. `hideShare(shareId: string, recipientId: string): Promise<void>` -- Verify share exists and userId is the recipient. Set hiddenByRecipient to true.

    8. `lookupUserByPublicKey(publicKey: string): Promise<{ userId: string; publicKey: string } | null>` -- Query users table by publicKey. Return userId and publicKey if found, null otherwise.

    9. `getPendingRotations(sharerId: string): Promise<Share[]>` -- Find shares where sharerId matches and revokedAt IS NOT NULL. These are shares waiting for key rotation.

    10. `completeRotation(shareId: string): Promise<void>` -- Hard-delete the share record and all associated ShareKey records (after key rotation is complete).

    Inject `@InjectRepository(Share)` and `@InjectRepository(ShareKey)` and `@InjectRepository(User)` (from AuthModule -- import User entity).

    Follow the DeviceApproval service pattern for error handling: throw `NotFoundException` when share not found, `ForbiddenException` when user is not authorized, `ConflictException` when share already exists.

  </action>
  <verify>
    Run `pnpm --filter api build` succeeds (service compiles without type errors).
  </verify>
  <done>
    SharesService has all 10 methods implementing the share record CRUD. DTOs have proper class-validator decorations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shares controller, module, register in app.module, and regenerate API client</name>
  <files>
    apps/api/src/shares/shares.controller.ts
    apps/api/src/shares/shares.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    **shares.controller.ts** -- REST controller with JWT auth guard. Follow DeviceApproval controller pattern:

    All endpoints require `@UseGuards(JwtAuthGuard)` and extract userId from `@Req() req`.

    Endpoints:
    1. `@Post()` -- Create share. Body: CreateShareDto. Calls service.createShare(userId, dto). Returns 201 with share record (serialize encryptedKey as hex, include shareId).

    2. `@Get('received')` -- List received shares. Calls service.getReceivedShares(userId). Map each share to response DTO: { shareId, sharerPublicKey (from sharer relation), itemType, ipnsName, itemName, encryptedKey (Buffer to hex), createdAt }.

    3. `@Get('sent')` -- List sent shares. Calls service.getSentShares(userId). Map to response: { shareId, recipientPublicKey, itemType, ipnsName, itemName, createdAt }.

    4. `@Get(':shareId/keys')` -- Get share keys. Param: shareId. Calls service.getShareKeys(shareId, userId). Map each key: { keyType, itemId, encryptedKey (hex) }.

    5. `@Post(':shareId/keys')` -- Add share keys. Param: shareId. Body: AddShareKeysDto. Calls service.addShareKeys(shareId, userId, dto). Returns 201.

    6. `@Delete(':shareId')` -- Revoke share. Param: shareId. Calls service.revokeShare(shareId, userId). Returns 204.

    7. `@Patch(':shareId/hide')` -- Hide share. Param: shareId. Calls service.hideShare(shareId, userId). Returns 204.

    8. `@Get('lookup')` -- User lookup. Query param: publicKey. Calls service.lookupUserByPublicKey(publicKey). Returns { userId, publicKey } or 404. Use @Query('publicKey') decorator.

    Controller path: `@Controller('shares')`.

    **shares.module.ts** -- NestJS module:
    ```typescript
    @Module({
      imports: [
        TypeOrmModule.forFeature([Share, ShareKey, User]),
      ],
      controllers: [SharesController],
      providers: [SharesService],
      exports: [SharesService],
    })
    export class SharesModule {}
    ```

    **app.module.ts** modifications:
    1. Import `SharesModule` from `./shares/shares.module`
    2. Import `Share` and `ShareKey` from `./shares/entities`
    3. Add `Share` and `ShareKey` to the entities array in TypeOrmModule.forRootAsync
    4. Add `SharesModule` to the imports array

    After all files are saved, run `pnpm api:generate` to regenerate the typed API client for the web app.
    Then commit the regenerated client files in `apps/web/src/api/`.

  </action>
  <verify>
    Run `pnpm --filter api build` succeeds.
    Run `pnpm api:generate` succeeds.
    Run `pnpm --filter web build` succeeds (generated client compiles).
    Verify the generated client has share-related endpoints by checking `apps/web/src/api/` for share types.
  </verify>
  <done>
    SharesController has 8 endpoints with JWT auth. SharesModule registered in app.module. Both Share and ShareKey entities in TypeORM config. API client regenerated with typed share endpoints. Full monorepo builds.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter api build` passes
- `pnpm api:generate` succeeds
- `pnpm --filter web build` passes with regenerated client
- POST /shares endpoint exists and accepts CreateShareDto
- GET /shares/received endpoint exists
- DELETE /shares/:shareId endpoint exists
- GET /shares/lookup?publicKey=X endpoint exists
- All endpoints require JWT authentication
</verification>

<success_criteria>

1. 8 REST endpoints functional with proper JWT auth guards
2. Service handles all CRUD operations including soft-delete for revocation
3. User lookup endpoint validates publicKey against users table
4. API client regenerated -- web app has typed access to all share endpoints
5. Full monorepo build succeeds
   </success_criteria>

<output>
After completion, create `.planning/phases/14-user-to-user-sharing/14-02-SUMMARY.md`
</output>
