---
phase: 14-user-to-user-sharing
plan: 04
type: execute
wave: 3
depends_on: ['14-02']
files_modified:
  - apps/web/src/components/file-browser/ShareDialog.tsx
  - apps/web/src/styles/share-dialog.css
  - apps/web/src/components/file-browser/ContextMenu.tsx
  - apps/web/src/components/file-browser/FileBrowser.tsx
autonomous: true

must_haves:
  truths:
    - 'User can open a share dialog from the context menu'
    - 'Share dialog accepts a pasted public key and validates it'
    - 'Share dialog shows existing recipients with per-recipient revoke'
    - 'Context menu has a Share item between Move and Details'
  artifacts:
    - path: 'apps/web/src/components/file-browser/ShareDialog.tsx'
      provides: 'Share modal for creating and managing shares'
      exports: ['ShareDialog']
    - path: 'apps/web/src/styles/share-dialog.css'
      provides: 'Share dialog styles in terminal aesthetic'
      contains: 'share-dialog'
  key_links:
    - from: 'apps/web/src/components/file-browser/ShareDialog.tsx'
      to: 'apps/web/src/services/share.service.ts'
      via: 'createShare, revokeShare, lookupUser calls'
      pattern: 'import.*from.*share.service'
    - from: 'apps/web/src/components/file-browser/FileBrowser.tsx'
      to: 'apps/web/src/components/file-browser/ShareDialog.tsx'
      via: 'renders ShareDialog component'
      pattern: 'ShareDialog'
    - from: 'apps/web/src/components/file-browser/ContextMenu.tsx'
      to: 'apps/web/src/components/file-browser/FileBrowser.tsx'
      via: 'onShare callback prop'
      pattern: 'onShare'
---

<objective>
Build the ShareDialog modal and integrate sharing into the context menu and FileBrowser.

Purpose: This provides the primary UI for sharing -- users open the context menu, click Share, paste a recipient's public key, and see/manage existing share recipients. This is the core user-facing sharing interaction.
Output: ShareDialog component, updated ContextMenu with Share action, FileBrowser wired to open ShareDialog.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-user-to-user-sharing/14-CONTEXT.md
@.planning/phases/14-user-to-user-sharing/14-RESEARCH.md
@.planning/phases/14-user-to-user-sharing/14-02-SUMMARY.md
@apps/web/src/components/file-browser/ContextMenu.tsx
@apps/web/src/components/file-browser/FileBrowser.tsx
@apps/web/src/components/file-browser/DetailsDialog.tsx
@apps/web/src/components/ui/Modal.tsx
@apps/web/src/styles/context-menu.css
@designs/cipher-box-design.pen
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ShareDialog modal component</name>
  <files>
    apps/web/src/components/file-browser/ShareDialog.tsx
    apps/web/src/styles/share-dialog.css
  </files>
  <action>
    Create ShareDialog using the existing Modal component pattern. Spawn a ui-design-researcher agent if design mockups exist in the .pen file, otherwise follow CONTEXT.md spec and terminal aesthetic.

    **ShareDialog.tsx props:**
    ```typescript
    type ShareDialogProps = {
      isOpen: boolean;
      onClose: () => void;
      item: FolderChild; // The item being shared
      folderKey: Uint8Array; // Parent folder's key (for file metadata decryption)
      ipnsName: string; // The item's IPNS name
      parentFolderId: string; // For folder context
    };
    ```

    **Dialog structure (terminal aesthetic per CONTEXT.md):**
    - Title: `SHARE: {item.name}` with `/` suffix for folders
    - Input field: Paste recipient's public key (0x04... format)
    - Submit button: `--share` styled green
    - Validation: Check format (starts with 0x04, 130 hex chars = 65 bytes uncompressed), then call lookupUser API to verify registered user
    - Error states: "invalid key format", "user not found", "cannot share with yourself"
    - Loading state while re-wrapping keys
    - Success feedback: show added recipient in list

    **Existing recipients section:**
    - List of current recipients fetched from `fetchSentShares` or a dedicated endpoint filtered by ipnsName
    - Each recipient shown as truncated pubkey: `0x{first4}...{last4}` (e.g., `0x1a2b...9f0e`)
    - Per-recipient `--revoke` button styled in `#EF4444` (danger red per CONTEXT.md)
    - Inline confirm pattern for revoke: click `--revoke` -> shows `confirm? [y] [n]` -> click y to execute

    **Share creation flow (when user clicks --share):**
    1. Validate public key format (0x04 prefix, 130 hex chars)
    2. Call lookupUser(publicKeyHex) to verify registered user
    3. Get ownerPrivateKey from useAuthStore
    4. Get the item's key:
       - For folders: folderKey is passed as prop
       - For files: resolve FileMetadata via IPNS, unwrap fileKeyEncrypted with ownerPrivateKey
    5. Import reWrapKey from @cipherbox/crypto (or just use wrapKey directly since we have the plaintext key)
       - Actually: for folders, just wrapKey(folderKey, recipientPubKey) since folderKey is already decrypted
       - For files: unwrap fileKeyEncrypted -> fileKey, then wrapKey(fileKey, recipientPubKey)
    6. For folders: traverse children and re-wrap each child key:
       - File children: resolve FileMetadata, unwrap fileKeyEncrypted, wrapKey with recipient
       - Folder children: unwrap folderKeyEncrypted from parent metadata, wrapKey with recipient
       - Recurse into subfolders (depth-first, with progress indicator)
    7. Call createShare API with all wrapped keys
    8. Update sentShares in share store
    9. Show success state, reset input

    **Progress indicator for folder sharing:**
    Show "re-wrapping keys... {n}/{total}" during the traversal. Use a state counter that increments as each key is wrapped.

    **Prevent sharing root folder:**
    If item is the root folder (parentFolderId is 'root' and item represents the root), show error "cannot share root folder".

    Use `bytesToHex` and `hexToBytes` from @cipherbox/crypto for conversions. Use existing Modal component for the dialog wrapper.

  </action>
  <verify>
    Run `pnpm --filter web build` succeeds.
    Verify ShareDialog exports and compiles without type errors.
    Verify it imports from @cipherbox/crypto (wrapKey, unwrapKey, hexToBytes, bytesToHex).
  </verify>
  <done>
    ShareDialog modal renders with public key input, share button, recipient list with revoke, progress indicator for key re-wrapping, and root folder guard.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Share action to ContextMenu and wire in FileBrowser</name>
  <files>
    apps/web/src/components/file-browser/ContextMenu.tsx
    apps/web/src/components/file-browser/FileBrowser.tsx
  </files>
  <action>
    **ContextMenu.tsx modifications:**

    Add a new prop: `onShare?: () => void`

    Add the Share menu item in the single-item (non-multi-select) section, positioned between "Move to..." and "Details" per CONTEXT.md:

    ```tsx
    {/* Share */}
    {onShare && (
      <button
        type="button"
        className="context-menu-item"
        onClick={handleShare}
        role="menuitem"
      >
        <span className="context-menu-item-icon">@</span>
        Share
      </button>
    )}
    ```

    Add handler:
    ```tsx
    const handleShare = () => {
      onShare?.();
      onClose();
    };
    ```

    Position the Share item between "Move to..." and "Details" in the JSX order. Use `@` as the icon character per CONTEXT.md decision.

    **FileBrowser.tsx modifications:**

    1. Add state for ShareDialog:
    ```tsx
    const [shareItem, setShareItem] = useState<FolderChild | null>(null);
    ```

    2. Add handleShare callback:
    ```tsx
    const handleShare = useCallback((item: FolderChild) => {
      setShareItem(item);
    }, []);
    ```

    3. Pass `onShare` to ContextMenu:
    ```tsx
    <ContextMenu
      ...
      onShare={() => handleShare(contextMenuState.item)}
    />
    ```

    4. Render ShareDialog:
    ```tsx
    {shareItem && currentFolder && (
      <ShareDialog
        isOpen={!!shareItem}
        onClose={() => setShareItem(null)}
        item={shareItem}
        folderKey={currentFolder.folderKey}
        ipnsName={shareItem.type === 'folder'
          ? /* get folder ipnsName from folder entry */
          : (shareItem as FilePointer).fileMetaIpnsName}
        parentFolderId={currentFolderId}
      />
    )}
    ```

    For folder items, the ipnsName needs to come from the folder's IPNS name. The FolderEntry in children has `ipnsName` field. Check the FolderEntry type from @cipherbox/crypto to get the correct field name.

    Import ShareDialog at the top of FileBrowser.tsx.

    Do NOT add Share to multi-select context menu (sharing multiple items at once is not supported -- share them individually).

  </action>
  <verify>
    Run `pnpm --filter web build` succeeds.
    Verify ContextMenu has onShare prop in its type definition.
    Verify FileBrowser renders ShareDialog and passes onShare to ContextMenu.
  </verify>
  <done>
    Context menu shows "Share" with @ icon between "Move to..." and "Details". FileBrowser manages ShareDialog state and passes the selected item's context to the dialog.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` passes
- ShareDialog component renders modal with public key input and recipient list
- ContextMenu has Share action with @ icon in correct position
- FileBrowser renders ShareDialog when Share is clicked
- No TypeScript errors
</verification>

<success_criteria>

1. ShareDialog accepts pubkey, validates format and user existence, creates share with re-wrapped keys
2. Folder sharing traverses children and re-wraps all descendant keys with progress indicator
3. File sharing wraps the single file key for recipient
4. Recipient list shows truncated pubkeys with per-recipient revoke (inline confirm)
5. Root folder sharing is prevented
6. Context menu Share item positioned between Move and Details with @ icon
7. Terminal aesthetic maintained throughout
   </success_criteria>

<output>
After completion, create `.planning/phases/14-user-to-user-sharing/14-04-SUMMARY.md`
</output>
