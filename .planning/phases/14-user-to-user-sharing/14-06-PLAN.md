---
phase: 14-user-to-user-sharing
plan: 06
type: execute
wave: 4
depends_on: ['14-03']
files_modified:
  - apps/web/src/hooks/useFolder.ts
  - apps/web/src/services/share.service.ts
  - apps/web/src/services/folder.service.ts
autonomous: true

must_haves:
  truths:
    - 'When uploading a file to a shared folder, re-wrapped keys are sent for all recipients'
    - 'When creating a subfolder in a shared folder, subfolder key is re-wrapped for recipients'
    - 'Revoking a share sets revokedAt and triggers lazy rotation on next modification'
    - 'Lazy rotation generates new folderKey and re-wraps for remaining recipients'
  artifacts:
    - path: 'apps/web/src/hooks/useFolder.ts'
      provides: 'Post-upload and post-create hooks for share key propagation'
      contains: 'addShareKeys'
    - path: 'apps/web/src/services/share.service.ts'
      provides: 'Extended share service with re-wrapping helpers'
      contains: 'reWrapForRecipients'
  key_links:
    - from: 'apps/web/src/hooks/useFolder.ts'
      to: 'apps/web/src/services/share.service.ts'
      via: 'calls re-wrapping after upload/create'
      pattern: 'reWrapForRecipients|addShareKeys'
    - from: 'apps/web/src/services/share.service.ts'
      to: 'packages/crypto/src/ecies/encrypt.ts'
      via: 'wrapKey for re-wrapping'
      pattern: 'wrapKey'
---

<objective>
Implement post-upload key re-wrapping for shared folders and the revocation/lazy-rotation flow.

Purpose: This ensures that when the sharer modifies a shared folder (uploads files, creates subfolders), the new keys are automatically re-wrapped for all existing recipients. It also implements the revocation flow with lazy key rotation.
Output: Post-upload hooks that propagate share keys, revocation with soft-delete, lazy rotation on next modification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-user-to-user-sharing/14-CONTEXT.md
@.planning/phases/14-user-to-user-sharing/14-RESEARCH.md
@.planning/phases/14-user-to-user-sharing/14-03-SUMMARY.md
@apps/web/src/hooks/useFolder.ts
@apps/web/src/services/upload.service.ts
@apps/web/src/services/folder.service.ts
@apps/web/src/stores/share.store.ts
@apps/web/src/services/share.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add post-upload and post-create share key propagation</name>
  <files>
    apps/web/src/services/share.service.ts
    apps/web/src/hooks/useFolder.ts
  </files>
  <action>
    **share.service.ts additions:**

    Add a helper function that checks if a folder has active shares and re-wraps new keys for all recipients:

    ```typescript
    /**
     * After adding a file or subfolder to a shared folder, re-wrap the new key
     * for all existing share recipients.
     *
     * This is a fire-and-forget operation -- failures are logged but don't block
     * the primary upload/create flow.
     */
    export async function reWrapForRecipients(params: {
      folderIpnsName: string;
      newItems: Array<{
        keyType: 'file' | 'folder';
        itemId: string;
        plaintextKey: Uint8Array;
      }>;
    }): Promise<void>
    ```

    Implementation:
    1. Fetch sent shares filtered by folderIpnsName (GET /shares/sent, filter by ipnsName matching the folder or any ancestor)
    2. If no active shares for this folder, return immediately (common case optimization)
    3. For each share recipient:
       a. For each new item, call `wrapKey(plaintextKey, hexToBytes(recipientPublicKey))`
       b. Collect all wrapped keys
    4. For each share, call addShareKeys(shareId, wrappedKeys) to store in share_keys table
    5. Zero all plaintext keys after wrapping
    6. Log any errors but do not throw (non-blocking)

    Also add:
    ```typescript
    /**
     * Check if a folder (by IPNS name) has any active shares.
     * Used to decide whether post-upload re-wrapping is needed.
     */
    export async function hasActiveShares(folderIpnsName: string): Promise<boolean>
    ```

    This checks the sent shares in the store (or fetches if stale) for any share matching the given IPNS name. This is a quick check before doing expensive re-wrapping.

    Also add ancestor share detection: when uploading to a subfolder of a shared folder, we need to check if ANY ancestor folder is shared. This requires walking up the folder tree (using folder.store breadcrumbs) and checking each folder's IPNS name against sent shares.

    ```typescript
    /**
     * Find active shares that cover a given folder, including ancestor shares.
     * A folder is "covered" if it or any of its ancestor folders is shared.
     */
    export async function findCoveringShares(
      folderIpnsName: string,
      ancestorIpnsNames: string[]
    ): Promise<SentShare[]>
    ```

    **useFolder.ts modifications:**

    Find the upload completion handler (where new files are added to folder metadata) and add a post-upload hook:

    After a successful file upload:
    1. Check if current folder or any ancestor has active shares (findCoveringShares)
    2. If yes, call reWrapForRecipients with the new file's key
    3. Do this asynchronously (don't block upload completion UI)

    Similarly, after creating a new subfolder:
    1. Check for covering shares
    2. If yes, re-wrap the new subfolder's folderKey for all recipients

    The key insight is that the upload/create flow already has access to the plaintext keys (fileKey for files, folderKey for new subfolders) before they're discarded. The hook captures these keys before they're zeroed and passes them to reWrapForRecipients.

    Implementation approach:
    - In the `uploadFiles` or `handleUpload` function within useFolder, after the file is successfully uploaded and metadata published, check for shares and re-wrap
    - In the `createSubfolder` function, after the subfolder is created and metadata published, check for shares and re-wrap
    - Wrap both in try-catch with console.warn on failure (non-blocking)

    Be careful with Zustand stale closures: use `useShareStore.getState()` inside async callbacks, not the hook selector (per MEMORY.md lesson about Zustand stale closures).

  </action>
  <verify>
    Run `pnpm --filter web build` succeeds.
    Verify share.service.ts exports reWrapForRecipients and findCoveringShares.
    Verify useFolder.ts has post-upload re-wrapping logic.
  </verify>
  <done>
    Post-upload hook checks for active shares and re-wraps new file/folder keys for all recipients. Post-create-subfolder hook does the same. Both are non-blocking (fire-and-forget with error logging). Ancestor share detection covers nested folders.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement lazy key rotation on folder modification after revoke</name>
  <files>
    apps/web/src/services/folder.service.ts
    apps/web/src/services/share.service.ts
  </files>
  <action>
    **Lazy rotation protocol:**

    Per CONTEXT.md and RESEARCH.md: revoking a share sets revokedAt but does NOT immediately rotate the folderKey. Key rotation happens on the sharer's next folder modification.

    **share.service.ts additions:**

    ```typescript
    /**
     * Check if a folder has pending rotations (revoked shares awaiting key rotation).
     * Called before any folder modification.
     */
    export async function checkPendingRotation(folderIpnsName: string): Promise<boolean>
    ```

    Implementation: Check sent shares (from store or API) for any share with this IPNS name where revokedAt is not null. Return true if any exist.

    ```typescript
    /**
     * Execute lazy key rotation for a folder.
     * Called when a folder modification is about to happen and pending rotations exist.
     *
     * 1. Generate new folderKey
     * 2. Re-encrypt folder metadata with new folderKey
     * 3. Re-wrap new folderKey with owner's publicKey (for parent metadata)
     * 4. Re-wrap new folderKey for each REMAINING (non-revoked) recipient
     * 5. Update parent metadata's folderKeyEncrypted
     * 6. Update share records with new encryptedKey
     * 7. Hard-delete revoked share records (rotation complete)
     *
     * Returns the new folderKey so the caller uses it for the modification.
     */
    export async function executeLazyRotation(params: {
      folderIpnsName: string;
      oldFolderKey: Uint8Array;
      ownerPrivateKey: Uint8Array;
      ownerPublicKey: Uint8Array;
      parentFolderId: string;
    }): Promise<{ newFolderKey: Uint8Array }>
    ```

    Implementation:
    1. Generate new random 32-byte folderKey: `crypto.getRandomValues(new Uint8Array(32))`
    2. Re-read and decrypt current folder metadata with oldFolderKey
    3. Re-encrypt folder metadata with newFolderKey (re-encrypt all children's metadata)
    4. For child folders: their folderKeyEncrypted stays the same (they have their own keys). Only the metadata blob is re-encrypted.
    5. Actually -- the key that rotates is the folderKey used to encrypt the folder's metadata blob. The children's own keys don't change. What changes:
       - Folder metadata is re-encrypted with newFolderKey
       - Parent metadata's `folderKeyEncrypted` entry for this folder is updated (re-wrapped with owner's publicKey using newFolderKey)
       - Each remaining recipient's share record gets newFolderKey wrapped with their publicKey
    6. Publish updated IPNS record with re-encrypted metadata
    7. Update parent folder's metadata to use new folderKeyEncrypted for this child
    8. Publish parent's IPNS record
    9. For each remaining (non-revoked) share: create new share record with newFolderKey wrapped for recipient, or update existing share's encryptedKey
    10. Hard-delete revoked shares (API call to completeRotation or direct DELETE)
    11. Return newFolderKey

    **folder.service.ts modifications:**

    Before any folder modification (upload, create subfolder, rename, move, delete), check for pending rotation:

    Add a `checkAndRotateIfNeeded` call at the start of modification operations. This function:
    1. Calls checkPendingRotation(folderIpnsName)
    2. If pending, calls executeLazyRotation
    3. Updates the folder node in folder.store with the new folderKey
    4. Returns the (possibly new) folderKey for the caller to use

    Integrate this check into the existing folder modification flow. The key is to check BEFORE the modification and use the rotated key for the new operation.

    NOTE: Rotation is a complex operation. For Phase 14, implement the detection and flag-setting (checkPendingRotation returns true). The full rotation execution (re-encrypting metadata, re-publishing) is complex enough to warrant careful implementation. Implement the full flow but test it thoroughly. If the rotation flow becomes too complex, implement the detection and soft-delete, and leave immediate rotation as a follow-up. The security guarantee is maintained because revoked users lose API access to share_keys immediately.

    Key safety: zero old folderKey after rotation completes. Update folder store with new key.

  </action>
  <verify>
    Run `pnpm --filter web build` succeeds.
    Verify share.service.ts exports checkPendingRotation and executeLazyRotation.
    Verify folder.service.ts calls checkAndRotateIfNeeded before modifications.
  </verify>
  <done>
    Lazy rotation flow: revoke sets revokedAt (soft-delete), next folder modification detects pending rotation, generates new folderKey, re-encrypts metadata, re-wraps for remaining recipients, hard-deletes revoked records. New folderKey propagated to folder store and used for the modification.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` passes
- Post-upload hook re-wraps file keys for share recipients
- Post-create-subfolder hook re-wraps folder keys for share recipients
- Revocation sets revokedAt (soft-delete) without deleting share_keys
- Pending rotation detection returns true when revoked shares exist
- Lazy rotation generates new folderKey, re-encrypts, re-wraps, hard-deletes
- All operations non-blocking where appropriate (upload isn't slowed by re-wrapping)
- Full monorepo build succeeds
</verification>

<success_criteria>

1. Uploading to a shared folder automatically re-wraps the new file key for all recipients
2. Creating a subfolder in a shared folder re-wraps the subfolder key for recipients
3. Revoking a share sets revokedAt but preserves share_keys until rotation
4. Next folder modification after revoke rotates the folderKey
5. Remaining recipients get re-wrapped new folderKey
6. Revoked shares are hard-deleted after rotation completes
7. No plaintext keys leaked or left un-zeroed in memory
   </success_criteria>

<output>
After completion, create `.planning/phases/14-user-to-user-sharing/14-06-SUMMARY.md`
</output>
