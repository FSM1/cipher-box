---
phase: 04.2-local-ipfs-testing
plan: 02
type: execute
wave: 2
depends_on: ["04.2-01"]
files_modified:
  - .github/workflows/ci.yml
  - apps/api/src/ipfs/providers/local.provider.spec.ts
  - apps/api/test/ipfs.e2e-spec.ts
  - apps/api/test/jest-e2e.json
autonomous: true

must_haves:
  truths:
    - "CI workflow includes IPFS service container"
    - "LocalProvider has unit tests covering pin/unpin/get operations"
    - "Integration tests run against local IPFS node"
    - "Tests pass in CI with local IPFS node"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "IPFS service container in test job"
      contains: "ipfs/kubo"
    - path: "apps/api/src/ipfs/providers/local.provider.spec.ts"
      provides: "LocalProvider unit tests"
      min_lines: 80
    - path: "apps/api/test/ipfs.e2e-spec.ts"
      provides: "IPFS integration tests"
      min_lines: 50
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "apps/api/src/ipfs/providers/local.provider.ts"
      via: "IPFS_PROVIDER=local env var in test step"
      pattern: "IPFS_PROVIDER:\\s*local"
    - from: "apps/api/test/ipfs.e2e-spec.ts"
      to: "apps/api/src/ipfs/providers/local.provider.ts"
      via: "E2E tests use local provider"
      pattern: "ipfs/add|pinFile"
---

<objective>
Add IPFS integration tests and CI service container

Purpose: Ensure the local IPFS provider is tested and CI can run tests without external Pinata dependencies. This completes the local IPFS testing infrastructure.

Output:
- GitHub Actions CI with IPFS service container
- LocalProvider unit tests
- E2E integration tests for IPFS operations
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.2-local-ipfs-testing/04.2-CONTEXT.md
@.planning/phases/04.2-local-ipfs-testing/04.2-RESEARCH.md
@.planning/phases/04.2-local-ipfs-testing/04.2-01-SUMMARY.md

# Files created in Plan 01
@apps/api/src/ipfs/providers/local.provider.ts
@apps/api/src/ipfs/providers/ipfs-provider.interface.ts
@.github/workflows/ci.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPFS service container to GitHub Actions CI</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Add IPFS service container to the `test` job in ci.yml:

```yaml
services:
  postgres:
    # ... existing postgres config
  ipfs:
    image: ipfs/kubo:v0.39.0
    ports:
      - 5001:5001
      - 8080:8080
    options: >-
      --health-cmd "ipfs id"
      --health-interval 10s
      --health-timeout 5s
      --health-retries 10
      --health-start-period 30s
```

Add environment variables to the "Run tests" step:
```yaml
- name: Run tests
  run: pnpm test
  env:
    # ... existing env vars
    IPFS_PROVIDER: local
    IPFS_LOCAL_API_URL: http://localhost:5001
    IPFS_LOCAL_GATEWAY_URL: http://localhost:8080
```

Also add IPFS service to `api-spec` job since it runs the API for OpenAPI generation.

IMPORTANT per RESEARCH.md:
- Use health-start-period of 30s - Kubo needs time to initialize
- Health check retries should be 10+ to handle slow CI runners
- No CORS issues when running on same host
  </action>
  <verify>
Validate workflow syntax:
- Push to a test branch and check Actions tab for syntax errors
- Or use `act` locally if available: `act -n`

Check IPFS service starts in CI (will verify in actual PR):
- Service container should be healthy before tests run
  </verify>
  <done>CI workflow includes IPFS service container with proper health checks</done>
</task>

<task type="auto">
  <name>Task 2: Create LocalProvider unit tests</name>
  <files>apps/api/src/ipfs/providers/local.provider.spec.ts</files>
  <action>
Create unit tests for LocalProvider that mock fetch:

```typescript
// apps/api/src/ipfs/providers/local.provider.spec.ts
import { BadRequestException, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import { LocalProvider } from './local.provider';

describe('LocalProvider', () => {
  let provider: LocalProvider;
  let mockFetch: jest.Mock;
  const API_URL = 'http://localhost:5001';
  const GATEWAY_URL = 'http://localhost:8080';

  beforeEach(() => {
    mockFetch = jest.fn();
    global.fetch = mockFetch;
    provider = new LocalProvider(API_URL, GATEWAY_URL);
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('pinFile', () => {
    // Test cases:
    // - Returns { cid, size } on successful pin
    // - Uses POST method (not PUT/GET)
    // - Includes cid-version=1 in query params
    // - Throws BadRequestException for empty buffer
    // - Throws InternalServerErrorException on Kubo error
    // - Throws InternalServerErrorException on network error
  });

  describe('unpinFile', () => {
    // Test cases:
    // - Returns void on successful unpin
    // - Uses POST method (not DELETE)
    // - Treats "not pinned" error as success (idempotent)
    // - Throws BadRequestException for empty CID
    // - Throws InternalServerErrorException on other Kubo errors
  });

  describe('getFile', () => {
    // Test cases:
    // - Returns Buffer on success
    // - Uses POST method (not GET)
    // - Throws NotFoundException for missing CID
    // - Throws InternalServerErrorException on Kubo error
  });
});
```

Cover the same scenarios as the existing Pinata provider tests, adapted for Kubo's API behavior:
- Kubo returns 500 with error text for not found (not 404)
- Kubo returns JSON `{ Hash: string, Name: string, Size: string }` for add
- Size is a string in Kubo response, needs parseInt

Test edge cases specific to Kubo:
- "not pinned" in error response means already unpinned
- "not found" or "no link" in error response means CID doesn't exist
  </action>
  <verify>
Run LocalProvider tests:
- `pnpm -F api test -- --testPathPattern=local.provider.spec.ts`

All tests pass and cover key scenarios.
  </verify>
  <done>LocalProvider has comprehensive unit tests covering all IpfsProvider methods</done>
</task>

<task type="auto">
  <name>Task 3: Create IPFS E2E integration tests</name>
  <files>
apps/api/test/ipfs.e2e-spec.ts
apps/api/test/jest-e2e.json
  </files>
  <action>
Create E2E tests that run against a real local IPFS node:

1. Check/update `apps/api/test/jest-e2e.json` to ensure it can run E2E tests:
```json
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  },
  "moduleNameMapper": {
    "^jose$": "<rootDir>/../node_modules/jose/dist/node/cjs/index.js"
  }
}
```

2. Create `apps/api/test/ipfs.e2e-spec.ts`:
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('IPFS E2E (local node)', () => {
  let app: INestApplication;
  let authToken: string;

  // Skip if IPFS_PROVIDER !== 'local' or local node not available
  const skipIfNotLocal = process.env.IPFS_PROVIDER !== 'local';

  beforeAll(async () => {
    if (skipIfNotLocal) return;

    // Health check - verify local IPFS is running
    try {
      const response = await fetch('http://localhost:5001/api/v0/id', { method: 'POST' });
      if (!response.ok) throw new Error('IPFS not responding');
    } catch {
      console.warn('Skipping IPFS E2E tests - local node not available');
      return;
    }

    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // Get auth token for protected endpoints
    // (mock or use test user based on project auth setup)
  });

  afterAll(async () => {
    if (app) await app.close();
    // Run garbage collection to clean up test pins
    if (!skipIfNotLocal) {
      try {
        await fetch('http://localhost:5001/api/v0/repo/gc', { method: 'POST' });
      } catch { /* ignore GC errors */ }
    }
  });

  describe('/ipfs/add (POST)', () => {
    it.skipIf(skipIfNotLocal)('should pin file and return CID', async () => {
      const testContent = Buffer.from('test content for E2E');

      const response = await request(app.getHttpServer())
        .post('/ipfs/add')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', testContent, 'test.bin')
        .expect(201);

      expect(response.body.cid).toMatch(/^bafy/); // CIDv1 prefix
      expect(response.body.size).toBeGreaterThan(0);

      // Verify file is actually pinned in local node
      const pinCheck = await fetch(
        `http://localhost:5001/api/v0/pin/ls?arg=${response.body.cid}`,
        { method: 'POST' }
      );
      expect(pinCheck.ok).toBe(true);
    });
  });

  describe('/ipfs/unpin (POST)', () => {
    it.skipIf(skipIfNotLocal)('should unpin previously pinned file', async () => {
      // First pin a file
      const testContent = Buffer.from('content to unpin');
      const addResponse = await request(app.getHttpServer())
        .post('/ipfs/add')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', testContent, 'test.bin')
        .expect(201);

      const cid = addResponse.body.cid;

      // Then unpin it
      await request(app.getHttpServer())
        .post('/ipfs/unpin')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ cid })
        .expect(201);

      // Verify file is no longer pinned
      const pinCheck = await fetch(
        `http://localhost:5001/api/v0/pin/ls?arg=${cid}`,
        { method: 'POST' }
      );
      expect(pinCheck.ok).toBe(false); // Should fail - not pinned
    });
  });
});
```

Key considerations:
- Skip tests gracefully if IPFS_PROVIDER !== 'local'
- Health check before running tests
- Clean up with `ipfs repo gc` after tests
- Use CIDv1 prefix check (bafy...) to verify correct cidVersion
- Verify pins exist in local node after add
  </action>
  <verify>
Run E2E tests with local IPFS:
1. Start Docker Compose: `docker compose -f docker/docker-compose.yml up -d`
2. Wait for IPFS: `until curl -s -X POST http://localhost:5001/api/v0/id > /dev/null; do sleep 1; done`
3. Run E2E: `IPFS_PROVIDER=local pnpm -F api test:e2e`

Tests should pass when local node is running, skip gracefully when not.
  </verify>
  <done>E2E integration tests exist and run against local IPFS node</done>
</task>

</tasks>

<verification>
1. LocalProvider unit tests pass:
   `pnpm -F api test -- --testPathPattern=local.provider`

2. E2E tests pass with local IPFS:
   ```bash
   docker compose -f docker/docker-compose.yml up -d ipfs
   sleep 30  # Wait for IPFS to initialize
   IPFS_PROVIDER=local pnpm -F api test:e2e
   ```

3. All existing tests still pass:
   `pnpm test`

4. CI workflow validates (push to branch and check Actions):
   - IPFS service container starts
   - Tests run with IPFS_PROVIDER=local
   - All tests pass

5. Verify GC runs after tests:
   Check IPFS repo size doesn't grow indefinitely with repeated test runs.
</verification>

<success_criteria>
- GitHub Actions CI includes IPFS service container with health checks
- LocalProvider has unit tests with >80% coverage
- E2E tests run against local IPFS node
- Tests skip gracefully when local IPFS not available
- CI pipeline passes with local IPFS provider
- Cleanup (GC) runs after test suites
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-local-ipfs-testing/04.2-02-SUMMARY.md`
</output>
