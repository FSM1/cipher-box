# Phase 4.2: Local IPFS Testing Infrastructure - Research

**Researched:** 2026-01-21
**Domain:** Docker/Kubo IPFS, NestJS Provider Patterns, GitHub Actions Service Containers
**Confidence:** HIGH

## Summary

This research covers the technical implementation details for adding a local IPFS node (Kubo) to the Docker Compose stack and abstracting the existing IpfsService to support multiple providers. The key areas investigated are:

1. **Kubo Docker Configuration** - Official ipfs/kubo image, ports, volumes, and health checks
2. **Kubo HTTP RPC API** - Direct HTTP calls for pin, unpin, and get operations (no SDK)
3. **NestJS Provider Pattern** - Dynamic module with factory pattern to switch implementations
4. **GitHub Actions Integration** - Service container configuration for CI workflows

**Primary recommendation:** Use the strategy pattern with a single `IpfsProvider` interface, implement `PinataProvider` (existing logic) and `LocalProvider` (Kubo HTTP API), and use NestJS dynamic module `forRootAsync` to inject the correct provider based on `IPFS_PROVIDER` environment variable.

## Standard Stack

The established tools for this domain:

### Core
| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| ipfs/kubo | v0.34.0 | Local IPFS node | Official Go implementation, most stable |
| Docker Compose | 3.8+ | Container orchestration | Already used in project |
| NestJS ConfigService | @nestjs/config | Environment-based configuration | Already in project |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| form-data | existing | Multipart form encoding | Already used for Pinata |
| node-fetch or global fetch | existing | HTTP requests | Already used in IpfsService |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Kubo | js-ipfs | Kubo is more stable/production-grade |
| HTTP API | ipfs-http-client SDK | Direct HTTP is simpler, matches existing Pinata approach |
| Docker volume | tmpfs | Volume persists data for faster subsequent runs |

## Architecture Patterns

### Recommended Project Structure
```
apps/api/src/ipfs/
├── ipfs.module.ts           # Dynamic module with forRootAsync
├── ipfs.controller.ts       # Unchanged - uses IpfsProvider interface
├── providers/
│   ├── ipfs-provider.interface.ts    # Abstract interface
│   ├── pinata.provider.ts            # Pinata implementation (refactored from ipfs.service.ts)
│   └── local.provider.ts             # Kubo HTTP API implementation
├── dto/                     # Unchanged
└── errors/
    └── ipfs.errors.ts       # Common error types
```

### Pattern 1: Provider Interface with Strategy Pattern
**What:** Define an abstract interface that both Pinata and Local providers implement
**When to use:** When you need to swap implementations based on configuration
**Example:**
```typescript
// Source: NestJS Strategy Pattern best practices
// apps/api/src/ipfs/providers/ipfs-provider.interface.ts
export interface IpfsProvider {
  pinFile(data: Buffer, metadata?: Record<string, string>): Promise<{ cid: string; size: number }>;
  unpinFile(cid: string): Promise<void>;
  getFile(cid: string): Promise<Buffer>;
}

export const IPFS_PROVIDER = 'IPFS_PROVIDER';
```

### Pattern 2: Dynamic Module with useFactory
**What:** Module that reads config at startup and provides the correct implementation
**When to use:** When provider selection is determined by environment variables
**Example:**
```typescript
// Source: NestJS Dynamic Modules documentation
// apps/api/src/ipfs/ipfs.module.ts
import { Module, DynamicModule } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { IPFS_PROVIDER, IpfsProvider } from './providers/ipfs-provider.interface';
import { PinataProvider } from './providers/pinata.provider';
import { LocalProvider } from './providers/local.provider';

@Module({})
export class IpfsModule {
  static forRootAsync(): DynamicModule {
    return {
      module: IpfsModule,
      imports: [ConfigModule],
      providers: [
        {
          provide: IPFS_PROVIDER,
          useFactory: (configService: ConfigService): IpfsProvider => {
            const provider = configService.get<string>('IPFS_PROVIDER', 'pinata');

            if (provider === 'local') {
              const apiUrl = configService.get<string>('IPFS_LOCAL_API_URL', 'http://localhost:5001');
              const gatewayUrl = configService.get<string>('IPFS_LOCAL_GATEWAY_URL', 'http://localhost:8080');
              return new LocalProvider(apiUrl, gatewayUrl);
            }

            const jwt = configService.get<string>('PINATA_JWT');
            if (!jwt) {
              throw new Error('PINATA_JWT environment variable is required when IPFS_PROVIDER=pinata');
            }
            return new PinataProvider(jwt);
          },
          inject: [ConfigService],
        },
      ],
      controllers: [IpfsController],
      exports: [IPFS_PROVIDER],
    };
  }
}
```

### Anti-Patterns to Avoid
- **Conditional logic in service methods:** Don't add if/else checks for provider type inside methods. Use the interface pattern instead.
- **Silent fallback:** Don't fall back to Pinata if local node is unavailable. Fail fast with clear error.
- **Mixing concerns:** Keep provider-specific logic in provider classes, not in the controller.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Multipart form encoding | Manual boundary construction | form-data package | Edge cases with binary data |
| CID validation | Regex matching | Accept any string, let IPFS validate | IPFS will return clear errors |
| Docker health checks | Custom polling script | Docker HEALTHCHECK instruction | Standard, well-tested |
| Config injection | Manual process.env reads | NestJS ConfigService | Type-safe, testable |

**Key insight:** The Kubo HTTP API is straightforward enough that no SDK is needed. Direct fetch calls match the existing Pinata implementation approach.

## Common Pitfalls

### Pitfall 1: Kubo API Port Exposure
**What goes wrong:** Exposing port 5001 publicly allows admin-level node control
**Why it happens:** Developers copy-paste configs without understanding security
**How to avoid:** Bind to localhost only: `127.0.0.1:5001:5001`
**Warning signs:** Using `0.0.0.0:5001:5001` or just `5001:5001`

### Pitfall 2: GitHub Actions Service Container Timing
**What goes wrong:** Tests start before IPFS node is ready
**Why it happens:** GitHub Actions only retries health checks 5-6 times (~30s total)
**How to avoid:** Use explicit health check with sufficient retries in workflow options
**Warning signs:** Intermittent test failures in CI but not locally

### Pitfall 3: Kubo HTTP API All Methods are POST
**What goes wrong:** Using GET/DELETE for retrieve/unpin operations
**Why it happens:** Assuming REST conventions apply
**How to avoid:** All Kubo RPC endpoints use POST method
**Warning signs:** 404 or 405 errors from Kubo API

### Pitfall 4: Missing Origin Header for Kubo API
**What goes wrong:** API returns 403 Forbidden
**Why it happens:** Kubo validates Origin header for CORS protection
**How to avoid:** Either configure CORS in Kubo or run from same host
**Warning signs:** 403 errors only when calling from different origin

### Pitfall 5: NestJS Provider Token Mismatch
**What goes wrong:** Injection fails silently or returns undefined
**Why it happens:** Using class name instead of token for injection
**How to avoid:** Use `@Inject(IPFS_PROVIDER)` not `@Inject(IpfsProvider)`
**Warning signs:** "Cannot read property of undefined" in controller

## Code Examples

Verified patterns from official sources:

### Kubo HTTP API: Add/Pin File
```typescript
// Source: https://docs.ipfs.tech/reference/kubo/rpc/
// All Kubo RPC endpoints use POST method
async pinFile(data: Buffer): Promise<{ cid: string; size: number }> {
  const formData = new FormData();
  formData.append('file', Readable.from(data), {
    filename: `file-${Date.now()}`,
    contentType: 'application/octet-stream',
  });

  // pin=true is default, cidVersion=1 for CIDv1
  const response = await fetch(
    `${this.apiUrl}/api/v0/add?pin=true&cid-version=1`,
    {
      method: 'POST',
      body: formData as unknown as BodyInit,
      headers: formData.getHeaders(),
    }
  );

  if (!response.ok) {
    throw new Error(`Kubo add failed: ${response.status}`);
  }

  const result = await response.json();
  // Response: { Hash: string, Name: string, Size: string }
  return {
    cid: result.Hash,
    size: parseInt(result.Size, 10),
  };
}
```

### Kubo HTTP API: Unpin File
```typescript
// Source: https://docs.ipfs.tech/reference/kubo/rpc/
async unpinFile(cid: string): Promise<void> {
  const response = await fetch(
    `${this.apiUrl}/api/v0/pin/rm?arg=${cid}`,
    { method: 'POST' }
  );

  // 500 with "not pinned" message means already unpinned - treat as success
  if (!response.ok) {
    const text = await response.text();
    if (text.includes('not pinned')) {
      return; // Idempotent - already unpinned
    }
    throw new Error(`Kubo unpin failed: ${response.status} - ${text}`);
  }
}
```

### Kubo HTTP API: Get File (Cat)
```typescript
// Source: https://docs.ipfs.tech/reference/kubo/rpc/
async getFile(cid: string): Promise<Buffer> {
  const response = await fetch(
    `${this.apiUrl}/api/v0/cat?arg=${cid}`,
    { method: 'POST' }
  );

  if (!response.ok) {
    if (response.status === 500) {
      const text = await response.text();
      if (text.includes('not found') || text.includes('no link')) {
        throw new NotFoundException(`CID not found: ${cid}`);
      }
    }
    throw new Error(`Kubo cat failed: ${response.status}`);
  }

  return Buffer.from(await response.arrayBuffer());
}
```

### Docker Compose: Kubo Service
```yaml
# Source: https://github.com/ipfs/kubo/blob/master/docker-compose.yaml
# docker/docker-compose.yml
services:
  ipfs:
    image: ipfs/kubo:v0.39.0
    container_name: cipherbox-ipfs
    restart: unless-stopped
    environment:
      - IPFS_PATH=/data/ipfs
    volumes:
      - ipfs_data:/data/ipfs
    ports:
      # Swarm - P2P connections (can be public)
      - "4001:4001/tcp"
      - "4001:4001/udp"
      # API - admin access (localhost only!)
      - "127.0.0.1:5001:5001"
      # Gateway - read access (localhost only for dev)
      - "127.0.0.1:8080:8080"
    healthcheck:
      test: ["CMD-SHELL", "ipfs id || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'

volumes:
  ipfs_data:
```

### GitHub Actions: IPFS Service Container
```yaml
# Source: GitHub Actions service containers documentation
# .github/workflows/ci.yml (test job modification)
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        # ... existing postgres config
      ipfs:
        image: ipfs/kubo:v0.39.0
        ports:
          - 5001:5001
          - 8080:8080
        options: >-
          --health-cmd "ipfs id"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10
          --health-start-period 30s
    steps:
      # ... existing steps
      - name: Run tests
        run: pnpm test
        env:
          IPFS_PROVIDER: local
          IPFS_LOCAL_API_URL: http://localhost:5001
          IPFS_LOCAL_GATEWAY_URL: http://localhost:8080
          # ... other env vars
```

### NestJS Controller with Provider Injection
```typescript
// Source: NestJS custom providers documentation
// apps/api/src/ipfs/ipfs.controller.ts
import { Controller, Inject } from '@nestjs/common';
import { IPFS_PROVIDER, IpfsProvider } from './providers/ipfs-provider.interface';

@Controller('ipfs')
export class IpfsController {
  constructor(
    @Inject(IPFS_PROVIDER) private readonly ipfsProvider: IpfsProvider
  ) {}

  async add(file: Express.Multer.File): Promise<AddResponseDto> {
    return this.ipfsProvider.pinFile(file.buffer);
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| js-ipfs (JavaScript implementation) | Kubo (Go implementation) | 2023 | js-ipfs deprecated, Kubo is standard |
| CIDv0 (Qm... hashes) | CIDv1 (bafy... hashes) | 2020+ | CIDv1 is modern standard |
| ipfs-http-client SDK | Direct HTTP API | Ongoing | SDK adds overhead, HTTP is simpler |

**Deprecated/outdated:**
- js-ipfs: Maintenance mode, use Kubo instead
- IPFS_PROFILE=lowpower: Not recommended for testing, use defaults

## Open Questions

Things that couldn't be fully resolved:

1. **Exact memory/CPU limits for IPFS container**
   - What we know: Kubo recommends 6GB RAM for production, 2GB works for development
   - What's unclear: Optimal limits for CI environment with brief test workloads
   - Recommendation: Start with 2GB memory, 1 CPU; adjust if tests fail

2. **Test parallelism with shared IPFS node**
   - What we know: Multiple tests can use same node simultaneously
   - What's unclear: Whether parallel tests need CID namespacing
   - Recommendation: Run IPFS integration tests sequentially initially; optimize later if slow

3. **IPFS garbage collection timing**
   - What we know: `ipfs repo gc` cleans up unpinned content
   - What's unclear: Whether to run GC after each test or once at end
   - Recommendation: Run once after test suite completes (afterAll hook)

## Sources

### Primary (HIGH confidence)
- [IPFS Kubo RPC API Documentation](https://docs.ipfs.tech/reference/kubo/rpc/) - Complete HTTP API reference for add, pin, unpin, cat operations
- [IPFS Docker Installation Guide](https://docs.ipfs.tech/install/run-ipfs-inside-docker/) - Official Docker setup with ports, volumes, environment variables
- [Kubo Official docker-compose.yaml](https://github.com/ipfs/kubo/blob/master/docker-compose.yaml) - Reference Docker Compose configuration
- [GitHub Actions Service Containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers) - Service container syntax and health checks

### Secondary (MEDIUM confidence)
- [NestJS Dynamic Modules](https://docs.nestjs.com/fundamentals/dynamic-modules) - forRootAsync pattern with useFactory
- [NestJS Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers) - Provider tokens and injection
- [DEV.to NestJS Dynamic Modules](https://dev.to/nestjs/advanced-nestjs-how-to-build-completely-dynamic-nestjs-modules-1370) - Practical examples of registerAsync pattern

### Tertiary (LOW confidence)
- [Wait for Services Action](https://github.com/marketplace/actions/wait-for-services) - Third-party action for health check waiting (may not be needed with proper options)

## Metadata

**Confidence breakdown:**
- Kubo Docker setup: HIGH - Official documentation and docker-compose.yaml from IPFS team
- Kubo HTTP API: HIGH - Official RPC documentation with clear examples
- NestJS provider pattern: HIGH - Well-documented NestJS feature, matches existing TypeOrmModule.forRootAsync usage in project
- GitHub Actions service containers: HIGH - Official GitHub documentation, follows same pattern as existing postgres service
- Resource limits: MEDIUM - Recommendations vary; 2GB/1CPU is reasonable starting point

**Research date:** 2026-01-21
**Valid until:** 2026-02-21 (30 days - stable domain)
