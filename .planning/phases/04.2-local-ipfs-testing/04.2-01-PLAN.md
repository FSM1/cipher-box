---
phase: 04.2-local-ipfs-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/docker-compose.yml
  - apps/api/src/ipfs/providers/ipfs-provider.interface.ts
  - apps/api/src/ipfs/providers/pinata.provider.ts
  - apps/api/src/ipfs/providers/local.provider.ts
  - apps/api/src/ipfs/providers/index.ts
  - apps/api/src/ipfs/ipfs.module.ts
  - apps/api/src/ipfs/ipfs.controller.ts
  - apps/api/src/ipfs/ipfs.service.ts
  - apps/api/src/ipfs/ipfs.service.spec.ts
  - apps/api/src/ipfs/ipfs.controller.spec.ts
autonomous: true

must_haves:
  truths:
    - "Docker Compose includes local IPFS node (Kubo) service"
    - "IPFS_PROVIDER environment variable switches between local and pinata"
    - "Backend IPFS operations work with local node when configured"
    - "Existing Pinata functionality continues working unchanged"
  artifacts:
    - path: "docker/docker-compose.yml"
      provides: "Kubo IPFS service definition"
      contains: "ipfs/kubo"
    - path: "apps/api/src/ipfs/providers/ipfs-provider.interface.ts"
      provides: "Abstract provider interface"
      exports: ["IpfsProvider", "IPFS_PROVIDER"]
    - path: "apps/api/src/ipfs/providers/pinata.provider.ts"
      provides: "Pinata IPFS implementation"
      exports: ["PinataProvider"]
    - path: "apps/api/src/ipfs/providers/local.provider.ts"
      provides: "Local Kubo implementation"
      exports: ["LocalProvider"]
    - path: "apps/api/src/ipfs/ipfs.module.ts"
      provides: "Dynamic module with forRootAsync"
      contains: "forRootAsync"
  key_links:
    - from: "apps/api/src/ipfs/ipfs.module.ts"
      to: "apps/api/src/ipfs/providers/ipfs-provider.interface.ts"
      via: "useFactory provider injection"
      pattern: "provide:\\s*IPFS_PROVIDER"
    - from: "apps/api/src/ipfs/ipfs.controller.ts"
      to: "apps/api/src/ipfs/providers/ipfs-provider.interface.ts"
      via: "@Inject(IPFS_PROVIDER)"
      pattern: "@Inject\\(IPFS_PROVIDER\\)"
---

<objective>
Add local IPFS node (Kubo) to Docker Compose and refactor IPFS service to provider pattern

Purpose: Enable offline testing by allowing the backend to use a local IPFS node instead of Pinata. This requires abstracting the existing IpfsService into an interface with two implementations.

Output:
- Docker Compose with Kubo IPFS service
- IpfsProvider interface with PinataProvider and LocalProvider implementations
- Dynamic IpfsModule that selects provider based on IPFS_PROVIDER environment variable
- Updated controller using provider injection
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.2-local-ipfs-testing/04.2-CONTEXT.md
@.planning/phases/04.2-local-ipfs-testing/04.2-RESEARCH.md

# Existing code to refactor
@apps/api/src/ipfs/ipfs.service.ts
@apps/api/src/ipfs/ipfs.module.ts
@apps/api/src/ipfs/ipfs.controller.ts
@apps/api/src/ipfs/ipfs.service.spec.ts
@apps/api/src/ipfs/ipfs.controller.spec.ts
@docker/docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Kubo IPFS service to Docker Compose</name>
  <files>docker/docker-compose.yml</files>
  <action>
Add Kubo IPFS service to docker-compose.yml:

```yaml
ipfs:
  image: ipfs/kubo:v0.39.0
  container_name: cipherbox-ipfs
  restart: unless-stopped
  environment:
    - IPFS_PATH=/data/ipfs
  volumes:
    - ipfs_data:/data/ipfs
  ports:
    # Swarm - P2P connections
    - "4001:4001/tcp"
    - "4001:4001/udp"
    # API - localhost only for security
    - "127.0.0.1:5001:5001"
    # Gateway - localhost only for dev
    - "127.0.0.1:8080:8080"
  healthcheck:
    test: ["CMD-SHELL", "ipfs id || exit 1"]
    interval: 10s
    timeout: 5s
    retries: 10
    start_period: 30s
  deploy:
    resources:
      limits:
        memory: 2G
        cpus: '1.0'
```

Add `ipfs_data` to volumes section.

IMPORTANT: Bind API port (5001) to 127.0.0.1 only - this port provides admin-level access.
  </action>
  <verify>
Run `docker compose -f docker/docker-compose.yml config` - should validate without errors.
Run `docker compose -f docker/docker-compose.yml up -d ipfs` - should start IPFS container.
Run `docker compose -f docker/docker-compose.yml ps` - should show ipfs healthy.
Run `curl -s -X POST http://localhost:5001/api/v0/id | head -c 100` - should return JSON with peer ID.
  </verify>
  <done>Kubo IPFS container runs and responds to API requests on localhost:5001</done>
</task>

<task type="auto">
  <name>Task 2: Create provider interface and implementations</name>
  <files>
apps/api/src/ipfs/providers/ipfs-provider.interface.ts
apps/api/src/ipfs/providers/pinata.provider.ts
apps/api/src/ipfs/providers/local.provider.ts
apps/api/src/ipfs/providers/index.ts
  </files>
  <action>
Create the provider abstraction:

1. Create `apps/api/src/ipfs/providers/ipfs-provider.interface.ts`:
```typescript
export interface IpfsProvider {
  pinFile(data: Buffer, metadata?: Record<string, string>): Promise<{ cid: string; size: number }>;
  unpinFile(cid: string): Promise<void>;
  getFile(cid: string): Promise<Buffer>;
}

export const IPFS_PROVIDER = 'IPFS_PROVIDER';
```

2. Create `apps/api/src/ipfs/providers/pinata.provider.ts`:
- Move existing IpfsService logic here
- Implement IpfsProvider interface
- Constructor takes `pinataJwt: string` parameter (not ConfigService)
- Add `getFile()` method using Pinata gateway (https://gateway.pinata.cloud/ipfs/{cid})
- Keep existing pinFile/unpinFile logic unchanged
- Remove @Injectable decorator (not a NestJS provider - instantiated by factory)

3. Create `apps/api/src/ipfs/providers/local.provider.ts`:
- Implement IpfsProvider interface
- Constructor takes `apiUrl: string, gatewayUrl: string` parameters
- All Kubo RPC endpoints use POST method (not REST conventions!)
- pinFile: POST to `{apiUrl}/api/v0/add?pin=true&cid-version=1` with multipart form
- unpinFile: POST to `{apiUrl}/api/v0/pin/rm?arg={cid}` - treat "not pinned" as success
- getFile: POST to `{apiUrl}/api/v0/cat?arg={cid}` - return Buffer from response
- Use form-data package for multipart encoding (already in project)
- Map errors to NestJS exceptions (BadRequestException, NotFoundException, InternalServerErrorException)

4. Create `apps/api/src/ipfs/providers/index.ts`:
```typescript
export * from './ipfs-provider.interface';
export * from './pinata.provider';
export * from './local.provider';
```

IMPORTANT per RESEARCH.md:
- Kubo API uses POST for ALL operations including get/unpin
- "not pinned" error from unpin means already unpinned - treat as success
- Use Readable.from(data) with form-data for file upload
  </action>
  <verify>
Files exist:
- `ls apps/api/src/ipfs/providers/`

TypeScript compiles:
- `pnpm -F api exec tsc --noEmit`
  </verify>
  <done>IpfsProvider interface exists with PinataProvider and LocalProvider implementations</done>
</task>

<task type="auto">
  <name>Task 3: Refactor IpfsModule to dynamic module and update controller</name>
  <files>
apps/api/src/ipfs/ipfs.module.ts
apps/api/src/ipfs/ipfs.controller.ts
apps/api/src/ipfs/ipfs.service.ts
apps/api/src/ipfs/ipfs.service.spec.ts
apps/api/src/ipfs/ipfs.controller.spec.ts
  </files>
  <action>
1. Update `apps/api/src/ipfs/ipfs.module.ts` to dynamic module:
```typescript
import { Module, DynamicModule } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { IPFS_PROVIDER, IpfsProvider, PinataProvider, LocalProvider } from './providers';
import { IpfsController } from './ipfs.controller';

@Module({})
export class IpfsModule {
  static forRootAsync(): DynamicModule {
    return {
      module: IpfsModule,
      imports: [ConfigModule],
      controllers: [IpfsController],
      providers: [
        {
          provide: IPFS_PROVIDER,
          useFactory: (configService: ConfigService): IpfsProvider => {
            const provider = configService.get<string>('IPFS_PROVIDER', 'pinata');

            if (provider === 'local') {
              const apiUrl = configService.get<string>('IPFS_LOCAL_API_URL', 'http://localhost:5001');
              const gatewayUrl = configService.get<string>('IPFS_LOCAL_GATEWAY_URL', 'http://localhost:8080');
              return new LocalProvider(apiUrl, gatewayUrl);
            }

            const jwt = configService.get<string>('PINATA_JWT');
            if (!jwt) {
              throw new Error('PINATA_JWT environment variable is required when IPFS_PROVIDER=pinata');
            }
            return new PinataProvider(jwt);
          },
          inject: [ConfigService],
        },
      ],
      exports: [IPFS_PROVIDER],
    };
  }
}
```

2. Update `apps/api/src/ipfs/ipfs.controller.ts`:
- Change constructor to use `@Inject(IPFS_PROVIDER) private readonly ipfsProvider: IpfsProvider`
- Replace `this.ipfsService.pinFile` with `this.ipfsProvider.pinFile`
- Replace `this.ipfsService.unpinFile` with `this.ipfsProvider.unpinFile`
- Update imports to use providers

3. Delete `apps/api/src/ipfs/ipfs.service.ts` - logic moved to PinataProvider

4. Update `apps/api/src/ipfs/ipfs.service.spec.ts`:
- Rename to `pinata.provider.spec.ts` in providers folder
- Update to test PinataProvider class directly (not through NestJS module)
- Keep all existing test cases

5. Update `apps/api/src/ipfs/ipfs.controller.spec.ts`:
- Mock IPFS_PROVIDER token instead of IpfsService
- Update mock object to match IpfsProvider interface (add getFile mock)

6. Update AppModule to use `IpfsModule.forRootAsync()` instead of just `IpfsModule`

IMPORTANT: Use `@Inject(IPFS_PROVIDER)` token injection, not class-based injection. Using class name causes silent failures per RESEARCH.md pitfalls.
  </action>
  <verify>
Tests pass:
- `pnpm -F api test`

Build succeeds:
- `pnpm -F api build`

Verify module registration in AppModule:
- `grep -r "IpfsModule.forRootAsync" apps/api/src/`
  </verify>
  <done>IpfsModule is dynamic, controller uses provider injection, old IpfsService deleted</done>
</task>

</tasks>

<verification>
1. Docker Compose starts both postgres and ipfs:
   `docker compose -f docker/docker-compose.yml up -d && docker compose -f docker/docker-compose.yml ps`

2. Local IPFS node responds:
   `curl -s -X POST http://localhost:5001/api/v0/id | jq .ID`

3. All tests pass:
   `pnpm test`

4. Build succeeds:
   `pnpm build`

5. With IPFS_PROVIDER=local, backend uses local node (manual E2E test):
   - Start API with IPFS_PROVIDER=local IPFS_LOCAL_API_URL=http://localhost:5001
   - POST a file to /ipfs/add endpoint
   - Verify CID appears in local node: `curl -X POST "http://localhost:5001/api/v0/pin/ls?arg={cid}"`
</verification>

<success_criteria>
- Docker Compose includes Kubo IPFS service with health checks
- IpfsProvider interface with PinataProvider and LocalProvider implementations
- IpfsModule.forRootAsync() selects provider based on IPFS_PROVIDER env var
- Controller uses @Inject(IPFS_PROVIDER) for provider injection
- All existing tests pass (updated for new structure)
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-local-ipfs-testing/04.2-01-SUMMARY.md`
</output>
