---
phase: 06.1-webapp-automation-testing
plan: 03
type: execute
wave: 2
depends_on: ['06.1-01', '06.1-02']
files_modified:
  - tests/e2e/tests/auth/login.spec.ts
  - tests/e2e/tests/auth/logout.spec.ts
  - tests/e2e/tests/auth/session.spec.ts
  - tests/e2e/fixtures/auth.fixture.ts
  - tests/e2e/utils/web3auth-helpers.ts
autonomous: true

must_haves:
  truths:
    - 'Login test verifies user can authenticate via Web3Auth'
    - 'Logout test verifies keys are cleared from memory'
    - 'Session test verifies auth persists across page reload'
    - 'Unauthenticated users are redirected to login'
  artifacts:
    - path: 'tests/e2e/tests/auth/login.spec.ts'
      provides: 'Login flow E2E tests'
      contains: 'test.*login'
    - path: 'tests/e2e/tests/auth/logout.spec.ts'
      provides: 'Logout flow E2E tests'
      contains: 'test.*logout'
    - path: 'tests/e2e/tests/auth/session.spec.ts'
      provides: 'Session persistence tests'
      contains: 'test.*session'
    - path: 'tests/e2e/fixtures/auth.fixture.ts'
      provides: 'Authenticated session fixture'
      exports: ['authenticatedTest']
  key_links:
    - from: 'tests/e2e/tests/auth/login.spec.ts'
      to: '/api/auth/web3auth/verify'
      via: 'API call after Web3Auth success'
      pattern: 'auth.*verify'
    - from: 'tests/e2e/fixtures/auth.fixture.ts'
      to: 'tests/e2e/page-objects/dashboard.page.ts'
      via: 'fixture navigates to dashboard after auth'
      pattern: 'dashboard.*goto'
---

<objective>
Create E2E tests for authentication flows.

Purpose: Validate the complete authentication journey including login via Web3Auth, logout with key clearing, session persistence, and protected route redirects. These tests ensure the security-critical auth flow works correctly end-to-end.

Output:

- Login test suite covering Web3Auth email flow
- Logout test suite verifying key clearing
- Session persistence tests
- Protected route redirect tests
- Authenticated session fixture for other tests to use
  </objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-webapp-automation-testing/06.1-CONTEXT.md
@.planning/phases/06.1-webapp-automation-testing/06.1-RESEARCH.md
@.planning/phases/06.1-webapp-automation-testing/06.1-01-SUMMARY.md
@.planning/phases/06.1-webapp-automation-testing/06.1-02-SUMMARY.md
@apps/web/src/routes/Login.tsx
@apps/web/src/components/auth/AuthButton.tsx
@apps/web/src/components/auth/LogoutButton.tsx
@apps/web/src/stores/auth.store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Web3Auth test helpers and auth fixture</name>
  <files>
    tests/e2e/utils/web3auth-helpers.ts
    tests/e2e/fixtures/auth.fixture.ts
    tests/e2e/.env.example
  </files>
  <action>
    Web3Auth testing approach per RESEARCH.md open questions:
    - Web3Auth Sapphire Devnet can be used for testing
    - Static test accounts may require creating test accounts manually
    - For reliable E2E tests, we'll use a hybrid approach:
      a) For most tests: Use storage state from a pre-authenticated session
      b) For login test: Actually click through Web3Auth modal

    1. Create tests/e2e/.env.example with placeholders:
       - WEB3AUTH_TEST_EMAIL - test account email
       - E2E tests will use Web3Auth Sapphire Devnet (testnet)

    2. Create tests/e2e/utils/web3auth-helpers.ts:
       - Function waitForWeb3AuthModal(page: Page): Promise<FrameLocator>
         - Wait for iframe with Web3Auth modal to appear
         - Return frameLocator for modal interactions
       - Function loginViaEmail(page: Page, email: string): Promise<void>
         - Click login button on app
         - Wait for Web3Auth modal
         - Select email login option
         - Enter email
         - Note: In Sapphire Devnet, OTP might be auto-filled or we need email service
         - Wait for redirect to dashboard
       - Function getStorageState(page: Page): Promise<object>
         - Capture cookies and localStorage for reuse

    3. Create tests/e2e/fixtures/auth.fixture.ts:
       - Import base test from @playwright/test
       - Create authenticatedTest extending base test:
         - storageState fixture: loads pre-saved auth state if exists
         - authenticatedPage fixture:
           - Check if storage state file exists
           - If yes: load it (fast path)
           - If no: perform actual login and save state
           - Navigate to /dashboard
           - Assert dashboard is loaded
         - cleanVault fixture:
           - Before test: call API to clear vault (TBD - depends on API)
           - Use authenticatedPage context for auth header

    4. Create storage state handling:
       - Storage state file: tests/e2e/.auth/user.json (gitignored)
       - Add .auth to .gitignore in tests/e2e

    Note: The actual login flow through Web3Auth modal can be flaky in CI.
    For now, focus on:
    - Manual login test (runs interactively)
    - Storage state based tests (fast, reliable)
    The CI integration plan will handle auth state setup.

  </action>
  <verify>
    cd tests/e2e && pnpm exec tsc --noEmit
  </verify>
  <done>
    Web3Auth helpers and auth fixture created. Storage state pattern established for fast authenticated tests. Framework supports both interactive login and pre-authenticated sessions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create login and logout test specs</name>
  <files>
    tests/e2e/tests/auth/login.spec.ts
    tests/e2e/tests/auth/logout.spec.ts
  </files>
  <action>
    1. Create tests/e2e/tests/auth/login.spec.ts:

       Import test and expect from base fixtures (not auth fixture for login tests)

       Tests:
       a) "shows login page for unauthenticated users":
          - Navigate to /
          - Assert login button is visible
          - Assert page shows login/welcome content

       b) "clicking login opens Web3Auth modal":
          - Navigate to /
          - Click login button
          - Assert Web3Auth modal iframe appears
          - Assert modal has login options visible

       c) "redirects to dashboard after successful login" (skip in CI initially):
          - Mark with test.skip if process.env.CI
          - Navigate to /
          - Perform full login flow via Web3Auth
          - Assert redirected to /dashboard
          - Assert user menu or logout button visible

       d) "redirects unauthenticated users from protected routes to login":
          - Navigate directly to /dashboard (without auth)
          - Assert redirected to / or /login
          - Assert login prompt visible

    2. Create tests/e2e/tests/auth/logout.spec.ts:

       Import authenticatedTest from auth fixture (needs authenticated state)

       Tests:
       a) "logout button is visible when authenticated":
          - Use authenticatedPage fixture
          - Navigate to dashboard
          - Assert logout button visible

       b) "clicking logout clears session and redirects to login":
          - Use authenticatedPage fixture
          - Click logout button
          - Assert redirected to / or /login
          - Assert login button visible (not logout)

       c) "after logout, accessing protected route redirects to login":
          - Use authenticatedPage fixture
          - Click logout
          - Try to navigate to /dashboard
          - Assert still on login page (not dashboard)

       d) "after logout, localStorage is cleared" (security check):
          - Use authenticatedPage fixture
          - Note keys in localStorage before logout
          - Click logout
          - Assert sensitive keys are cleared (authToken, vault keys, etc.)

  </action>
  <verify>
    pnpm --filter @cipherbox/e2e test tests/auth/login.spec.ts -- --project=chromium
    # Some tests may be skipped in non-interactive mode
  </verify>
  <done>
    Login and logout tests created. Tests cover modal opening, redirect flows, and session clearing. Interactive login test is skipped in CI (will use storage state setup).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create session persistence tests</name>
  <files>
    tests/e2e/tests/auth/session.spec.ts
  </files>
  <action>
    1. Create tests/e2e/tests/auth/session.spec.ts:

       Import authenticatedTest from auth fixture

       Tests:
       a) "session persists after page reload":
          - Use authenticatedPage fixture
          - Navigate to /dashboard
          - Assert logged in state
          - Reload page
          - Assert still on dashboard (not redirected)
          - Assert logged in state persists

       b) "session persists when navigating between pages":
          - Use authenticatedPage fixture
          - Navigate to /dashboard
          - Navigate to /settings (if exists)
          - Navigate back to /dashboard
          - Assert still authenticated throughout

       c) "expired session redirects to login":
          - This test is harder to implement without mocking
          - Option 1: Skip for now, add later with time manipulation
          - Option 2: Clear the auth cookie manually, then reload
          - Use authenticatedPage fixture
          - Clear cookies: await context.clearCookies()
          - Reload page
          - Assert redirected to login

       d) "token refresh works transparently" (if applicable):
          - Skip if token refresh isn't observable in UI
          - Or test by checking network requests for refresh calls

    2. Add test organization:
       - Use test.describe to group related tests
       - Use test.beforeEach for common setup if needed

  </action>
  <verify>
    pnpm --filter @cipherbox/e2e test tests/auth/session.spec.ts
  </verify>
  <done>
    Session persistence tests created covering page reload, navigation, and session expiry scenarios. Tests use authenticated fixture for fast execution.
  </done>
</task>

</tasks>

<verification>
1. pnpm --filter @cipherbox/e2e test tests/auth/ runs all auth tests
2. Login tests verify Web3Auth modal can be opened
3. Logout tests verify session clearing and redirects
4. Session tests verify persistence across reloads
5. Protected route tests verify unauthenticated redirect
</verification>

<success_criteria>

- Login flow test opens Web3Auth modal
- Logout flow test clears session and redirects
- Session persists across page reload for authenticated users
- Unauthenticated access to protected routes redirects to login
- Auth fixture provides fast authenticated sessions via storage state
- Tests can run in both interactive and CI modes
  </success_criteria>

<output>
After completion, create `.planning/phases/06.1-webapp-automation-testing/06.1-03-SUMMARY.md`
</output>
