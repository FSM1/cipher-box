# Phase 6.1: Webapp Automation Testing - Research

**Researched:** 2026-01-21
**Domain:** E2E testing with Playwright for React/TypeScript applications
**Confidence:** HIGH

## Summary

Playwright is the industry-standard E2E testing framework for modern web applications in 2026, offering built-in auto-waiting, web-first assertions, and comprehensive debugging tools. For pnpm monorepos, the recommended approach is to create a dedicated test package (e.g., `tests/e2e`) that depends on the web app package and runs against the full stack.

The standard testing strategy involves: Page Object Model patterns for maintainability, API-driven test data seeding for speed, fixture-based setup/teardown for isolation, and CI integration with artifact uploads on failure. Playwright's auto-waiting mechanism eliminates the need for manual waits and hard-coded timeouts, making tests resilient to timing issues.

For Web3Auth integration, while there's no official testing documentation for static accounts, the framework supports testing OAuth flows via the Sapphire Devnet network. Tests can interact with Web3Auth modals using standard Playwright locators and assertions.

**Primary recommendation:** Configure Playwright in a dedicated `tests/e2e` workspace package, use Page Object Model with fixtures for test organization, seed test data via API calls rather than UI interactions, and configure video recording on failure for CI debugging.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library          | Version        | Purpose               | Why Standard                                                                           |
| ---------------- | -------------- | --------------------- | -------------------------------------------------------------------------------------- |
| @playwright/test | Latest (1.48+) | E2E testing framework | Industry standard for browser automation, built-in auto-waiting, cross-browser support |
| TypeScript       | 5.9+           | Type safety           | Provides intellisense for page objects, catches errors at compile time                 |

### Supporting

| Library         | Version | Purpose                      | When to Use                                             |
| --------------- | ------- | ---------------------------- | ------------------------------------------------------- |
| @faker-js/faker | Latest  | Generate realistic test data | Creating dynamic test data for file names, folder names |
| dotenv          | Latest  | Environment configuration    | Loading test-specific environment variables             |

### Alternatives Considered

| Instead of   | Could Use             | Tradeoff                                                                                                                     |
| ------------ | --------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| Playwright   | Cypress               | Cypress can't test multiple browser tabs, has limitations with iframes, and doesn't support Chromium-only testing as cleanly |
| Playwright   | Selenium              | Selenium requires explicit waits, more verbose syntax, slower execution                                                      |
| Page Objects | Raw locators in tests | Page objects provide better maintainability but require more upfront structure                                               |

**Installation:**

```bash
# In monorepo root
pnpm create playwright@latest

# Or add to specific workspace
pnpm --filter tests/e2e add -D @playwright/test
```

## Architecture Patterns

### Recommended Project Structure

```
tests/
└── e2e/
    ├── fixtures/           # Custom fixtures for auth, data
    ├── page-objects/       # Page object classes
    │   ├── base.page.ts   # Base page with common methods
    │   ├── login.page.ts
    │   ├── dashboard.page.ts
    │   └── file-browser/
    │       ├── file-list.page.ts
    │       ├── folder-tree.page.ts
    │       └── context-menu.page.ts
    ├── tests/              # Test specs
    │   ├── auth/
    │   ├── file-operations/
    │   ├── folder-operations/
    │   └── navigation/
    ├── utils/              # Helper utilities
    │   ├── api-client.ts  # API calls for test setup
    │   ├── vault-setup.ts # Vault initialization helpers
    │   └── ipfs-helpers.ts
    ├── playwright.config.ts
    └── package.json
```

### Pattern 1: Page Object Model with Fixtures

**What:** Encapsulate page interactions in classes, expose them via test fixtures
**When to use:** All E2E tests - improves maintainability and reduces duplication
**Example:**

```typescript
// Source: https://playwright.dev/docs/pom + https://playwright.dev/docs/test-fixtures

// page-objects/file-list.page.ts
export class FileListPage {
  readonly page: Page;

  // Locators - use user-facing attributes
  private readonly fileItems = () => this.page.getByRole('button', { name: /file-item-/ });
  private readonly contextMenu = () => this.page.getByRole('menu');
  private readonly renameButton = () => this.page.getByRole('menuitem', { name: 'Rename' });
  private readonly deleteButton = () => this.page.getByRole('menuitem', { name: 'Delete' });

  constructor(page: Page) {
    this.page = page;
  }

  async rightClickFile(fileName: string) {
    const fileItem = this.page.getByRole('button', { name: new RegExp(fileName) });
    await fileItem.click({ button: 'right' });
    await expect(this.contextMenu()).toBeVisible();
  }

  async renameFile(oldName: string, newName: string) {
    await this.rightClickFile(oldName);
    await this.renameButton().click();

    // Wait for rename dialog
    const dialog = this.page.getByRole('dialog', { name: /rename/i });
    await expect(dialog).toBeVisible();

    const input = dialog.getByRole('textbox');
    await input.fill(newName);
    await dialog.getByRole('button', { name: /save|confirm/i }).click();

    // Wait for dialog to close and file to appear with new name
    await expect(dialog).not.toBeVisible();
    await expect(this.page.getByRole('button', { name: new RegExp(newName) })).toBeVisible();
  }
}

// fixtures/index.ts
export const test = base.extend<{
  fileListPage: FileListPage;
  authenticatedPage: Page; // Page with logged-in user
}>({
  // Fixture for authenticated session
  authenticatedPage: async ({ page, request }, use) => {
    // API-based login (faster than UI)
    const response = await request.post('/api/auth/web3auth/verify', {
      data: {
        idToken: process.env.TEST_ID_TOKEN,
        publicKey: process.env.TEST_PUBLIC_KEY,
      },
    });

    const { authToken } = await response.json();

    // Set auth cookie
    await page
      .context()
      .addCookies([{ name: 'authToken', value: authToken, domain: 'localhost', path: '/' }]);

    await page.goto('/dashboard');
    await use(page);
  },

  fileListPage: async ({ authenticatedPage }, use) => {
    const fileListPage = new FileListPage(authenticatedPage);
    await use(fileListPage);
  },
});
```

### Pattern 2: API-Driven Test Data Seeding

**What:** Use API calls to set up test data instead of UI interactions
**When to use:** Test setup, especially for creating files/folders before testing UI interactions
**Example:**

```typescript
// Source: https://www.browserstack.com/guide/playwright-best-practices

// utils/vault-setup.ts
export async function cleanVault(request: APIRequestContext, authToken: string) {
  // Get current vault metadata
  const vaultResponse = await request.get('/api/vault', {
    headers: { Authorization: `Bearer ${authToken}` },
  });

  const { rootIpnsName } = await vaultResponse.json();

  // Clear vault via API (faster than UI)
  await request.post('/api/vault/clear', {
    headers: { Authorization: `Bearer ${authToken}` },
    data: { rootIpnsName },
  });
}

export async function seedTestFiles(
  request: APIRequestContext,
  authToken: string,
  files: Array<{ name: string; content: string }>
) {
  for (const file of files) {
    await request.post('/api/vault/files', {
      headers: { Authorization: `Bearer ${authToken}` },
      data: {
        fileName: file.name,
        content: Buffer.from(file.content).toString('base64'),
        folderId: 'root',
      },
    });
  }
}

// In test
test.beforeEach(async ({ request }) => {
  const authToken = await getAuthToken(request);
  await cleanVault(request, authToken);
  await seedTestFiles(request, authToken, [
    { name: 'test-document.txt', content: 'Test content' },
    { name: 'sample.pdf', content: 'PDF content' },
  ]);
});
```

### Pattern 3: Web3Auth Modal Interaction

**What:** Testing Web3Auth authentication flows using Playwright locators
**When to use:** Auth flow tests, login/logout tests
**Example:**

```typescript
// page-objects/login.page.ts
export class LoginPage {
  readonly page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  async goto() {
    await this.page.goto('/');
  }

  async loginWithEmail(email: string) {
    // Click login button to open Web3Auth modal
    await this.page.getByRole('button', { name: /login|sign in/i }).click();

    // Wait for Web3Auth modal iframe
    const modalFrame = this.page.frameLocator('iframe[id*="web3auth"]').first();

    // Click email passwordless option
    await modalFrame.getByRole('button', { name: /email/i }).click();

    // Enter email
    await modalFrame.getByRole('textbox', { name: /email/i }).fill(email);
    await modalFrame.getByRole('button', { name: /continue|submit/i }).click();

    // In test environment, Web3Auth provides test OTP
    // Wait for success and modal to close
    await expect(this.page).toHaveURL(/\/dashboard/);
  }
}
```

### Anti-Patterns to Avoid

- **Hard-coded timeouts:** Never use `page.waitForTimeout(5000)` - use web-first assertions instead
- **Brittle CSS selectors:** Avoid `.css-abc123` or `div > div > button` - use semantic locators
- **Missing await:** All Playwright methods are async - forgetting await causes race conditions
- **UI-based test setup:** Don't click through 10 pages to set up data - use API calls
- **Shared test state:** Don't rely on test execution order - each test should be independent

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem                     | Don't Build              | Use Instead                                               | Why                                                                   |
| --------------------------- | ------------------------ | --------------------------------------------------------- | --------------------------------------------------------------------- |
| Wait for element            | Custom polling loop      | Playwright auto-waiting + `expect(locator).toBeVisible()` | Built-in retry logic handles dynamic content, avoids flakiness        |
| Test data generation        | Manual test data         | @faker-js/faker                                           | Generates realistic data, handles edge cases (unicode, special chars) |
| Screenshot/video on failure | Custom hooks             | Playwright config: `video: 'retain-on-failure'`           | Automatically captures artifacts, uploads to CI                       |
| Authentication state        | Login in every test      | Storage state fixtures                                    | Saves auth state, reuses across tests (100x faster)                   |
| Parallel execution          | Manual worker management | Playwright workers config                                 | Handles isolation, parallelization, and resource limits               |
| Test reporting              | Custom HTML generator    | Playwright HTML reporter                                  | Built-in trace viewer, timeline, network logs                         |

**Key insight:** Playwright's built-in features handle 90% of common testing challenges. Custom solutions for waiting, retries, or artifact capture create maintenance burden and miss edge cases that Playwright already handles.

## Common Pitfalls

### Pitfall 1: Race Conditions from Missing await

**What goes wrong:** Test fails intermittently because promises resolve in unexpected order
**Why it happens:** TypeScript doesn't enforce await on async functions, easy to forget
**How to avoid:**

- Enable `@typescript-eslint/no-floating-promises` rule
- Use web-first assertions that auto-wait: `expect(locator).toBeVisible()`
- Never use `.textContent()` directly - use `.textContent()` in an expect assertion
  **Warning signs:** Test passes locally but fails in CI, test fails on every 5th run

### Pitfall 2: Flaky Tests from Hard-Coded Timeouts

**What goes wrong:** `page.waitForTimeout(5000)` fails when page loads slower than expected
**Why it happens:** Developers try to "fix" flakiness by adding sleep delays
**How to avoid:**

- Use web-first assertions: `expect(locator).toHaveText('Expected')`
- Use built-in wait strategies: `page.waitForLoadState('networkidle')`
- Leverage Playwright's auto-waiting for actions
  **Warning signs:** Tests have `waitForTimeout` calls, tests take longer than necessary

### Pitfall 3: Fragile Locators Breaking on UI Changes

**What goes wrong:** Test breaks when developer changes CSS class names or DOM structure
**Why it happens:** Using CSS selectors like `.MuiButton-root.css-abc123`
**How to avoid:**

- Priority: `getByRole` > `getByText` > `getByLabel` > `getByTestId` > CSS selectors
- Add `data-testid` attributes for complex components
- Use semantic locators tied to user-facing behavior
  **Warning signs:** Tests break when CSS is refactored, tests have long XPath expressions

### Pitfall 4: Vault Not Cleaned Between Tests

**What goes wrong:** Test expects empty vault but previous test left files, causing assertions to fail
**Why it happens:** Forgetting to clean up in `afterEach` or relying on test execution order
**How to avoid:**

- Use `test.beforeEach` to wipe vault via API call
- Never rely on test execution order
- Use isolated test users if possible
  **Warning signs:** Tests pass individually but fail in suite, tests only pass on first run

### Pitfall 5: Web3Auth Modal Timing Issues

**What goes wrong:** Test tries to interact with Web3Auth modal before iframe loads
**Why it happens:** Web3Auth modal renders asynchronously in iframe
**How to avoid:**

- Use `page.frameLocator()` with proper waiting
- Wait for specific elements in modal: `await modalFrame.getByRole('button', { name: 'Email' }).waitFor()`
- Use web-first assertions for modal content
  **Warning signs:** "Frame was detached" errors, "Element not found" in Web3Auth modal

### Pitfall 6: IPFS Timing Issues

**What goes wrong:** File upload appears successful but file not yet pinned, download test fails
**Why it happens:** IPFS operations are asynchronous, UI updates before IPFS confirms
**How to avoid:**

- Wait for specific UI feedback: `expect(uploadStatus).toHaveText('Complete')`
- Use API polling in fixtures to confirm IPFS pin completion
- Wait for file to appear in list before testing download
  **Warning signs:** Upload tests pass but immediate download tests fail

## Code Examples

Verified patterns from official sources:

### Playwright Configuration for Monorepo

```typescript
// Source: https://playwright.dev/docs/test-configuration
// tests/e2e/playwright.config.ts

import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',

  // Run tests sequentially initially (parallelize later if needed)
  fullyParallel: false,
  workers: 1,

  // Fail build on CI if tests marked as test.only
  forbidOnly: !!process.env.CI,

  // No retries - fix flakiness immediately
  retries: 0,

  // Reporter for local and CI
  reporter: process.env.CI ? 'html' : 'list',

  use: {
    // Base URL for app under test
    baseURL: 'http://localhost:5173',

    // Capture artifacts on failure only
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    trace: 'retain-on-failure',
  },

  // Projects - Chromium only per requirements
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],

  // Web server configuration
  webServer: {
    command: 'pnpm --filter @cipherbox/web dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  },
});
```

### Locator Best Practices

```typescript
// Source: https://playwright.dev/docs/locators

// GOOD: Semantic locators (resilient to changes)
await page.getByRole('button', { name: 'Login' }).click();
await page.getByRole('textbox', { name: 'Email' }).fill('test@example.com');
await page.getByText('Welcome back').waitFor();

// GOOD: Test IDs for complex components
await page.getByTestId('file-upload-dropzone').click();

// BAD: CSS selectors (brittle)
await page.locator('.MuiButton-root.css-abc123').click();
await page.locator('div.container > div.row > button').click();

// BAD: XPath (hard to read and maintain)
await page.locator('//div[@class="container"]//button[contains(text(), "Click")]').click();
```

### Web-First Assertions

```typescript
// Source: https://playwright.dev/docs/test-assertions

// GOOD: Auto-waiting assertions
await expect(page.getByText('File uploaded successfully')).toBeVisible();
await expect(page.getByRole('button', { name: 'Download' })).toBeEnabled();
await expect(page.getByRole('listitem')).toHaveCount(5);

// BAD: Manual waiting (flaky)
await page.waitForTimeout(5000);
const text = await page.locator('.status').textContent();
expect(text).toBe('Complete');

// GOOD: Wait for specific condition
await expect(page.getByRole('progressbar')).not.toBeVisible();
await expect(page.getByTestId('file-list')).toContainText('document.pdf');
```

### Test Isolation with Fixtures

```typescript
// Source: https://playwright.dev/docs/test-fixtures

// fixtures/auth.fixture.ts
export const test = base.extend<{ authenticatedPage: Page }>({
  authenticatedPage: async ({ page, request }, use) => {
    // API-based auth (fast)
    const token = await getAuthToken(request);
    await page
      .context()
      .addCookies([{ name: 'authToken', value: token, domain: 'localhost', path: '/' }]);

    // Clean vault before test
    await cleanVault(request, token);

    await page.goto('/dashboard');
    await use(page);

    // Cleanup after test
    await cleanVault(request, token);
  },
});

// In test file
import { test } from '../fixtures/auth.fixture';

test('upload file', async ({ authenticatedPage }) => {
  // Page is already authenticated and vault is clean
  // No manual setup needed
});
```

## State of the Art

| Old Approach                 | Current Approach          | When Changed | Impact                                             |
| ---------------------------- | ------------------------- | ------------ | -------------------------------------------------- |
| Selenium WebDriver           | Playwright                | 2020-2021    | Faster execution, built-in auto-waiting, better DX |
| Manual waits (`sleep(5000)`) | Web-first assertions      | 2021-2022    | Eliminated 80% of flaky tests                      |
| Page Object classes only     | Fixtures + Page Objects   | 2022-2023    | Better test isolation, composable setup            |
| UI-based test setup          | API-driven seeding        | 2023-2024    | 10x faster test execution                          |
| Test IDs everywhere          | Role-based locators first | 2024-2025    | Better accessibility alignment, more resilient     |
| Full video recording         | `retain-on-failure`       | 2025-2026    | Reduced CI artifact storage costs by 90%           |

**Deprecated/outdated:**

- `page.waitForSelector()` with manual timeout - replaced by web-first assertions with auto-retry
- `test.describe.serial()` for dependent tests - replaced by proper test isolation with fixtures
- `page.$()` and `page.$$()` - replaced by `page.locator()` with auto-waiting
- Separate test configuration per test file - replaced by global configuration with project overrides

## Open Questions

Things that couldn't be fully resolved:

1. **Web3Auth Static Test Accounts**
   - What we know: Web3Auth has Sapphire Devnet for testing, community mentions "static test accounts"
   - What's unclear: No official documentation found for static test accounts feature. Unclear if this is:
     - A feature that exists but is undocumented
     - Enterprise-only feature
     - Community workaround (creating test accounts manually)
   - Recommendation: Start with Sapphire Devnet test accounts (create via Web3Auth dashboard), explore Web3Auth community forum or support for static account feature. May need to create test email accounts and manage OTPs via email testing service.

2. **Local IPFS Kubo Test Data Persistence**
   - What we know: IPFS Kubo runs in Docker, tests should use local IPFS
   - What's unclear: Best strategy for cleaning IPFS data between test runs - volume wipe vs. API-based cleanup
   - Recommendation: Use IPFS API to unpin test CIDs in `afterAll` hook. For full isolation, consider separate IPFS container per test suite with volume cleanup.

3. **Vault Cleanup Performance**
   - What we know: Need to wipe vault before each test
   - What's unclear: Whether full vault wipe via API is fast enough, or if we need database-level cleanup
   - Recommendation: Start with API-based vault cleanup. If too slow (>1s per test), consider direct database truncation in test environment.

## Sources

### Primary (HIGH confidence)

- [Playwright Introduction](https://playwright.dev/docs/intro) - Installation, browser support, system requirements
- [Playwright Test Configuration](https://playwright.dev/docs/test-configuration) - baseURL, video, screenshot, timeout, retries, parallel execution
- [Playwright CI Guide](https://playwright.dev/docs/ci-intro) - CI setup, artifacts, report configuration
- [Playwright Page Object Model](https://playwright.dev/docs/pom) - POM structure, locator organization, TypeScript examples
- [Playwright Fixtures](https://playwright.dev/docs/test-fixtures) - Fixture patterns, setup/teardown, encapsulation
- [Playwright Locators](https://playwright.dev/docs/locators) - Locator strategies, best practices, API reference
- [Playwright Auto-waiting](https://playwright.dev/docs/actionability) - Auto-waiting mechanism, actionability checks
- [Playwright Assertions](https://playwright.dev/docs/test-assertions) - Web-first assertions, auto-retry logic
- [Playwright Best Practices](https://playwright.dev/docs/best-practices) - Recommended patterns, anti-patterns
- [Playwright Trace Viewer](https://playwright.dev/docs/trace-viewer) - Debugging tool, screenshots, network logs

### Secondary (MEDIUM confidence)

- [Setting Up E2E Testing with Playwright: Monorepo vs Standard Repository](https://www.kyrre.dev/blog/end-to-end-testing-setup) - Monorepo structure recommendations (2024)
- [Turborepo Playwright Guide](https://turborepo.com/docs/guides/tools/playwright) - pnpm workspace integration patterns (2024)
- [15 Best Practices for Playwright Testing in 2026](https://www.browserstack.com/guide/playwright-best-practices) - Current best practices compilation
- [Avoiding Flaky Tests in Playwright](https://betterstack.com/community/guides/testing/avoid-flaky-playwright-tests/) - Anti-patterns and solutions (2025)
- [Playwright Test Data Management Strategies](https://momentic.ai/resources/the-definitive-guide-to-playwright-test-data-management-strategies) - API seeding, fixture patterns (2025)
- [Playwright Locators Guide](https://momentic.ai/blog/playwright-locators-guide) - getByRole, getByText, getByLabel best practices (2025)
- [Complete Monorepo Guide: pnpm + Workspace + Changesets](https://jsdev.space/complete-monorepo-guide/) - Dependency management, hoisting (2025)
- [Playwright HTML Reporter Guide](https://testdino.com/blog/playwright-html-reporter/) - Report configuration, trace viewer integration (2025)
- [IPFS Kubo Docker Installation](https://docs.ipfs.tech/install/run-ipfs-inside-docker/) - Official Docker setup guide
- [Integration Testing Passwordless Authentication with Playwright](https://marcin.codes/posts/integration-testing-passwordless-authentication-with-playwright/) - Email auth patterns (2024)

### Tertiary (LOW confidence - needs verification)

- [Web3Auth Documentation](https://web3auth.io/docs/) - Searched for static test accounts, found Sapphire Devnet but no specific static account feature documented
- [Web3Auth Community Forum - Sapphire Devnet](https://web3auth.io/community/t/need-to-get-some-test-balance-on-sapphire-dev-network/7753) - Community discussion about test network
- [Web3Auth E2E Tests Repository](https://github.com/Web3Auth/web3auth-e2e-tests) - Mentions "random accounts in each combo case" but no static account implementation found

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - Playwright is well-documented with official docs and widespread adoption
- Architecture: HIGH - POM + fixtures pattern is official Playwright recommendation
- Pitfalls: HIGH - Based on official best practices docs and community resources from 2025-2026
- Web3Auth testing: MEDIUM - No official testing docs found, approach based on general OAuth/iframe testing patterns
- IPFS testing: MEDIUM - Kubo Docker setup documented, but test cleanup strategy needs validation

**Research date:** 2026-01-21
**Valid until:** 30 days (2026-02-20) - Playwright has stable API, major changes unlikely in short term
