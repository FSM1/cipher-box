---
phase: 07-multi-device-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/ipns/ipns.controller.ts
  - apps/api/src/ipns/ipns.service.ts
  - apps/api/src/ipns/dto/resolve.dto.ts
  - apps/api/src/ipns/dto/index.ts
  - apps/web/src/stores/sync.store.ts
autonomous: true

must_haves:
  truths:
    - 'Backend can resolve IPNS names to CIDs via delegated routing'
    - 'Sync state tracks isSyncing, lastSyncTime, syncError, isOnline'
  artifacts:
    - path: 'apps/api/src/ipns/dto/resolve.dto.ts'
      provides: 'ResolveIpnsResponseDto with cid, sequenceNumber'
      exports: ['ResolveIpnsResponseDto']
    - path: 'apps/web/src/stores/sync.store.ts'
      provides: 'Sync state store'
      exports: ['useSyncStore']
  key_links:
    - from: 'apps/api/src/ipns/ipns.controller.ts'
      to: 'apps/api/src/ipns/ipns.service.ts'
      via: 'resolveRecord method call'
      pattern: "ipnsService\\.resolveRecord"
---

<objective>
Create backend IPNS resolution endpoint and frontend sync state store.

Purpose: Establish the foundational infrastructure for multi-device sync - backend can now resolve IPNS names to their current CIDs, and frontend has a dedicated store for tracking sync state.

Output: GET /ipns/resolve endpoint, ResolveIpnsResponseDto, useSyncStore
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-device-sync/07-CONTEXT.md
@.planning/phases/07-multi-device-sync/07-RESEARCH.md

Key existing files:
@apps/api/src/ipns/ipns.service.ts (add resolveRecord method)
@apps/api/src/ipns/ipns.controller.ts (add GET /resolve endpoint)
@apps/api/src/ipns/dto/publish.dto.ts (pattern for DTOs)
@apps/web/src/stores/vault.store.ts (pattern for Zustand stores)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend IPNS resolution endpoint</name>
  <files>
    apps/api/src/ipns/dto/resolve.dto.ts
    apps/api/src/ipns/dto/index.ts
    apps/api/src/ipns/ipns.service.ts
    apps/api/src/ipns/ipns.controller.ts
  </files>
  <action>
Create GET /ipns/resolve endpoint that resolves IPNS names via delegated routing.

1. Create `apps/api/src/ipns/dto/resolve.dto.ts`:
   - ResolveIpnsQueryDto: `ipnsName` (string, required, validated)
   - ResolveIpnsResponseDto: `cid` (string), `sequenceNumber` (string), `success` (boolean)
   - Use class-validator decorators (@IsString, @IsNotEmpty)

2. Update `apps/api/src/ipns/dto/index.ts`:
   - Export new DTOs

3. Add to IpnsService (`apps/api/src/ipns/ipns.service.ts`):

   ```typescript
   async resolveRecord(ipnsName: string): Promise<{ cid: string; sequenceNumber: string } | null> {
     // GET from delegated-ipfs.dev/routing/v1/ipns/{ipnsName}
     // Accept header: application/vnd.ipfs.ipns-record
     // Parse response to extract value (CID) and sequence number
     // Return null if not found (404)
     // Use same retry pattern as publishToDelegatedRouting
   }
   ```

   Note: The delegated routing API returns IPNS records in protobuf format. Use the ipns npm package (already in crypto module) to unmarshal if needed, or parse the simpler JSON response format if available.

4. Add controller endpoint (`apps/api/src/ipns/ipns.controller.ts`):
   - GET /ipns/resolve with @Query() for ipnsName
   - Rate limit: 30 resolves per minute (higher than publish since read-only)
   - Return 404 if IPNS name not found
   - Use JwtAuthGuard (authenticated users only)
     </action>
     <verify>
   - `pnpm --filter @cipherbox/api build` succeeds
   - `pnpm --filter @cipherbox/api test` passes
   - Start API, call `curl -X GET "http://localhost:3000/api/ipns/resolve?ipnsName=k51..." -H "Authorization: Bearer $TOKEN"` returns CID or 404
     </verify>
     <done>
     GET /ipns/resolve endpoint returns CID and sequence number for valid IPNS names, 404 for unknown names
     </done>
     </task>

<task type="auto">
  <name>Task 2: Create sync state store</name>
  <files>
    apps/web/src/stores/sync.store.ts
  </files>
  <action>
Create Zustand store for sync state management.

Create `apps/web/src/stores/sync.store.ts`:

```typescript
import { create } from 'zustand';

type SyncStatus = 'idle' | 'syncing' | 'success' | 'error';

type SyncState = {
  // Sync status
  status: SyncStatus;
  lastSyncTime: Date | null;
  syncError: string | null;

  // Network status
  isOnline: boolean;

  // Actions
  startSync: () => void;
  syncSuccess: () => void;
  syncFailure: (error: string) => void;
  setOnline: (online: boolean) => void;
  reset: () => void;
};

export const useSyncStore = create<SyncState>((set) => ({
  // Initial state
  status: 'idle',
  lastSyncTime: null,
  syncError: null,
  isOnline: typeof navigator !== 'undefined' ? navigator.onLine : true,

  // Actions
  startSync: () =>
    set({
      status: 'syncing',
      syncError: null,
    }),

  syncSuccess: () =>
    set({
      status: 'success',
      lastSyncTime: new Date(),
      syncError: null,
    }),

  syncFailure: (error) =>
    set({
      status: 'error',
      syncError: error,
    }),

  setOnline: (online) => set({ isOnline: online }),

  reset: () =>
    set({
      status: 'idle',
      lastSyncTime: null,
      syncError: null,
    }),
}));
```

Design notes:

- SyncStatus uses string literal type (not enum per CLAUDE.md)
- isOnline initialized from navigator.onLine with SSR guard
- Actions are minimal and focused
- No persistence - sync state is ephemeral
  </action>
  <verify> - `pnpm --filter @cipherbox/web build` succeeds - `pnpm --filter @cipherbox/web lint` passes - Store can be imported: `import { useSyncStore } from './stores/sync.store'`
  </verify>
  <done>
  useSyncStore exists with status, lastSyncTime, syncError, isOnline state and corresponding actions
  </done>
  </task>

</tasks>

<verification>
- Backend builds and tests pass
- Frontend builds and lints pass
- GET /ipns/resolve endpoint accessible via curl
- useSyncStore exportable and usable in components
</verification>

<success_criteria>

1. GET /ipns/resolve returns CID for published IPNS names
2. GET /ipns/resolve returns 404 for unknown names
3. useSyncStore tracks sync state (idle/syncing/success/error)
4. useSyncStore tracks online status
   </success_criteria>

<output>
After completion, create `.planning/phases/07-multi-device-sync/07-01-SUMMARY.md`
</output>
