---
phase: 07-multi-device-sync
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/hooks/useInterval.ts
  - apps/web/src/hooks/useVisibility.ts
  - apps/web/src/hooks/useOnlineStatus.ts
  - apps/web/src/hooks/useSyncPolling.ts
  - apps/web/src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - 'useInterval pauses when delay is null and cleans up on unmount'
    - 'useVisibility returns false when tab is hidden'
    - 'useOnlineStatus updates reactively on network change'
    - 'useSyncPolling polls every 30s when visible and online, pauses otherwise'
  artifacts:
    - path: 'apps/web/src/hooks/useInterval.ts'
      provides: 'Reusable interval hook with cleanup'
      exports: ['useInterval']
    - path: 'apps/web/src/hooks/useVisibility.ts'
      provides: 'Page Visibility API wrapper'
      exports: ['useVisibility']
    - path: 'apps/web/src/hooks/useOnlineStatus.ts'
      provides: 'Network status detection'
      exports: ['useOnlineStatus']
    - path: 'apps/web/src/hooks/useSyncPolling.ts'
      provides: 'Sync polling orchestrator'
      exports: ['useSyncPolling']
  key_links:
    - from: 'apps/web/src/hooks/useSyncPolling.ts'
      to: 'apps/web/src/hooks/useInterval.ts'
      via: 'useInterval hook call'
      pattern: "useInterval\\("
    - from: 'apps/web/src/hooks/useSyncPolling.ts'
      to: 'apps/web/src/hooks/useVisibility.ts'
      via: 'useVisibility hook call'
      pattern: "useVisibility\\("
    - from: 'apps/web/src/hooks/useSyncPolling.ts'
      to: 'apps/web/src/hooks/useOnlineStatus.ts'
      via: 'useOnlineStatus hook call'
      pattern: "useOnlineStatus\\("
---

<objective>
Create polling infrastructure hooks for multi-device sync.

Purpose: Build reusable hooks that handle interval polling with proper cleanup, tab visibility detection, network status tracking, and orchestrate them together for sync polling.

Output: useInterval, useVisibility, useOnlineStatus, useSyncPolling hooks
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-device-sync/07-CONTEXT.md
@.planning/phases/07-multi-device-sync/07-RESEARCH.md

Key existing files:
@apps/web/src/hooks/index.ts (export hooks)
@apps/web/src/hooks/useAuth.ts (pattern for hooks)
@apps/web/src/stores/sync.store.ts (will be created by 07-01, use in useSyncPolling)
@apps/web/src/stores/vault.store.ts (get rootIpnsName)
@apps/web/src/stores/folder.store.ts (get/set folder state)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create utility hooks (useInterval, useVisibility, useOnlineStatus)</name>
  <files>
    apps/web/src/hooks/useInterval.ts
    apps/web/src/hooks/useVisibility.ts
    apps/web/src/hooks/useOnlineStatus.ts
    apps/web/src/hooks/index.ts
  </files>
  <action>
Create three utility hooks following patterns from 07-RESEARCH.md.

1. Create `apps/web/src/hooks/useInterval.ts`:

```typescript
import { useEffect, useRef } from 'react';

/**
 * Custom interval hook with proper cleanup and ref-based callback.
 * Pass null as delay to pause the interval.
 *
 * @param callback - Function to call on each interval
 * @param delay - Interval in ms, or null to pause
 */
export function useInterval(callback: () => void, delay: number | null): void {
  const savedCallback = useRef<(() => void) | null>(null);

  // Remember the latest callback without re-establishing interval
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // Set up the interval
  useEffect(() => {
    if (delay === null) return; // Pause when delay is null

    const id = setInterval(() => {
      savedCallback.current?.();
    }, delay);

    return () => clearInterval(id); // Cleanup on unmount or delay change
  }, [delay]);
}
```

2. Create `apps/web/src/hooks/useVisibility.ts`:

```typescript
import { useState, useEffect } from 'react';

/**
 * Hook that tracks Page Visibility API state.
 * Returns true when tab is visible, false when hidden/backgrounded.
 */
export function useVisibility(): boolean {
  const [isVisible, setIsVisible] = useState(() =>
    typeof document !== 'undefined' ? !document.hidden : true
  );

  useEffect(() => {
    const handleVisibilityChange = () => {
      setIsVisible(!document.hidden);
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  return isVisible;
}
```

3. Create `apps/web/src/hooks/useOnlineStatus.ts`:

```typescript
import { useState, useEffect } from 'react';

/**
 * Hook that tracks navigator.onLine status with event listeners.
 * Updates reactively when browser detects network changes.
 *
 * Note: navigator.onLine only detects if network interface is connected,
 * not actual internet reachability. Handle network errors gracefully.
 */
export function useOnlineStatus(): boolean {
  const [isOnline, setIsOnline] = useState(() =>
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}
```

4. Update `apps/web/src/hooks/index.ts`:
   - Add exports for useInterval, useVisibility, useOnlineStatus

Design notes per 07-RESEARCH.md:

- useInterval uses useRef to avoid stale callback closure issue
- All hooks have SSR guards (typeof document/navigator checks)
- useOnlineStatus includes note about navigator.onLine limitations
  </action>
  <verify> - `pnpm --filter @cipherbox/web build` succeeds - `pnpm --filter @cipherbox/web lint` passes - Hooks can be imported from index: `import { useInterval, useVisibility, useOnlineStatus } from './hooks'`
  </verify>
  <done>
  useInterval, useVisibility, useOnlineStatus hooks created with proper cleanup and SSR safety
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create useSyncPolling orchestrator hook</name>
  <files>
    apps/web/src/hooks/useSyncPolling.ts
    apps/web/src/hooks/index.ts
  </files>
  <action>
Create the main sync polling hook that orchestrates interval, visibility, and online status.

Create `apps/web/src/hooks/useSyncPolling.ts`:

```typescript
import { useCallback, useEffect, useRef } from 'react';
import { useInterval } from './useInterval';
import { useVisibility } from './useVisibility';
import { useOnlineStatus } from './useOnlineStatus';
import { useSyncStore } from '../stores/sync.store';
import { useVaultStore } from '../stores/vault.store';

const SYNC_INTERVAL_MS = 30000; // 30 seconds per CONTEXT.md

/**
 * Orchestrates IPNS polling for multi-device sync.
 *
 * Behavior per CONTEXT.md:
 * - Polls every 30s when tab is visible and online
 * - Pauses polling when tab is backgrounded (saves battery)
 * - Polls immediately when tab regains focus (per RESEARCH.md recommendation)
 * - Polls immediately when coming back online
 * - Updates sync store with status (syncing/success/error)
 *
 * @param onSync - Callback to execute sync logic (resolve IPNS, compare, refresh)
 */
export function useSyncPolling(onSync: () => Promise<void>): void {
  const isVisible = useVisibility();
  const isOnline = useOnlineStatus();
  const { startSync, syncSuccess, syncFailure, setOnline } = useSyncStore();
  const { rootIpnsName } = useVaultStore();

  // Track previous states for edge detection
  const prevOnline = useRef(isOnline);
  const prevVisible = useRef(isVisible);

  // Keep sync store's isOnline in sync
  useEffect(() => {
    setOnline(isOnline);
  }, [isOnline, setOnline]);

  // Wrapped sync callback that updates store state
  const doSync = useCallback(async () => {
    if (!rootIpnsName || !isOnline) return;

    startSync();
    try {
      await onSync();
      syncSuccess();
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Sync failed';
      syncFailure(message);
    }
  }, [rootIpnsName, isOnline, onSync, startSync, syncSuccess, syncFailure]);

  // Determine polling delay: null pauses, number runs
  // Per CONTEXT.md: pause when backgrounded (Claude's discretion chose pause)
  const pollDelay = isVisible && isOnline ? SYNC_INTERVAL_MS : null;

  // Regular interval polling
  useInterval(doSync, pollDelay);

  // Immediate sync on visibility regain (per RESEARCH.md recommendation)
  useEffect(() => {
    if (isVisible && !prevVisible.current && isOnline) {
      doSync();
    }
    prevVisible.current = isVisible;
  }, [isVisible, isOnline, doSync]);

  // Immediate sync on reconnect (per CONTEXT.md)
  useEffect(() => {
    if (isOnline && !prevOnline.current) {
      doSync();
    }
    prevOnline.current = isOnline;
  }, [isOnline, doSync]);
}
```

Update `apps/web/src/hooks/index.ts`:

- Add export for useSyncPolling

Design notes:

- Hook takes onSync callback to keep sync logic separate (will be implemented in Plan 03)
- Pauses polling when tab backgrounded (battery optimization per RESEARCH.md)
- Polls immediately on focus regain and reconnect (per RESEARCH.md recommendations)
- Uses ref tracking to detect state transitions (not just current state)
  </action>
  <verify> - `pnpm --filter @cipherbox/web build` succeeds - `pnpm --filter @cipherbox/web lint` passes - Hook can be imported: `import { useSyncPolling } from './hooks'`
  </verify>
  <done>
  useSyncPolling hook orchestrates polling with visibility/online awareness and immediate sync on state transitions
  </done>
  </task>

</tasks>

<verification>
- Frontend builds and lints pass
- All four hooks exportable from index.ts
- useInterval pauses when delay is null
- useSyncPolling integrates with sync store
</verification>

<success_criteria>

1. useInterval properly cleans up on unmount and pauses when delay is null
2. useVisibility returns correct tab visibility state
3. useOnlineStatus updates on online/offline events
4. useSyncPolling polls every 30s when visible+online, pauses otherwise
5. useSyncPolling triggers immediate sync on visibility regain and reconnect
   </success_criteria>

<output>
After completion, create `.planning/phases/07-multi-device-sync/07-02-SUMMARY.md`
</output>
