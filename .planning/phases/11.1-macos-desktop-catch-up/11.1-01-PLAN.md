---
phase: 11.1-macos-desktop-catch-up
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src-tauri/Cargo.toml
  - apps/desktop/src-tauri/src/crypto/hkdf.rs
  - apps/desktop/src-tauri/src/crypto/aes_ctr.rs
  - apps/desktop/src-tauri/src/crypto/folder.rs
  - apps/desktop/src-tauri/src/crypto/mod.rs
  - apps/desktop/src-tauri/src/crypto/tests.rs
autonomous: true

must_haves:
  truths:
    - "HKDF-SHA256 with salt 'CipherBox-v1' and info 'cipherbox-vault-ipns-v1' produces same Ed25519 seed as web app for same private key input"
    - "HKDF with info 'cipherbox-file-ipns-v1:{fileId}' produces per-file Ed25519 seed matching web app"
    - "HKDF with info 'cipherbox-device-registry-ipns-v1' produces registry Ed25519 seed matching web app"
    - 'AES-256-CTR encrypt/decrypt roundtrips correctly for arbitrary data'
    - 'AES-256-CTR range decryption produces correct bytes for arbitrary byte offsets'
    - 'v2 FolderMetadata with FilePointer entries deserializes correctly from JSON'
    - 'FileMetadata (per-file IPNS record) type with optional encryptionMode deserializes correctly'
  artifacts:
    - path: 'apps/desktop/src-tauri/src/crypto/hkdf.rs'
      provides: 'HKDF derivation functions for vault, file, and registry IPNS keypairs'
      exports:
        ['derive_vault_ipns_keypair', 'derive_file_ipns_keypair', 'derive_registry_ipns_keypair']
    - path: 'apps/desktop/src-tauri/src/crypto/aes_ctr.rs'
      provides: 'AES-256-CTR encrypt, decrypt, and range decrypt functions'
      exports: ['encrypt_aes_ctr', 'decrypt_aes_ctr', 'decrypt_aes_ctr_range']
    - path: 'apps/desktop/src-tauri/src/crypto/folder.rs'
      provides: 'v2 folder schema types with FilePointer, FileMetadata type'
      contains: 'FilePointer'
  key_links:
    - from: 'apps/desktop/src-tauri/src/crypto/hkdf.rs'
      to: 'apps/desktop/src-tauri/src/crypto/ed25519.rs'
      via: 'HKDF seed -> SigningKey -> VerifyingKey'
      pattern: 'SigningKey::from_bytes'
    - from: 'apps/desktop/src-tauri/src/crypto/hkdf.rs'
      to: 'apps/desktop/src-tauri/src/crypto/ipns.rs'
      via: 'Ed25519 public key -> derive_ipns_name'
      pattern: 'derive_ipns_name'
    - from: 'apps/desktop/src-tauri/src/crypto/aes_ctr.rs'
      to: 'aes/ctr crates'
      via: 'Ctr64BE cipher construction'
      pattern: 'Ctr64BE'
---

<objective>
Add Rust crypto primitives for HKDF-based deterministic IPNS derivation, AES-256-CTR encryption/decryption, and v2 folder metadata types (FilePointer, FileMetadata).

Purpose: These primitives are the foundation for all other desktop catch-up work. HKDF enables deterministic vault/file/registry IPNS derivation (matching web app). AES-CTR enables decryption of media files uploaded via web. v2 types enable parsing the new folder metadata schema.

Output: Three new Rust source files (hkdf.rs, aes_ctr.rs) and updated folder.rs with v2 types, plus passing tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Web app reference implementations (source of truth for Rust ports)

@packages/crypto/src/vault/derive-ipns.ts
@packages/crypto/src/file/derive-ipns.ts
@packages/crypto/src/registry/derive-ipns.ts
@packages/crypto/src/aes/encrypt-ctr.ts
@packages/crypto/src/aes/decrypt-ctr.ts
@packages/crypto/src/folder/types.ts
@packages/crypto/src/file/types.ts

# Existing Rust crypto code to extend

@apps/desktop/src-tauri/src/crypto/mod.rs
@apps/desktop/src-tauri/src/crypto/ed25519.rs
@apps/desktop/src-tauri/src/crypto/aes.rs
@apps/desktop/src-tauri/src/crypto/folder.rs
@apps/desktop/src-tauri/src/crypto/ipns.rs
@apps/desktop/src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: HKDF derivation functions and AES-CTR primitives</name>
  <files>
    apps/desktop/src-tauri/Cargo.toml
    apps/desktop/src-tauri/src/crypto/hkdf.rs
    apps/desktop/src-tauri/src/crypto/aes_ctr.rs
    apps/desktop/src-tauri/src/crypto/mod.rs
  </files>
  <action>
    1. Add crate dependencies to Cargo.toml:
       - `hkdf = "0.12"` for HKDF-SHA256
       - `sha2 = "0.10"` for SHA-256 (HKDF hash)
       - `aes = "0.8"` for AES-256 block cipher
       - `ctr = "0.9"` for CTR mode wrapper

    2. Create `crypto/hkdf.rs` with three derivation functions:
       - `derive_vault_ipns_keypair(user_private_key: &[u8; 32]) -> Result<(Vec<u8>, Vec<u8>, String), HkdfError>`
         Salt: b"CipherBox-v1", Info: b"cipherbox-vault-ipns-v1"
         Returns (ed25519_private_key, ed25519_public_key, ipns_name)
       - `derive_file_ipns_keypair(user_private_key: &[u8; 32], file_id: &str) -> Result<(Vec<u8>, Vec<u8>, String), HkdfError>`
         Salt: b"CipherBox-v1", Info: format!("cipherbox-file-ipns-v1:{}", file_id).as_bytes()
         Validate file_id.len() >= 10
       - `derive_registry_ipns_keypair(user_private_key: &[u8; 32]) -> Result<(Vec<u8>, Vec<u8>, String), HkdfError>`
         Salt: b"CipherBox-v1", Info: b"cipherbox-device-registry-ipns-v1"

       All three follow the same pattern:
       a. HKDF::new(Some(salt), user_private_key) -> extract PRK
       b. prk.expand(info, &mut okm[..32]) -> 32-byte Ed25519 seed
       c. SigningKey::from_bytes(&okm) -> derive VerifyingKey (public key)
       d. crypto::ipns::derive_ipns_name(&public_key_bytes) -> IPNS name
       e. Return (private_key_vec, public_key_vec, ipns_name)

       Define `HkdfError` enum with variants: InvalidKeySize, DerivationFailed, IpnsDerivationFailed.

    3. Create `crypto/aes_ctr.rs` with:
       - Constants: `AES_CTR_IV_SIZE = 16`, `AES_CTR_COUNTER_BITS = 64`
       - `encrypt_aes_ctr(plaintext: &[u8], key: &[u8; 32], iv: &[u8; 16]) -> Result<Vec<u8>, AesCtrError>`
         Use `type Aes256Ctr = ctr::Ctr64BE<aes::Aes256>` (big-endian 64-bit counter, matching Web Crypto `length: 64`)
         CTR output is same size as input (no tag).
       - `decrypt_aes_ctr(ciphertext: &[u8], key: &[u8; 32], iv: &[u8; 16]) -> Result<Vec<u8>, AesCtrError>`
         CTR encrypt == decrypt (XOR is symmetric), but provide separate function for API clarity.
       - `decrypt_aes_ctr_range(ciphertext: &[u8], key: &[u8; 32], iv: &[u8; 16], start_byte: usize, end_byte: usize) -> Result<Vec<u8>, AesCtrError>`
         Compute block-aligned range (block_size = 16).
         Build counter for starting block: copy nonce (first 8 bytes of IV), set counter = base_counter + start_block.
         Use BigEndian u64 for counter arithmetic (bytes 8-15 of IV).
         Decrypt only the block-aligned range, then slice to exact requested bytes.
       - Define `AesCtrError` with: InvalidKeySize, InvalidIvSize, EncryptionFailed, DecryptionFailed, InvalidRange.

    4. Update `crypto/mod.rs` to add `pub mod hkdf;` and `pub mod aes_ctr;`

  </action>
  <verify>
    Run `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check` to verify compilation.
  </verify>
  <done>
    hkdf.rs and aes_ctr.rs compile with all three HKDF functions and CTR encrypt/decrypt/range functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: v2 folder schema types + FileMetadata type + tests</name>
  <files>
    apps/desktop/src-tauri/src/crypto/folder.rs
    apps/desktop/src-tauri/src/crypto/tests.rs
  </files>
  <action>
    1. Update `crypto/folder.rs` to support both v1 and v2 folder metadata:
       - Add `FilePointer` struct (matching TypeScript FilePointer):
         ```rust
         #[derive(Debug, Clone, Serialize, Deserialize)]
         #[serde(rename_all = "camelCase")]
         pub struct FilePointer {
             pub id: String,
             pub name: String,
             pub file_meta_ipns_name: String,
             pub created_at: u64,
             pub modified_at: u64,
         }
         ```
       - Add `FileMetadata` struct (per-file IPNS record, matching TypeScript):
         ```rust
         #[derive(Debug, Clone, Serialize, Deserialize)]
         #[serde(rename_all = "camelCase")]
         pub struct FileMetadata {
             pub version: String,
             pub cid: String,
             pub file_key_encrypted: String,
             pub file_iv: String,
             pub size: u64,
             pub mime_type: String,
             #[serde(default = "default_encryption_mode")]
             pub encryption_mode: String,
             pub created_at: u64,
             pub modified_at: u64,
         }
         fn default_encryption_mode() -> String { "GCM".to_string() }
         ```
       - Add `FolderChildV2` enum:
         ```rust
         #[derive(Debug, Clone, Serialize, Deserialize)]
         #[serde(tag = "type", rename_all = "lowercase")]
         pub enum FolderChildV2 {
             Folder(FolderEntry),
             File(FilePointer),
         }
         ```
       - Add `FolderMetadataV2`:
         ```rust
         #[derive(Debug, Clone, Serialize, Deserialize)]
         pub struct FolderMetadataV2 {
             pub version: String,
             pub children: Vec<FolderChildV2>,
         }
         ```
       - Add `AnyFolderMetadata` enum for version-dispatched parsing:
         ```rust
         pub enum AnyFolderMetadata {
             V1(FolderMetadata),
             V2(FolderMetadataV2),
         }
         ```
       - Add `decrypt_any_folder_metadata(sealed: &[u8], folder_key: &[u8; 32]) -> Result<AnyFolderMetadata, FolderError>`:
         Decrypt with AES-GCM, then check `version` field to dispatch to V1 or V2.
       - Add `encrypt_file_metadata` and `decrypt_file_metadata` functions (using AES-GCM, same as folder metadata pattern).

    2. Add comprehensive tests to `crypto/tests.rs`:
       - Test HKDF vault derivation with a known private key, verify IPNS name starts with "k51"
       - Test HKDF file derivation with same key + different fileIds produce different IPNS names
       - Test HKDF registry derivation produces different name from vault derivation (same key)
       - Test AES-CTR roundtrip (encrypt then decrypt == original)
       - Test AES-CTR range decryption at various offsets (start=0, start=16, start=7 for mid-block)
       - Test v2 FolderMetadata deserialization from JSON with FilePointer children
       - Test FileMetadata deserialization with and without encryptionMode field (default "GCM")
       - Test AnyFolderMetadata dispatch (v1 -> V1, v2 -> V2)
       - Test encrypt/decrypt roundtrip for FileMetadata

  </action>
  <verify>
    Run `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo test` -- all tests pass including new ones.
  </verify>
  <done>
    v2 folder types (FilePointer, FolderMetadataV2, FileMetadata, AnyFolderMetadata) compile and serialize/deserialize correctly. All HKDF, AES-CTR, and v2 type tests pass. `cargo test` green.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `cargo test` passes with all new tests green
- HKDF derivation produces deterministic output (same input -> same IPNS name)
- AES-CTR encrypt/decrypt roundtrip succeeds for various data sizes
- v2 folder metadata deserializes correctly from JSON matching web app format
</verification>

<success_criteria>

1. Three HKDF derivation functions (vault, file, registry) produce deterministic Ed25519 keypairs and IPNS names
2. AES-CTR encrypt, decrypt, and range-decrypt work for arbitrary data
3. FilePointer, FolderMetadataV2, FileMetadata, and AnyFolderMetadata types are defined and serde-compatible with web app JSON format
4. All new tests pass (`cargo test`)
   </success_criteria>

<output>
After completion, create `.planning/phases/11.1-macos-desktop-catch-up/11.1-01-SUMMARY.md`
</output>
