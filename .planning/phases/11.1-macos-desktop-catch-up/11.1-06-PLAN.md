---
phase: 11.1-macos-desktop-catch-up
plan: 06
type: execute
wave: 3
depends_on: ['11.1-01', '11.1-04']
files_modified:
  - apps/desktop/src-tauri/src/registry/mod.rs
  - apps/desktop/src-tauri/src/registry/types.rs
  - apps/desktop/src-tauri/src/main.rs
  - apps/desktop/src-tauri/src/commands.rs
  - apps/desktop/src-tauri/src/state.rs
autonomous: true

must_haves:
  truths:
    - 'Desktop registers itself in the encrypted device registry on IPFS after successful authentication'
    - "Device entry includes platform 'macos', deviceModel, appVersion, status 'pending' (or 'authorized' if first device)"
    - "Registry is ECIES-encrypted with the user's public key and published to a deterministic IPNS name (derived via HKDF)"
    - "Desktop device appears in the web app's Authorized Devices view"
    - 'Registry operations are non-blocking: failures never block login'
  artifacts:
    - path: 'apps/desktop/src-tauri/src/registry/mod.rs'
      provides: 'Device registry service: register_device, fetch_registry, update_registry'
      exports: ['register_device']
    - path: 'apps/desktop/src-tauri/src/registry/types.rs'
      provides: 'DeviceEntry, DeviceRegistry types matching web app'
      contains: 'DeviceRegistry'
  key_links:
    - from: 'apps/desktop/src-tauri/src/registry/mod.rs'
      to: 'apps/desktop/src-tauri/src/crypto/hkdf.rs'
      via: 'HKDF registry IPNS derivation'
      pattern: 'derive_registry_ipns_keypair'
    - from: 'apps/desktop/src-tauri/src/registry/mod.rs'
      to: 'apps/desktop/src-tauri/src/crypto/ecies.rs'
      via: "ECIES encrypt/decrypt registry with user's public key"
      pattern: "wrap_key\\|unwrap_key"
    - from: 'apps/desktop/src-tauri/src/commands.rs'
      to: 'apps/desktop/src-tauri/src/registry/mod.rs'
      via: 'Non-blocking registry update after auth'
      pattern: 'register_device'
---

<objective>
Implement the encrypted device registry client in Rust so the desktop app registers itself on IPFS after authentication, appearing in the web app's Authorized Devices view.

Purpose: Device registry enables cross-device awareness. The web app can see the desktop as a known device, and the desktop can participate in device approval flows.

Output: New registry module with types, ECIES-encrypted registry CRUD, and non-blocking registration after auth.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs

@.planning/phases/11.1-macos-desktop-catch-up/11.1-01-SUMMARY.md
@.planning/phases/11.1-macos-desktop-catch-up/11.1-04-SUMMARY.md

# Web app device registry reference

@apps/web/src/services/device-registry.service.ts
@packages/crypto/src/registry/derive-ipns.ts
@packages/crypto/src/registry/types.ts

# Existing desktop crypto (HKDF, ECIES)

@apps/desktop/src-tauri/src/crypto/hkdf.rs
@apps/desktop/src-tauri/src/crypto/ecies.rs
@apps/desktop/src-tauri/src/api/ipfs.rs
@apps/desktop/src-tauri/src/api/ipns.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Device registry types and service</name>
  <files>
    apps/desktop/src-tauri/src/registry/types.rs
    apps/desktop/src-tauri/src/registry/mod.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    1. Create `src/registry/` module directory. Add `pub mod registry;` to main.rs module declarations.

    2. Create `registry/types.rs` with types matching the web app:
       ```rust
       #[derive(Debug, Clone, Serialize, Deserialize)]
       #[serde(rename_all = "camelCase")]
       pub struct DeviceEntry {
           pub device_id: String,
           pub public_key: String,
           pub name: String,
           pub platform: String,        // "web" | "macos" | "linux" | "windows"
           pub app_version: String,
           pub device_model: String,
           pub ip_hash: String,
           pub status: String,           // "pending" | "authorized" | "revoked"
           pub created_at: u64,
           pub last_seen_at: u64,
           #[serde(skip_serializing_if = "Option::is_none")]
           pub revoked_at: Option<u64>,
           #[serde(skip_serializing_if = "Option::is_none")]
           pub revoked_by: Option<String>,
       }

       #[derive(Debug, Clone, Serialize, Deserialize)]
       #[serde(rename_all = "camelCase")]
       pub struct DeviceRegistry {
           pub version: String,          // "v1"
           pub sequence_number: u64,
           pub devices: Vec<DeviceEntry>,
       }
       ```

    3. Create `registry/mod.rs` with the registry service:
       ```rust
       pub mod types;
       use types::{DeviceEntry, DeviceRegistry};

       /// Register this desktop device in the encrypted device registry.
       ///
       /// Non-blocking: spawns a tokio task. Failures are logged, never block login.
       pub async fn register_device(
           api: &Arc<ApiClient>,
           private_key: &[u8; 32],
           public_key: &[u8],
           user_id: &str,
       ) -> Result<(), String> {
           // 1. Derive registry IPNS keypair via HKDF
           let (reg_ipns_priv, reg_ipns_pub, reg_ipns_name) =
               crypto::hkdf::derive_registry_ipns_keypair(private_key)
                   .map_err(|e| format!("Registry IPNS derivation failed: {}", e))?;

           // 2. Try to resolve existing registry IPNS
           let existing_registry = match fetch_and_decrypt_registry(
               api, &reg_ipns_name, private_key
           ).await {
               Ok(reg) => Some(reg),
               Err(_) => None, // No registry exists yet (first device)
           };

           // 3. Build device entry for this desktop
           let device_id = get_or_create_device_id(); // UUID stored in keychain
           let device_entry = DeviceEntry {
               device_id: device_id.clone(),
               public_key: hex::encode(public_key),
               name: get_device_name(),         // hostname
               platform: "macos".to_string(),
               app_version: env!("CARGO_PKG_VERSION").to_string(),
               device_model: get_device_model(), // "MacBook Pro" etc via sysinfo or fixed
               ip_hash: String::new(),           // TODO: hash of local IP
               status: if existing_registry.is_none() {
                   "authorized".to_string() // First device auto-authorized
               } else {
                   "pending".to_string()
               },
               created_at: now_ms(),
               last_seen_at: now_ms(),
               revoked_at: None,
               revoked_by: None,
           };

           // 4. Build updated registry
           let mut registry = existing_registry.unwrap_or(DeviceRegistry {
               version: "v1".to_string(),
               sequence_number: 0,
               devices: vec![],
           });

           // Update or add device entry
           if let Some(existing) = registry.devices.iter_mut().find(|d| d.device_id == device_id) {
               existing.last_seen_at = now_ms();
               existing.app_version = env!("CARGO_PKG_VERSION").to_string();
           } else {
               registry.devices.push(device_entry);
           }
           registry.sequence_number += 1;

           // 5. Encrypt registry with user's public key (ECIES)
           let registry_json = serde_json::to_vec(&registry)
               .map_err(|e| format!("Registry serialization failed: {}", e))?;
           let encrypted = crypto::ecies::wrap_key(&registry_json, public_key)
               .map_err(|e| format!("Registry encryption failed: {}", e))?;

           // 6. Upload encrypted registry to IPFS
           let cid = crate::api::ipfs::upload_content(api, &encrypted).await?;

           // 7. Create and publish IPNS record
           let reg_ipns_priv_arr: [u8; 32] = reg_ipns_priv.try_into()
               .map_err(|_| "Invalid registry IPNS key length")?;
           let value = format!("/ipfs/{}", cid);
           let record = crypto::ipns::create_ipns_record(
               &reg_ipns_priv_arr, &value, registry.sequence_number, 86_400_000
           ).map_err(|e| format!("IPNS record creation failed: {}", e))?;
           let marshaled = crypto::ipns::marshal_ipns_record(&record)
               .map_err(|e| format!("IPNS record marshaling failed: {}", e))?;
           let record_base64 = base64::engine::general_purpose::STANDARD.encode(&marshaled);

           let publish_req = crate::api::ipns::IpnsPublishRequest {
               ipns_name: reg_ipns_name,
               record: record_base64,
               metadata_cid: cid,
               encrypted_ipns_private_key: None,
               key_epoch: None,
           };
           crate::api::ipns::publish_ipns(api, &publish_req).await?;

           log::info!("Device registered in encrypted registry (device_id: {})", device_id);
           Ok(())
       }

       /// Fetch and decrypt existing registry from IPNS.
       async fn fetch_and_decrypt_registry(
           api: &ApiClient,
           ipns_name: &str,
           private_key: &[u8; 32],
       ) -> Result<DeviceRegistry, String> {
           let resolve = crate::api::ipns::resolve_ipns(api, ipns_name).await?;
           let encrypted = crate::api::ipfs::fetch_content(api, &resolve.cid).await?;
           let decrypted = crypto::ecies::unwrap_key(&encrypted, private_key)
               .map_err(|e| format!("Registry decryption failed: {}", e))?;
           serde_json::from_slice(&decrypted)
               .map_err(|e| format!("Registry parse failed: {}", e))
       }

       /// Get or create a persistent device ID (stored in macOS Keychain).
       fn get_or_create_device_id() -> String {
           // Try to read from keychain
           // If not found, generate UUID and store
           // Use keyring crate with service="cipherbox-desktop" key="device-id"
       }

       fn get_device_name() -> String {
           hostname::get().map(|h| h.to_string_lossy().to_string())
               .unwrap_or_else(|_| "CipherBox Desktop".to_string())
       }

       fn get_device_model() -> String {
           "macOS Desktop".to_string() // Could use sysinfo crate for model name
       }

       fn now_ms() -> u64 {
           std::time::SystemTime::now()
               .duration_since(std::time::UNIX_EPOCH)
               .map(|d| d.as_millis() as u64)
               .unwrap_or(0)
       }
       ```

    4. Add `hostname = "0.3"` to Cargo.toml for device name.

  </action>
  <verify>
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check` passes.
  </verify>
  <done>
    Device registry module created with types matching web app, ECIES encryption, HKDF-derived IPNS name, and full register/fetch/update cycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Non-blocking registry call in auth flow</name>
  <files>
    apps/desktop/src-tauri/src/commands.rs
    apps/desktop/src-tauri/src/state.rs
  </files>
  <action>
    1. In `handle_auth_complete()` in commands.rs, after step 8 (mark as authenticated), add a non-blocking device registration call:
       ```rust
       // 8b. Register device in encrypted registry (non-blocking)
       let reg_api = state.api.clone();
       let reg_private_key = private_key_bytes.clone();
       let reg_public_key = public_key_bytes.clone();
       let reg_user_id = user_id.clone();
       tokio::spawn(async move {
           let pk_arr: [u8; 32] = reg_private_key.try_into().unwrap_or([0u8; 32]);
           match crate::registry::register_device(
               &reg_api, &pk_arr, &reg_public_key, &reg_user_id
           ).await {
               Ok(()) => log::info!("Device registry updated"),
               Err(e) => log::warn!("Device registry update failed (non-blocking): {}", e),
           }
       });
       ```

    2. The `register_device` call is fire-and-forget. It must NEVER prevent login from completing. Even if IPFS/IPNS is unreachable, the user is already authenticated and can use the app.

    3. Optionally add a `device_id: RwLock<Option<String>>` to AppState for reference by other components (tray menu, sync daemon). But this is not strictly required for the registry to work.

    4. In `logout()`, do NOT deregister the device. Device entries persist in the registry until explicitly revoked from the web app settings.

  </action>
  <verify>
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check` passes.
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo test` passes.
    Grep for `register_device` in commands.rs returns a match.
    Grep for `tokio::spawn` around the register_device call confirms non-blocking execution.
  </verify>
  <done>
    Device registration is called non-blocking after auth. Failures are logged but never block login. Desktop appears in the web app's Authorized Devices view after first login.
  </done>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass
- Device registry types match web app's TypeScript types (camelCase JSON)
- Registry is ECIES-encrypted with user's public key
- Registry IPNS name derived via HKDF (matches web app derivation)
- Registration is non-blocking (tokio::spawn, fire-and-forget)
- First device is auto-authorized, subsequent devices start as 'pending'
</verification>

<success_criteria>

1. Desktop registers itself in the encrypted device registry after authentication
2. Device entry includes platform 'macos', correct metadata fields
3. Registry is ECIES-encrypted and published to HKDF-derived IPNS name
4. Web app can read the registry and see the desktop device entry
5. Registration failures never block the login flow
   </success_criteria>

<output>
After completion, create `.planning/phases/11.1-macos-desktop-catch-up/11.1-06-SUMMARY.md`
</output>
