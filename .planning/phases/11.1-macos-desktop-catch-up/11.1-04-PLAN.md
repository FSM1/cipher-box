---
phase: 11.1-macos-desktop-catch-up
plan: 04
type: execute
wave: 2
depends_on: ['11.1-02']
files_modified:
  - apps/desktop/package.json
  - apps/desktop/src/auth.ts
  - apps/desktop/src/main.ts
  - apps/desktop/src-tauri/src/commands.rs
  - apps/desktop/src-tauri/src/api/types.rs
autonomous: true

must_haves:
  truths:
    - 'Desktop authenticates through CipherBox identity provider + Core Kit loginWithJWT, not PnP Modal SDK'
    - 'Google OAuth login flow: user -> CipherBox backend identity endpoint -> CipherBox JWT -> Core Kit loginWithJWT -> _UNSAFE_exportTssKey -> handle_auth_complete'
    - 'Email OTP login flow: user -> CipherBox backend email OTP -> CipherBox JWT -> Core Kit loginWithJWT -> _UNSAFE_exportTssKey -> handle_auth_complete'
    - "Backend login uses loginType 'corekit' instead of 'social'"
    - 'PnP Modal SDK dependencies (@web3auth/modal, WALLET_CONNECTORS) are removed'
    - 'Dev-key path works: if --dev-key provided, skip Core Kit entirely and call handle_auth_complete directly with computed keypair'
  artifacts:
    - path: 'apps/desktop/src/auth.ts'
      provides: 'Core Kit initialization, loginWithJWT, Google/Email auth flows via CipherBox identity provider'
      contains: 'loginWithJWT'
    - path: 'apps/desktop/src/main.ts'
      provides: 'Updated init flow with Core Kit provider and CipherBox login UI'
      contains: 'loginWithGoogle'
    - path: 'apps/desktop/src-tauri/src/commands.rs'
      provides: "Updated handle_auth_complete with loginType 'corekit'"
      contains: 'corekit'
  key_links:
    - from: 'apps/desktop/src/auth.ts'
      to: 'CipherBox API /auth/identity/*'
      via: 'Google OAuth and Email OTP endpoints'
      pattern: '/auth/identity'
    - from: 'apps/desktop/src/auth.ts'
      to: '@web3auth/mpc-core-kit'
      via: 'Core Kit loginWithJWT with CipherBox JWT'
      pattern: 'loginWithJWT'
    - from: 'apps/desktop/src/auth.ts'
      to: 'apps/desktop/src-tauri/src/commands.rs'
      via: "Tauri IPC invoke('handle_auth_complete')"
      pattern: 'invoke.*handle_auth_complete'
---

<objective>
Migrate desktop auth from PnP Modal SDK to Core Kit with CipherBox identity provider. Replace the Web3Auth modal login with CipherBox-branded login UI using Google OAuth and Email OTP through the CipherBox backend, then Core Kit loginWithJWT.

Purpose: The web app migrated to Core Kit in Phase 12. The desktop must use the same auth flow to produce the same keypair (same sub=userId -> same Web3Auth TSS key -> same vault access).

Output: Rewritten auth.ts and main.ts with Core Kit integration, updated commands.rs for 'corekit' login type.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Web app reference implementation (source of truth for Core Kit auth)

@apps/web/src/lib/web3auth/core-kit-provider.tsx
@apps/web/src/lib/web3auth/hooks.ts
@apps/web/src/hooks/useAuth.ts
@apps/web/src/routes/Login.tsx

# Existing desktop files to rewrite

@apps/desktop/src/auth.ts
@apps/desktop/src/main.ts
@apps/desktop/src-tauri/src/commands.rs
@apps/desktop/src-tauri/src/api/types.rs

# CipherBox identity provider endpoints (backend)

@apps/api/src/auth/controllers/identity.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core Kit SDK setup and auth.ts rewrite</name>
  <files>
    apps/desktop/package.json
    apps/desktop/src/auth.ts
  </files>
  <action>
    1. Update package.json dependencies:
       - Remove: `@web3auth/modal` (PnP Modal SDK)
       - Add: `@web3auth/mpc-core-kit` (Core Kit)
       - Add: `@toruslabs/tss-dkls-lib` (TSS DKLs library required by Core Kit)
       - Keep: `@tauri-apps/api` (Tauri IPC)
       - Run `pnpm install --filter desktop` after updating

    2. Rewrite `auth.ts` completely. Remove all PnP Modal SDK code. New structure:

       ```typescript
       import { invoke } from '@tauri-apps/api/core';
       import {
         Web3AuthMPCCoreKit,
         WEB3AUTH_NETWORK,
         COREKIT_STATUS,
         makeEthereumSigner,
         TssShareType,
         keyToMnemonic,
         mnemonicToKey,
       } from '@web3auth/mpc-core-kit';
       import { tssLib } from '@toruslabs/tss-dkls-lib';

       // CipherBox API base URL (same as Rust backend uses)
       const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3000';
       const WEB3AUTH_CLIENT_ID = import.meta.env.VITE_WEB3AUTH_CLIENT_ID || '';

       let coreKit: Web3AuthMPCCoreKit | null = null;

       /** Initialize Core Kit singleton */
       export async function initCoreKit(): Promise<void> {
         if (coreKit) return;
         coreKit = new Web3AuthMPCCoreKit({
           web3AuthClientId: WEB3AUTH_CLIENT_ID,
           web3AuthNetwork: WEB3AUTH_NETWORK.DEVNET,
           manualSync: true,
           tssLib,
           storage: window.localStorage,
         });
         await coreKit.init();
       }

       /** Get Core Kit status */
       export function getCoreKitStatus(): string {
         return coreKit?.status || 'NOT_INITIALIZED';
       }

       /** Login with Google via CipherBox identity provider */
       export async function loginWithGoogle(): Promise<LoginResult> {
         if (!coreKit) throw new Error('Core Kit not initialized');

         // 1. Get Google ID token via popup (same pattern as web app)
         //    In Tauri webview, use Google Identity Services (GIS) or redirect
         //    For simplicity, open CipherBox backend Google OAuth endpoint
         const googleResponse = await fetch(`${API_BASE}/auth/identity/google/init`, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
         });
         // Actually, desktop should use the same GIS flow as web.
         // Alternative: open a popup window to the Google OAuth URL
         // and intercept the callback with the credential.
         //
         // Simpler approach: use window.open to CipherBox API Google OAuth URL
         // that returns a CipherBox JWT.
         //
         // BEST approach: Load Google Identity Services script in webview,
         // get Google credential, send to CipherBox backend, get CipherBox JWT.
         // This matches the web app exactly.

         // Load Google Identity Services
         const googleIdToken = await getGoogleCredential();

         // 2. Send Google credential to CipherBox backend
         const identityResp = await fetch(`${API_BASE}/auth/identity/google/callback`, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ credential: googleIdToken }),
         });
         if (!identityResp.ok) throw new Error('Google auth failed');
         const { token: cipherboxJwt } = await identityResp.json();

         // 3. Core Kit loginWithJWT
         return await loginWithCoreKit(cipherboxJwt);
       }

       /** Login with Email OTP via CipherBox identity provider */
       export async function loginWithEmail(email: string): Promise<{ requestOtp: true }>;
       export async function loginWithEmail(email: string, otp: string): Promise<LoginResult>;
       export async function loginWithEmail(email: string, otp?: string) {
         if (!otp) {
           // Request OTP
           const resp = await fetch(`${API_BASE}/auth/identity/email/otp`, {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ email }),
           });
           if (!resp.ok) throw new Error('Failed to request OTP');
           return { requestOtp: true };
         }

         // Verify OTP
         const resp = await fetch(`${API_BASE}/auth/identity/email/verify`, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ email, otp }),
         });
         if (!resp.ok) throw new Error('OTP verification failed');
         const { token: cipherboxJwt } = await resp.json();

         return await loginWithCoreKit(cipherboxJwt);
       }

       type LoginResult = { status: 'logged_in' } | { status: 'required_share' };

       /** Core Kit loginWithJWT + key export */
       async function loginWithCoreKit(cipherboxJwt: string): Promise<LoginResult> {
         if (!coreKit) throw new Error('Core Kit not initialized');

         await coreKit.loginWithJWT({
           verifier: 'cipherbox-identity',
           verifierId: extractSub(cipherboxJwt),
           idToken: cipherboxJwt,
         });

         if (coreKit.status === COREKIT_STATUS.REQUIRED_SHARE) {
           return { status: 'required_share' };
         }

         // Export TSS key
         const privateKeyHex = await coreKit._UNSAFE_exportTssKey();

         // Pass to Rust backend
         await invoke('handle_auth_complete', {
           idToken: cipherboxJwt,
           privateKey: privateKeyHex,
         });

         return { status: 'logged_in' };
       }

       /** Extract sub claim from JWT (base64url decode payload) */
       function extractSub(jwt: string): string {
         const payload = jwt.split('.')[1];
         const decoded = JSON.parse(atob(payload.replace(/-/g, '+').replace(/_/g, '/')));
         return decoded.sub;
       }

       /** Get Google credential via Google Identity Services */
       async function getGoogleCredential(): Promise<string> {
         // Load GIS script dynamically if not loaded
         // Render "Sign in with Google" button or use prompt()
         // Return the credential JWT from Google callback
         // This follows the same pattern as web app's GoogleLoginButton
         return new Promise((resolve, reject) => {
           // Implementation: load https://accounts.google.com/gsi/client
           // Initialize with clientId, callback that resolves the promise
           // Trigger prompt() or render button
           // Handle timeout
         });
       }

       /** Logout */
       export async function logout(): Promise<void> {
         await invoke('logout');
         if (coreKit?.status === COREKIT_STATUS.LOGGED_IN) {
           await coreKit.logout();
         }
       }
       ```

       The above is a structural outline. The actual implementation should:
       - Load Google Identity Services script dynamically in the Tauri webview
       - Use `google.accounts.id.initialize()` with the Google client ID from env
       - Handle the credential callback to get the Google JWT
       - For email: simple fetch() to CipherBox backend OTP endpoints
       - The verifier name `cipherbox-identity` must match the web app exactly (check web app Core Kit config for the verifier name used in DEVNET)

       Read `apps/web/src/lib/web3auth/hooks.ts` to get the exact verifier name, network, and loginWithJWT parameters used by the web app.

  </action>
  <verify>
    `cd /Users/michael/Code/cipher-box/apps/desktop && pnpm install` succeeds.
    `@web3auth/modal` no longer in node_modules.
    `@web3auth/mpc-core-kit` is in node_modules.
    TypeScript compiles: `cd /Users/michael/Code/cipher-box/apps/desktop && pnpm exec tsc --noEmit` (or Vite build check).
  </verify>
  <done>
    auth.ts rewritten to use Core Kit loginWithJWT with CipherBox identity provider. PnP Modal SDK removed. Google and Email login flows use CipherBox backend identity endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Login UI in main.ts + Rust loginType update</name>
  <files>
    apps/desktop/src/main.ts
    apps/desktop/src-tauri/src/commands.rs
    apps/desktop/src-tauri/src/api/types.rs
  </files>
  <action>
    1. Rewrite `main.ts` to show CipherBox-branded login UI instead of a single [CONNECT] button:

       ```typescript
       import './polyfills';
       import { invoke } from '@tauri-apps/api/core';
       import { getCurrentWindow } from '@tauri-apps/api/window';
       import { initCoreKit, loginWithGoogle, loginWithEmail, getCoreKitStatus, logout } from './auth';

       async function init(): Promise<void> {
         const appDiv = document.getElementById('app');
         if (!appDiv) return;

         // Check for dev-key mode (debug builds)
         const devKey: string | null = await invoke('get_dev_key');
         if (devKey) {
           appDiv.innerHTML = '<div style="...">Dev mode: authenticating with provided key...</div>';
           // Use test-login endpoint or directly call handle_auth_complete
           await handleDevKeyAuth(devKey);
           return;
         }

         // Initialize Core Kit
         appDiv.innerHTML = '<div style="...">Initializing CipherBox...</div>';
         try {
           await initCoreKit();
         } catch (err) {
           // Show error with retry button
           return;
         }

         // Show login form
         renderLoginForm(appDiv);
       }

       function renderLoginForm(appDiv: HTMLElement): void {
         appDiv.innerHTML = `
           <div style="color: #d1d5db; font-family: monospace; padding: 2rem; text-align: center; max-width: 320px; margin: 0 auto;">
             <div style="font-size: 1.25rem; margin-bottom: 1.5rem;">CipherBox Desktop</div>

             <div id="google-signin-container" style="margin-bottom: 1rem;">
               <button id="google-btn" style="...">
                 Sign in with Google
               </button>
             </div>

             <div style="color: #6b7280; margin: 1rem 0;">or</div>

             <div id="email-section">
               <input id="email-input" type="email" placeholder="Email address"
                 style="width: 100%; padding: 0.5rem; background: #1f2937; border: 1px solid #374151; color: #d1d5db; font-family: monospace;" />
               <button id="email-btn" style="..." >
                 Send OTP
               </button>
             </div>

             <div id="otp-section" style="display: none;">
               <input id="otp-input" type="text" placeholder="Enter OTP code" maxlength="6"
                 style="..." />
               <button id="otp-btn" style="...">
                 Verify
               </button>
             </div>

             <div id="auth-status" style="margin-top: 1rem; font-size: 0.875rem;"></div>
           </div>
         `;

         // Wire up Google button
         document.getElementById('google-btn')?.addEventListener('click', async () => {
           const statusEl = document.getElementById('auth-status')!;
           try {
             statusEl.textContent = 'Connecting to Google...';
             const result = await loginWithGoogle();
             if (result.status === 'required_share') {
               renderRequiredShareUI(appDiv);
               return;
             }
             handleAuthSuccess();
           } catch (err) {
             statusEl.style.color = '#ef4444';
             statusEl.textContent = err instanceof Error ? err.message : 'Google login failed';
           }
         });

         // Wire up Email OTP flow
         document.getElementById('email-btn')?.addEventListener('click', async () => {
           const email = (document.getElementById('email-input') as HTMLInputElement).value;
           const statusEl = document.getElementById('auth-status')!;
           try {
             statusEl.textContent = 'Sending OTP...';
             await loginWithEmail(email);
             // Show OTP input
             document.getElementById('email-section')!.style.display = 'none';
             document.getElementById('otp-section')!.style.display = 'block';
             statusEl.textContent = 'OTP sent to ' + email;
             statusEl.style.color = '#9ca3af';

             // Wire OTP verify
             document.getElementById('otp-btn')?.addEventListener('click', async () => {
               const otp = (document.getElementById('otp-input') as HTMLInputElement).value;
               try {
                 statusEl.textContent = 'Verifying...';
                 const result = await loginWithEmail(email, otp);
                 if (result.status === 'required_share') {
                   renderRequiredShareUI(appDiv);
                   return;
                 }
                 handleAuthSuccess();
               } catch (err) {
                 statusEl.style.color = '#ef4444';
                 statusEl.textContent = 'OTP verification failed';
               }
             });
           } catch (err) {
             statusEl.style.color = '#ef4444';
             statusEl.textContent = 'Failed to send OTP';
           }
         });
       }

       async function handleAuthSuccess(): Promise<void> {
         const statusEl = document.getElementById('auth-status');
         if (statusEl) {
           statusEl.style.color = '#10b981';
           statusEl.textContent = 'Authenticated. CipherBox is running in the menu bar.';
         }
         setTimeout(async () => {
           const window = getCurrentWindow();
           await window.hide();
         }, 1500);
       }

       async function handleDevKeyAuth(devKeyHex: string): Promise<void> {
         // For dev mode: call test-login endpoint or directly invoke handle_auth_complete
         // 1. Derive public key from dev key (use the backend test-login endpoint)
         // 2. Get a test JWT from /auth/test-login
         // 3. Call handle_auth_complete with the JWT and dev key
         // This enables CI to test the desktop app without Web3Auth
       }
       ```

    2. In `commands.rs`, update `handle_auth_complete`:
       - Change `login_type: "social".to_string()` to `login_type: "corekit".to_string()`
       - The CipherBox JWT from the identity provider is passed as `id_token` -- the backend's `POST /auth/login` with `loginType: 'corekit'` verifies it as a CipherBox JWT (not a Web3Auth JWT)

    3. In `api/types.rs`, no structural changes needed (LoginRequest already has login_type field).
       But do verify the LoginRequest is sent with the corekit login type.

    4. Handle `renderRequiredShareUI()` as a stub that shows "MFA required - recovery phrase or device approval needed" message. Plan 05 will implement the full MFA UI.

  </action>
  <verify>
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check` passes.
    `cd /Users/michael/Code/cipher-box/apps/desktop && pnpm exec tsc --noEmit` passes (or Vite build).
    Grep for `loginType.*corekit` or `login_type.*corekit` in commands.rs returns a match.
    Grep for `@web3auth/modal` in auth.ts returns 0 results.
  </verify>
  <done>
    Desktop webview shows CipherBox-branded login form with Google OAuth and Email OTP options. Auth flow goes through CipherBox identity provider + Core Kit loginWithJWT. Backend login uses loginType 'corekit'. PnP Modal SDK fully removed. REQUIRED_SHARE status handled with stub UI (MFA flow in Plan 05).
  </done>
</task>

</tasks>

<verification>
- Desktop auth uses Core Kit loginWithJWT, not PnP Modal SDK connect()
- Google login goes through CipherBox backend identity endpoint -> CipherBox JWT -> Core Kit
- Email login goes through CipherBox backend OTP endpoint -> CipherBox JWT -> Core Kit
- Private key extracted via _UNSAFE_exportTssKey (same as web app)
- loginType changed to 'corekit' for backend auth
- No @web3auth/modal imports remain
- TypeScript and Rust both compile cleanly
</verification>

<success_criteria>

1. Desktop uses Core Kit loginWithJWT with CipherBox identity provider (same verifier as web app)
2. Google OAuth and Email OTP login work through CipherBox backend endpoints
3. loginType 'corekit' used for backend auth
4. PnP Modal SDK completely removed
5. REQUIRED_SHARE status triggers stub UI (placeholder for Plan 05 MFA)
   </success_criteria>

<output>
After completion, create `.planning/phases/11.1-macos-desktop-catch-up/11.1-04-SUMMARY.md`
</output>
