---
phase: 11.1-macos-desktop-catch-up
plan: 05
type: execute
wave: 3
depends_on: ['11.1-04']
files_modified:
  - apps/desktop/src/auth.ts
  - apps/desktop/src/main.ts
autonomous: true

must_haves:
  truths:
    - 'When Core Kit returns REQUIRED_SHARE status, desktop shows recovery phrase input UI'
    - 'User can enter 24-word recovery phrase to provide the missing share and complete login'
    - 'User can request cross-device approval from the desktop (enters waiting state until approved)'
    - 'After MFA recovery or approval, _UNSAFE_exportTssKey succeeds and auth completes normally'
    - 'Desktop approveDevice() function is implemented but no UI trigger (web app is the approving device for now)'
  artifacts:
    - path: 'apps/desktop/src/auth.ts'
      provides: 'MFA recovery and approval functions: inputRecoveryPhrase, requestDeviceApproval, approveDevice (no UI)'
      contains: 'mnemonicToKey'
    - path: 'apps/desktop/src/main.ts'
      provides: 'REQUIRED_SHARE UI: recovery phrase form, approval request UI'
      contains: 'renderRequiredShareUI'
  key_links:
    - from: 'apps/desktop/src/auth.ts'
      to: '@web3auth/mpc-core-kit'
      via: 'coreKit.inputFactorKey for recovery, coreKit.createFactor for new device'
      pattern: 'inputFactorKey'
    - from: 'apps/desktop/src/main.ts'
      to: 'CipherBox API /device-approval/*'
      via: 'Polling for approval status, creating approval requests'
      pattern: 'device-approval'
---

<objective>
Implement MFA support in the desktop webview: recovery phrase input for REQUIRED_SHARE status, cross-device approval request/response. Device approval UI for approving other devices is deferred (web app is the approving device for now).

Purpose: When users have MFA enabled, the desktop app needs a second factor (device share or recovery phrase) to reconstruct the TSS key. This plan implements the UI and logic for both recovery paths. The approveDevice() function is implemented but has no UI trigger until Phase 11.2 (cross-device approval flows).

Output: Updated auth.ts with MFA functions and main.ts with recovery/approval UI. approveDevice() implemented as API-complete stub without UI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs

@.planning/phases/11.1-macos-desktop-catch-up/11.1-04-SUMMARY.md

# Web app MFA reference implementation

@apps/web/src/lib/web3auth/hooks.ts
@apps/web/src/routes/Login.tsx
@apps/web/src/hooks/useMfa.ts

# CipherBox API device approval endpoints

@apps/api/src/auth/controllers/device-approval.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MFA recovery and approval in auth.ts</name>
  <files>
    apps/desktop/src/auth.ts
  </files>
  <action>
    Add MFA functions to auth.ts (extending the Core Kit auth module from Plan 04):

    1. **Recovery phrase input:**
       ```typescript
       export async function inputRecoveryPhrase(mnemonic: string): Promise<void> {
         if (!coreKit) throw new Error('Core Kit not initialized');
         if (coreKit.status !== COREKIT_STATUS.REQUIRED_SHARE) {
           throw new Error('Not in REQUIRED_SHARE state');
         }

         // Convert mnemonic to factor key
         const factorKey = mnemonicToKey(mnemonic);

         // Input the factor key to Core Kit
         await coreKit.inputFactorKey(new BN(factorKey, 'hex'));

         // After successful input, Core Kit status should be LOGGED_IN
         if (coreKit.status !== COREKIT_STATUS.LOGGED_IN) {
           throw new Error('Recovery failed: invalid recovery phrase');
         }

         // Create a device factor for this desktop so future logins don't need recovery
         const newDeviceFactorKey = await coreKit.createFactor({
           shareType: TssShareType.DEVICE,
           additionalMetadata: {
             deviceId: await getDesktopDeviceId(),
             platform: 'macos',
             name: getDeviceName(),
           },
         });
         await coreKit.setDeviceFactor(newDeviceFactorKey);
         await coreKit.commitChanges();

         // Now export key and complete auth
         const privateKeyHex = await coreKit._UNSAFE_exportTssKey();
         await invoke('handle_auth_complete', {
           idToken: getLastCipherboxJwt(), // stored from loginWithCoreKit
           privateKey: privateKeyHex,
         });
       }
       ```

    2. **Cross-device approval request:**
       ```typescript
       export async function requestDeviceApproval(): Promise<string> {
         // Create a device approval request on the CipherBox backend
         const resp = await fetch(`${API_BASE}/device-approval/request`, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Authorization': `Bearer ${getTemporaryAccessToken()}`,
           },
           body: JSON.stringify({
             deviceName: getDeviceName(),
             platform: 'macos',
           }),
         });
         if (!resp.ok) throw new Error('Failed to create approval request');
         const { requestId } = await resp.json();
         return requestId;
       }

       export async function pollApprovalStatus(requestId: string): Promise<'pending' | 'approved' | 'rejected' | 'expired'> {
         const resp = await fetch(`${API_BASE}/device-approval/${requestId}/status`, {
           headers: {
             'Authorization': `Bearer ${getTemporaryAccessToken()}`,
           },
         });
         if (!resp.ok) throw new Error('Failed to check approval status');
         const { status, factorKey } = await resp.json();

         if (status === 'approved' && factorKey) {
           // Use the provided factor key to complete login
           await coreKit!.inputFactorKey(new BN(factorKey, 'hex'));
           const privateKeyHex = await coreKit!._UNSAFE_exportTssKey();
           await invoke('handle_auth_complete', {
             idToken: getLastCipherboxJwt(),
             privateKey: privateKeyHex,
           });
         }

         return status;
       }
       ```

    3. **Respond to approval requests (approving device) - NO UI TRIGGER:**
       ```typescript
       /**
        * Approve a device approval request (API-complete stub).
        *
        * This function is fully implemented and tested, but has no UI trigger
        * in Phase 11.1. Users must approve devices from the web app.
        *
        * Phase 11.2 will add approval notification UI (tray icon notification +
        * approval dialog when desktop is the approving device).
        */
       export async function approveDevice(requestId: string): Promise<void> {
         if (!coreKit || coreKit.status !== COREKIT_STATUS.LOGGED_IN) {
           throw new Error('Must be logged in to approve devices');
         }

         // Create a new device factor for the requesting device
         const newFactorKey = await coreKit.createFactor({
           shareType: TssShareType.DEVICE,
         });
         await coreKit.commitChanges();

         // Send the factor key to the requesting device via the bulletin board
         const resp = await fetch(`${API_BASE}/device-approval/${requestId}/approve`, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Authorization': `Bearer ${getCurrentAccessToken()}`,
           },
           body: JSON.stringify({ factorKey: newFactorKey.toString('hex') }),
         });
         if (!resp.ok) throw new Error('Failed to approve device');
       }
       ```

    4. **Helper functions:**
       - `getDesktopDeviceId()`: generate or retrieve a persistent device ID (stored in localStorage)
       - `getDeviceName()`: return hostname via Tauri `invoke('get_hostname')` or navigator.userAgent
       - `getLastCipherboxJwt()`: module-level variable storing the JWT from the last loginWithCoreKit call
       - `getTemporaryAccessToken()`: for REQUIRED_SHARE state, the backend issues a limited token
       - `getCurrentAccessToken()`: for fully authenticated state

    5. Import `BN` from `bn.js` (dependency of Core Kit, already available).

    6. Add comment in auth.ts near approveDevice():
       ```typescript
       // TODO (Phase 11.2): Add approval listener after auth success to poll for pending
       // approval requests and show native notification when approval is needed.
       ```

  </action>
  <verify>
    TypeScript compiles without errors. Grep for `inputFactorKey` and `mnemonicToKey` in auth.ts.
    Grep for `approveDevice` in auth.ts shows function is defined.
  </verify>
  <done>
    MFA recovery (inputRecoveryPhrase), device approval request (requestDeviceApproval + pollApprovalStatus), and device factor creation are implemented. approveDevice() function is implemented and API-complete but has no UI trigger (deferred to Phase 11.2).
  </done>
</task>

<task type="auto">
  <name>Task 2: REQUIRED_SHARE UI in main.ts</name>
  <files>
    apps/desktop/src/main.ts
  </files>
  <action>
    Implement `renderRequiredShareUI()` in main.ts (replaces the stub from Plan 04):

    1. Show a screen with two options:
       - "Enter Recovery Phrase" - opens a textarea for 24-word mnemonic input
       - "Request Device Approval" - creates an approval request and shows waiting state

    2. Recovery phrase path:
       ```typescript
       function renderRequiredShareUI(appDiv: HTMLElement): void {
         appDiv.innerHTML = `
           <div style="color: #d1d5db; font-family: monospace; padding: 2rem; max-width: 400px; margin: 0 auto;">
             <div style="font-size: 1.1rem; margin-bottom: 1rem; color: #f59e0b;">
               MFA Required
             </div>
             <div style="font-size: 0.875rem; color: #9ca3af; margin-bottom: 1.5rem;">
               This device needs a second factor to access your vault.
             </div>

             <button id="recovery-btn" style="...">
               Enter Recovery Phrase
             </button>

             <button id="approval-btn" style="...">
               Request Device Approval
             </button>

             <div id="recovery-form" style="display: none; margin-top: 1rem;">
               <textarea id="mnemonic-input" rows="3" placeholder="Enter your 24-word recovery phrase..."
                 style="width: 100%; background: #1f2937; border: 1px solid #374151; color: #d1d5db; font-family: monospace; padding: 0.5rem;"></textarea>
               <button id="submit-recovery" style="...">Recover</button>
             </div>

             <div id="approval-waiting" style="display: none; margin-top: 1rem;">
               <div style="color: #9ca3af;">Waiting for approval from another device...</div>
               <div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.5rem;">
                 Approve this device from your web app or another authorized device.
               </div>
               <div id="approval-status" style="margin-top: 0.5rem;"></div>
             </div>

             <div id="mfa-status" style="margin-top: 1rem; font-size: 0.875rem;"></div>
           </div>
         `;

         // Wire recovery phrase button
         document.getElementById('recovery-btn')?.addEventListener('click', () => {
           document.getElementById('recovery-form')!.style.display = 'block';
           document.getElementById('approval-waiting')!.style.display = 'none';
         });

         // Wire recovery submit
         document.getElementById('submit-recovery')?.addEventListener('click', async () => {
           const mnemonic = (document.getElementById('mnemonic-input') as HTMLTextAreaElement).value.trim();
           const statusEl = document.getElementById('mfa-status')!;
           try {
             statusEl.textContent = 'Recovering...';
             await inputRecoveryPhrase(mnemonic);
             handleAuthSuccess();
           } catch (err) {
             statusEl.style.color = '#ef4444';
             statusEl.textContent = err instanceof Error ? err.message : 'Recovery failed';
           }
         });

         // Wire approval request button
         document.getElementById('approval-btn')?.addEventListener('click', async () => {
           document.getElementById('recovery-form')!.style.display = 'none';
           document.getElementById('approval-waiting')!.style.display = 'block';
           const statusEl = document.getElementById('approval-status')!;

           try {
             const requestId = await requestDeviceApproval();
             statusEl.textContent = 'Approval request sent. Waiting...';

             // Poll every 3 seconds
             const pollInterval = setInterval(async () => {
               try {
                 const status = await pollApprovalStatus(requestId);
                 if (status === 'approved') {
                   clearInterval(pollInterval);
                   handleAuthSuccess();
                 } else if (status === 'rejected') {
                   clearInterval(pollInterval);
                   statusEl.style.color = '#ef4444';
                   statusEl.textContent = 'Approval was rejected.';
                 } else if (status === 'expired') {
                   clearInterval(pollInterval);
                   statusEl.style.color = '#ef4444';
                   statusEl.textContent = 'Approval request expired.';
                 }
               } catch {
                 // Continue polling on transient errors
               }
             }, 3000);
           } catch (err) {
             statusEl.style.color = '#ef4444';
             statusEl.textContent = 'Failed to request approval';
           }
         });
       }
       ```

    3. Import `inputRecoveryPhrase`, `requestDeviceApproval`, `pollApprovalStatus` from auth.ts.

    4. Do NOT add approval listener for when this desktop IS the approving device:
       - This is explicitly deferred to Phase 11.2
       - For now, users must approve devices from the web app
       - Add a comment in main.ts:
         ```typescript
         // TODO (Phase 11.2): Add approval listener after auth success to poll for
         // pending approval requests and show native notification when approval needed.
         ```

  </action>
  <verify>
    TypeScript compiles. Both "Enter Recovery Phrase" and "Request Device Approval" UI paths are wired.
    Grep for "TODO.*Phase 11.2" in main.ts shows the approval listener deferral comment.
  </verify>
  <done>
    REQUIRED_SHARE UI shows recovery phrase input and device approval request options. Recovery phrase submission calls inputRecoveryPhrase which uses Core Kit inputFactorKey + mnemonicToKey. Approval request creates a bulletin board request and polls for status. Auth completes normally after either recovery path succeeds. approveDevice() is implemented but has no UI trigger (web app is the approving device for now).
  </done>
</task>

</tasks>

<verification>
- REQUIRED_SHARE Core Kit status triggers MFA UI (not crash or blank screen)
- Recovery phrase input converts mnemonic to factor key and completes login
- Device approval creates request and polls for status
- After recovery: device factor created for future logins (no recovery needed next time)
- Auth completes normally (handle_auth_complete called) after either MFA path
- approveDevice() function exists and is API-complete but has no UI trigger
</verification>

<success_criteria>

1. REQUIRED_SHARE status shows MFA recovery UI with two options
2. Recovery phrase path: mnemonic -> factorKey -> inputFactorKey -> TSS key export -> auth complete
3. Device approval path: request -> poll -> approved -> factorKey -> auth complete
4. New device factor created after recovery (future logins on this desktop don't need recovery)
5. approveDevice() function is implemented and API-complete (deferred UI in Phase 11.2)
   </success_criteria>

<output>
After completion, create `.planning/phases/11.1-macos-desktop-catch-up/11.1-05-SUMMARY.md`
</output>
