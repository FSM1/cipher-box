---
phase: 11.1-macos-desktop-catch-up
plan: 03
type: execute
wave: 2
depends_on: ['11.1-01']
files_modified:
  - apps/desktop/src-tauri/src/commands.rs
  - apps/desktop/src-tauri/src/fuse/inode.rs
  - apps/desktop/src-tauri/src/fuse/operations.rs
  - apps/desktop/src-tauri/src/fuse/mod.rs
  - apps/desktop/src-tauri/src/fuse/cache.rs
autonomous: true

must_haves:
  truths:
    - 'initialize_vault derives IPNS keypair deterministically via HKDF instead of random generation'
    - 'FUSE layer parses v2 FolderMetadata with FilePointer entries and resolves per-file IPNS to get file CID/IV/key'
    - "FUSE read() dispatches to AES-CTR decryption for files with encryptionMode 'CTR'"
    - "FUSE read() continues to use AES-GCM decryption for files with encryptionMode 'GCM' or missing mode"
    - 'FilePointer-based files appear as regular files in Finder with correct sizes after IPNS resolution'
  artifacts:
    - path: 'apps/desktop/src-tauri/src/commands.rs'
      provides: 'Deterministic HKDF-based vault IPNS derivation in initialize_vault'
      contains: 'derive_vault_ipns_keypair'
    - path: 'apps/desktop/src-tauri/src/fuse/inode.rs'
      provides: 'InodeKind::File with encryption_mode dispatch and FilePointer support'
      contains: 'encryption_mode'
    - path: 'apps/desktop/src-tauri/src/fuse/operations.rs'
      provides: 'v2 metadata parsing, per-file IPNS resolution, CTR decryption dispatch in read()'
      contains: 'decrypt_aes_ctr'
  key_links:
    - from: 'apps/desktop/src-tauri/src/commands.rs'
      to: 'apps/desktop/src-tauri/src/crypto/hkdf.rs'
      via: 'HKDF vault derivation replaces random keygen'
      pattern: 'hkdf::derive_vault_ipns_keypair'
    - from: 'apps/desktop/src-tauri/src/fuse/operations.rs'
      to: 'apps/desktop/src-tauri/src/crypto/aes_ctr.rs'
      via: 'CTR decryption for media files in read() callback'
      pattern: 'aes_ctr::decrypt_aes_ctr'
    - from: 'apps/desktop/src-tauri/src/fuse/inode.rs'
      to: 'apps/desktop/src-tauri/src/crypto/folder.rs'
      via: 'FilePointer and FolderMetadataV2 types used in populate_folder'
      pattern: 'FilePointer'
---

<objective>
Rewrite initialize_vault to use HKDF-based deterministic IPNS derivation, and update the FUSE layer to parse v2 folder metadata (FilePointer resolution) and decrypt AES-CTR encrypted files.

Purpose: This makes the desktop vault interoperable with the web app's current schema. Files uploaded via web (including CTR-encrypted media) become accessible through the FUSE mount. Vault initialization matches the web app's deterministic derivation.

Output: Updated commands.rs with HKDF vault init, and FUSE layer handling v2 metadata + CTR decryption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs

@.planning/phases/11.1-macos-desktop-catch-up/11.1-01-SUMMARY.md

# Files to modify

@apps/desktop/src-tauri/src/commands.rs
@apps/desktop/src-tauri/src/fuse/inode.rs
@apps/desktop/src-tauri/src/fuse/operations.rs
@apps/desktop/src-tauri/src/fuse/mod.rs
@apps/desktop/src-tauri/src/fuse/cache.rs

# Reference: crypto primitives from Plan 01

@apps/desktop/src-tauri/src/crypto/hkdf.rs
@apps/desktop/src-tauri/src/crypto/aes_ctr.rs
@apps/desktop/src-tauri/src/crypto/folder.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: HKDF vault initialization in commands.rs</name>
  <files>
    apps/desktop/src-tauri/src/commands.rs
  </files>
  <action>
    In `initialize_vault()` in commands.rs, replace random IPNS keygen with HKDF:

    1. Remove: `let (ipns_public_key, ipns_private_key) = crypto::ed25519::generate_ed25519_keypair();`

    2. Add: derive private key as [u8; 32] from the state's private_key:
       ```rust
       // Convert private key bytes to [u8; 32] array
       let private_key_arr: [u8; 32] = private_key_bytes.try_into()
           .map_err(|_| "Invalid private key length")?;
       ```

    3. Call `crypto::hkdf::derive_vault_ipns_keypair(&private_key_arr)` to get (ipns_private_key, ipns_public_key, ipns_name):
       ```rust
       let (ipns_private_key, ipns_public_key, ipns_name) =
           crypto::hkdf::derive_vault_ipns_keypair(&private_key_arr)
               .map_err(|e| format!("Vault IPNS derivation failed: {:?}", e))?;
       ```

    4. Use the derived ipns_name directly instead of calling derive_ipns_name separately (remove redundant call).

    5. The rest of initialize_vault remains the same:
       - ECIES wrap the IPNS private key with TEE public key
       - POST /vault/init with the wrapped key
       - Publish initial metadata to IPNS

    6. Update fetch_and_decrypt_vault: after decrypting the IPNS private key from the vault, verify it matches what HKDF would derive:
       ```rust
       // After decrypting ipns_private_key from vault
       let expected = crypto::hkdf::derive_vault_ipns_keypair(&private_key_arr)?;
       if ipns_private_key != expected.0 {
           log::warn!("Vault IPNS key mismatch: stored key differs from HKDF derivation");
           // Don't block - proceed with stored key for backward compatibility
       }
       ```

    7. Keep login_type as "social" for now (Plan 04 will change to "corekit" during Core Kit migration).

  </action>
  <verify>
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check` passes.
  </verify>
  <done>
    initialize_vault uses HKDF for deterministic IPNS derivation instead of random keygen. Vault IPNS keypair is now reproducible from user's private key.
  </done>
</task>

<task type="auto">
  <name>Task 2: v2 folder metadata + CTR decryption in FUSE layer</name>
  <files>
    apps/desktop/src-tauri/src/fuse/inode.rs
    apps/desktop/src-tauri/src/fuse/operations.rs
    apps/desktop/src-tauri/src/fuse/mod.rs
    apps/desktop/src-tauri/src/fuse/cache.rs
  </files>
  <action>
    **Part A: v2 folder metadata parsing** (inode.rs, operations.rs):

    1. In `inode.rs`, update InodeKind::File to support FilePointer and encryption_mode:
       - Add `file_meta_ipns_name: Option<String>` field for FilePointer IPNS resolution
       - Add `file_meta_resolved: bool` field to track resolution status
       - Add `encryption_mode: String` field (default "GCM" for v1 files)

    2. In `inode.rs`, update `populate_folder()` to handle both v1 and v2 metadata:
       - Import AnyFolderMetadata, FolderMetadataV2, FolderChildV2, FilePointer from crypto::folder
       - Use `decrypt_any_folder_metadata()` instead of `decrypt_folder_metadata()` where metadata is parsed
       - For V1: existing logic (FolderChild::File has inline CID, IV, key)
       - For V2: FolderChildV2::File is a FilePointer with only name and fileMetaIpnsName
         - Store fileMetaIpnsName in InodeKind::File
         - Initially set CID/IV/key fields as empty/placeholder
         - Set file_meta_resolved = false

    3. In `operations.rs`, add per-file IPNS resolution during populate_folder:
       - After creating FilePointer inodes in populate_folder, spawn async tasks to resolve all FilePointers' IPNS names
       - For each FilePointer:
         a. resolve_ipns(ipns_name) -> get CID
         b. Fetch CID content from IPFS
         c. Decrypt with parent folder key (FileMetadata is encrypted with parent's folderKey)
         d. Parse FileMetadata JSON
         e. Update InodeKind::File fields: cid, file_key_encrypted, file_iv, size, encryption_mode
         f. Set file_meta_resolved = true
       - Use eager resolution (resolve in populate_folder before mount) to avoid NFS stalls
       - CRITICAL: Never block FUSE callbacks. Pre-resolve all FilePointers before first READDIR.

    4. In `cache.rs`, update MetadataCache to store AnyFolderMetadata or handle both versions.

    **Part B: AES-CTR dispatch in read()** (operations.rs):

    5. In the `read()` callback, where file content is decrypted:
       - Check `encryption_mode` field on the file's InodeKind
       - If "GCM": use existing `crypto::aes::unseal_aes_gcm()` path
       - If "CTR": use `crypto::aes_ctr::decrypt_aes_ctr()` with the file's IV (16 bytes, not 12)
         - CTR files have NO auth tag, so ciphertext == plaintext size
         - For partial reads (FUSE read with offset/size), use `decrypt_aes_ctr_range()` for efficiency
       - Default to "GCM" if encryption_mode is empty or missing

    6. In `build_metadata_from_inodes()` in mod.rs, handle both v1 and v2 output:
       - When writing metadata back (create, rename, delete operations), produce v2 format if the folder was loaded as v2
       - Store the folder version in the inode or metadata cache to know which format to produce on write
       - For FilePointer children: reconstruct FilePointer with just name + fileMetaIpnsName (not inline data)

    **NFS Stability Considerations** (from learnings):

    7. Inode stability: populate_folder must reuse existing ino numbers when refreshing (prevents "stale file handle").

    8. READDIR cache: First response must be correct. Pre-resolve all FilePointer sizes before the first readdir.

    9. No blocking: All IPFS/IPNS resolution must complete before any FUSE callback can access the inode.

  </action>
  <verify>
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check` passes.
    `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo test` passes.
  </verify>
  <done>
    FUSE layer parses v2 FolderMetadata with FilePointer entries, resolves per-file IPNS to get file metadata (CID, IV, key, encryption_mode), and dispatches to AES-CTR or AES-GCM decryption based on encryptionMode field. All operations compile and tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass
- initialize_vault calls derive_vault_ipns_keypair instead of generate_ed25519_keypair
- FUSE code handles both FolderMetadata (v1) and FolderMetadataV2 (v2) formats
- FilePointer entries trigger IPNS resolution to fetch FileMetadata
- read() dispatches to CTR or GCM based on encryption_mode
- No blocking calls in FUSE callbacks (NFS safety)
</verification>

<success_criteria>

1. Vault initialization derives IPNS keypair deterministically via HKDF (matches web app derivation for same private key)
2. v2 folder metadata with FilePointer children is parsed and files appear in FUSE with correct sizes
3. AES-CTR encrypted files are decrypted correctly when read through FUSE
4. AES-GCM files continue to work unchanged (backward compatible)
5. No FUSE/NFS stability regressions (no blocking in callbacks)
   </success_criteria>

<output>
After completion, create `.planning/phases/11.1-macos-desktop-catch-up/11.1-03-SUMMARY.md`
</output>
