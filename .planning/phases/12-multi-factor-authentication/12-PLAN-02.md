---
phase: 12-core-kit-identity-provider
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/src/lib/web3auth/core-kit.ts
  - apps/web/src/lib/web3auth/core-kit-provider.tsx
  - apps/web/vite.config.ts
  - apps/web/src/polyfills.ts
autonomous: true

must_haves:
  truths:
    - 'MPC Core Kit SDK is installed and initializes without errors in the browser'
    - 'COREKIT_STATUS state machine transitions are observable: NOT_INITIALIZED -> INITIALIZED (after init())'
    - 'React context provides Core Kit instance and status to child components'
    - 'Vite builds successfully with all required polyfills for Core Kit WASM modules'
  artifacts:
    - path: 'apps/web/src/lib/web3auth/core-kit.ts'
      provides: 'Core Kit singleton, init function, status exports'
      exports: ['getCoreKit', 'initCoreKit', 'COREKIT_STATUS']
    - path: 'apps/web/src/lib/web3auth/core-kit-provider.tsx'
      provides: 'React context provider for Core Kit instance and status'
      exports: ['CoreKitProvider', 'useCoreKit']
  key_links:
    - from: 'apps/web/src/lib/web3auth/core-kit.ts'
      to: '@web3auth/mpc-core-kit'
      via: 'Web3AuthMPCCoreKit constructor'
      pattern: 'new Web3AuthMPCCoreKit'
    - from: 'apps/web/src/lib/web3auth/core-kit-provider.tsx'
      to: 'apps/web/src/lib/web3auth/core-kit.ts'
      via: 'import getCoreKit, initCoreKit'
      pattern: 'initCoreKit|getCoreKit'
---

<objective>
Install MPC Core Kit SDK and create the React context provider that wraps the singleton Core Kit instance. This is the frontend foundation -- no login flow yet, just SDK setup and initialization.

Purpose: Core Kit is fundamentally different from PnP -- it has no React hooks or provider. We need to build our own React integration layer. This plan installs the SDK, creates the singleton, builds the provider, and ensures polyfills work. Plan 03 will wire the actual auth flow.

Output: Core Kit singleton module, React context provider, updated Vite config for polyfills.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-multi-factor-authentication/12-CONTEXT.md
@.planning/phases/12-multi-factor-authentication/12-RESEARCH-corekit.md

Key existing files:
@apps/web/src/lib/web3auth/config.ts
@apps/web/src/lib/web3auth/provider.tsx
@apps/web/src/main.tsx
@apps/web/src/polyfills.ts
@apps/web/vite.config.ts
@apps/web/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Core Kit SDK + Polyfills</name>
  <files>
    apps/web/package.json
    apps/web/vite.config.ts
    apps/web/src/polyfills.ts
  </files>
  <action>
1. **Install packages** from the monorepo root:
```bash
pnpm --filter web add @web3auth/mpc-core-kit @toruslabs/tss-dkls-lib @web3auth/ethereum-mpc-provider
```

Do NOT install `firebase` (we handle Google OAuth on the backend, not client-side).
Do NOT remove `@web3auth/modal` yet -- it stays until Plan 05 (migration).

2. **Update polyfills** (`apps/web/src/polyfills.ts`):
   The existing polyfills provide `Buffer` and `process`. Core Kit's WASM modules may need additional polyfills. Check if `crypto` needs polyfilling (unlikely -- modern browsers have `window.crypto`). The existing setup should be sufficient, but if build errors arise related to `stream`, `crypto`, or `util`, add `vite-plugin-node-polyfills`:

```bash
pnpm --filter web add -D vite-plugin-node-polyfills
```

And add to `vite.config.ts`:

```typescript
import { nodePolyfills } from 'vite-plugin-node-polyfills';
// In plugins array:
nodePolyfills({ include: ['buffer', 'process', 'stream', 'util', 'crypto'] });
```

Only add this if the simpler polyfills don't work. Try the build first.

3. **Update vite.config.ts** if needed:

- Core Kit's DKLS WASM needs `Cross-Origin-Opener-Policy: same-origin` and `Cross-Origin-Embedder-Policy: require-corp` headers for SharedArrayBuffer access. The existing config already has `Cross-Origin-Opener-Policy: same-origin-allow-popups`. This may need to change to `same-origin` for WASM, BUT that breaks OAuth popups. The solution: keep `same-origin-allow-popups` (WASM works without SharedArrayBuffer, just slower).
- Ensure the `define: { global: 'globalThis' }` is still present (it is).

4. **Verify build**: Run `pnpm --filter web build` and fix any polyfill/build errors before proceeding to Task 2.
   </action>
   <verify> - `pnpm --filter web build` completes without errors - `pnpm --filter web dev` starts and the app loads at http://localhost:5173 without console errors related to Core Kit imports - The existing PnP login flow still works (Core Kit is installed alongside, not replacing yet)
   </verify>
   <done>Core Kit SDK packages installed. Vite build succeeds with all polyfills. Existing app functionality preserved.</done>
   </task>

<task type="auto">
  <name>Task 2: Core Kit Singleton + React Context Provider</name>
  <files>
    apps/web/src/lib/web3auth/core-kit.ts
    apps/web/src/lib/web3auth/core-kit-provider.tsx
  </files>
  <action>
1. **Create `core-kit.ts`** -- Singleton Core Kit instance:

```typescript
import { Web3AuthMPCCoreKit, WEB3AUTH_NETWORK, COREKIT_STATUS } from '@web3auth/mpc-core-kit';
import { tssLib } from '@toruslabs/tss-dkls-lib';

const environment = import.meta.env.VITE_ENVIRONMENT || 'local';

const NETWORK_MAP: Record<string, (typeof WEB3AUTH_NETWORK)[keyof typeof WEB3AUTH_NETWORK]> = {
  local: WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,
  ci: WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,
  staging: WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,
  production: WEB3AUTH_NETWORK.SAPPHIRE_MAINNET,
};

let instance: Web3AuthMPCCoreKit | null = null;

export function getCoreKit(): Web3AuthMPCCoreKit {
  if (!instance && typeof window !== 'undefined') {
    instance = new Web3AuthMPCCoreKit({
      web3AuthClientId: import.meta.env.VITE_WEB3AUTH_CLIENT_ID,
      web3AuthNetwork: NETWORK_MAP[environment] || WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,
      storage: window.localStorage,
      manualSync: true,
      tssLib,
    });
  }
  return instance!;
}

export async function initCoreKit(): Promise<COREKIT_STATUS> {
  const ck = getCoreKit();
  await ck.init();
  return ck.status;
}

export { COREKIT_STATUS };
export type { Web3AuthMPCCoreKit };
```

2. **Create `core-kit-provider.tsx`** -- React context:

```typescript
import { createContext, useContext, useEffect, useState, useCallback, type ReactNode } from 'react';
import { getCoreKit, initCoreKit, COREKIT_STATUS } from './core-kit';
import type { Web3AuthMPCCoreKit } from './core-kit';

interface CoreKitContextValue {
  coreKit: Web3AuthMPCCoreKit | null;
  status: COREKIT_STATUS;
  isInitialized: boolean;
  isLoggedIn: boolean;
  isRequiredShare: boolean;
  error: Error | null;
  reinitialize: () => Promise<void>;
}

const CoreKitContext = createContext<CoreKitContextValue>({
  coreKit: null,
  status: COREKIT_STATUS.NOT_INITIALIZED,
  isInitialized: false,
  isLoggedIn: false,
  isRequiredShare: false,
  error: null,
  reinitialize: async () => {},
});

export function CoreKitProvider({ children }: { children: ReactNode }) {
  const [status, setStatus] = useState<COREKIT_STATUS>(COREKIT_STATUS.NOT_INITIALIZED);
  const [coreKit, setCoreKit] = useState<Web3AuthMPCCoreKit | null>(null);
  const [error, setError] = useState<Error | null>(null);

  const initialize = useCallback(async () => {
    try {
      setError(null);
      const ck = getCoreKit();
      setCoreKit(ck);
      const resultStatus = await initCoreKit();
      setStatus(resultStatus);
    } catch (err) {
      console.error('[CoreKit] Initialization failed:', err);
      setError(err instanceof Error ? err : new Error(String(err)));
    }
  }, []);

  useEffect(() => {
    initialize();
  }, [initialize]);

  const value: CoreKitContextValue = {
    coreKit,
    status,
    isInitialized: status !== COREKIT_STATUS.NOT_INITIALIZED,
    isLoggedIn: status === COREKIT_STATUS.LOGGED_IN,
    isRequiredShare: status === COREKIT_STATUS.REQUIRED_SHARE,
    error,
    reinitialize: initialize,
  };

  return <CoreKitContext.Provider value={value}>{children}</CoreKitContext.Provider>;
}

export function useCoreKit(): CoreKitContextValue {
  const context = useContext(CoreKitContext);
  if (!context) {
    throw new Error('useCoreKit must be used within CoreKitProvider');
  }
  return context;
}
```

Key design decisions:

- The provider initializes Core Kit on mount (calls `init()` which checks for existing sessions)
- Status is tracked in React state and exposed via context
- `reinitialize()` is exposed for retry logic
- `isRequiredShare` is exposed for Phase 12.4 MFA challenge (handle gracefully now: if status is REQUIRED_SHARE, treat as not logged in since MFA enrollment doesn't exist yet)
- Do NOT mount this provider in `main.tsx` yet -- that happens in Plan 03 when we swap providers. For now, this is just the module ready to use.
  </action>
  <verify>
  - `pnpm --filter web build` compiles without errors (TypeScript checks pass)
  - Files exist at `apps/web/src/lib/web3auth/core-kit.ts` and `apps/web/src/lib/web3auth/core-kit-provider.tsx`
  - Import test: temporarily add `import { getCoreKit } from './lib/web3auth/core-kit'` to a test file and verify no import errors
  - `pnpm --filter web build` still succeeds with the new files
    </verify>
    <done>Core Kit singleton module and React context provider created. SDK initializes and exposes COREKIT_STATUS state machine. Ready for Plan 03 to wire auth flow.</done>
    </task>

</tasks>

<verification>
1. `pnpm --filter web build` succeeds with Core Kit packages installed
2. `core-kit.ts` exports `getCoreKit`, `initCoreKit`, `COREKIT_STATUS`
3. `core-kit-provider.tsx` exports `CoreKitProvider`, `useCoreKit`
4. Existing PnP-based app still loads and works (no breaking changes)
5. No console errors related to polyfills or WASM loading
</verification>

<success_criteria>

- Core Kit SDK installed alongside existing PnP SDK (no conflicts)
- Singleton pattern creates exactly one Core Kit instance
- React context provider tracks COREKIT_STATUS state machine
- Vite builds cleanly with all required polyfills
- Existing app functionality is completely preserved
  </success_criteria>

<output>
After completion, create `.planning/phases/12-multi-factor-authentication/12-02-SUMMARY.md`
</output>
