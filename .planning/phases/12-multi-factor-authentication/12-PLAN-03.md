---
phase: 12-core-kit-identity-provider
plan: 03
type: execute
wave: 2
depends_on: ['12-01', '12-02']
files_modified:
  - apps/web/src/lib/web3auth/hooks.ts
  - apps/web/src/hooks/useAuth.ts
  - apps/web/src/lib/api/auth.ts
  - apps/web/src/main.tsx
  - apps/web/src/stores/auth.store.ts
  - apps/api/src/auth/auth.service.ts
autonomous: false

must_haves:
  truths:
    - 'loginWithJWT() is called with CipherBox-issued JWT (from backend identity endpoints), not Web3Auth modal'
    - 'After login, _UNSAFE_exportTssKey() provides the secp256k1 private key for ECIES vault operations'
    - "Session persistence works: page reload restores logged-in state via Core Kit's built-in session"
    - 'Logout calls coreKit.logout(), clears Core Kit session, and clears all local state'
    - 'REQUIRED_SHARE status is handled gracefully (treated as not-logged-in until Phase 12.4)'
    - 'Backend updates placeholder publicKey to real Core Kit-derived publicKey on first /auth/login call'
    - 'Web3Auth custom verifier "cipherbox-identity" is configured on dashboard and validates CipherBox JWTs'
  artifacts:
    - path: 'apps/web/src/lib/web3auth/hooks.ts'
      provides: 'Core Kit auth flow: loginWithGoogle, loginWithEmail, getVaultKeypair, logout'
      exports: ['useCoreKitAuth']
    - path: 'apps/web/src/hooks/useAuth.ts'
      provides: 'Main auth hook rewritten for Core Kit (replaces PnP useAuthFlow integration)'
      exports: ['useAuth']
    - path: 'apps/web/src/lib/api/auth.ts'
      provides: 'Extended API client with identity provider endpoints'
      exports: ['authApi']
    - path: 'apps/api/src/auth/auth.service.ts'
      provides: 'Updated login() that resolves placeholder publicKey users by userId'
  key_links:
    - from: 'apps/web/src/lib/web3auth/hooks.ts'
      to: 'apps/web/src/lib/web3auth/core-kit.ts'
      via: 'getCoreKit() for loginWithJWT calls'
      pattern: 'getCoreKit|loginWithJWT'
    - from: 'apps/web/src/lib/web3auth/hooks.ts'
      to: '/auth/identity/google and /auth/identity/email/*'
      via: 'fetch CipherBox JWT from backend before loginWithJWT'
      pattern: 'identity/google|identity/email'
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/lib/web3auth/hooks.ts'
      via: 'useCoreKitAuth() for login/logout/keypair'
      pattern: 'useCoreKitAuth'
    - from: 'apps/web/src/main.tsx'
      to: 'apps/web/src/lib/web3auth/core-kit-provider.tsx'
      via: 'CoreKitProvider wrapping App'
      pattern: 'CoreKitProvider'
    - from: 'apps/api/src/auth/auth.service.ts'
      to: 'User entity'
      via: 'findOne by publicKey OR by userId for placeholder resolution'
      pattern: 'pending-core-kit|placeholder'
---

<objective>
Rewrite the frontend auth flow to use Core Kit's `loginWithJWT()` with CipherBox-issued JWTs. Wire the frontend to the backend identity provider endpoints (from Plan 01) and the Core Kit SDK (from Plan 02). Also update the backend auth service to handle the placeholder-to-real publicKey transition.

Purpose: This is the critical integration point. After this plan, the login flow is: User action -> CipherBox backend verifies credentials -> issues JWT -> client calls `loginWithJWT()` -> Core Kit derives MPC key -> `_UNSAFE_exportTssKey()` provides private key for vault operations. The existing PnP login flow is replaced.

Output: Rewritten hooks, updated auth store, new API client methods, CoreKitProvider mounted in app, backend auth service updated for placeholder publicKey resolution.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-multi-factor-authentication/12-CONTEXT.md
@.planning/phases/12-multi-factor-authentication/12-RESEARCH-corekit.md
@.planning/phases/12-multi-factor-authentication/12-01-SUMMARY.md
@.planning/phases/12-multi-factor-authentication/12-02-SUMMARY.md

Key existing files to REPLACE/MODIFY:
@apps/web/src/lib/web3auth/hooks.ts (rewrite)
@apps/web/src/hooks/useAuth.ts (rewrite)
@apps/web/src/lib/api/auth.ts (extend)
@apps/web/src/main.tsx (swap provider)
@apps/web/src/stores/auth.store.ts (simplify)
@apps/web/src/lib/web3auth/core-kit.ts (from Plan 02)
@apps/web/src/lib/web3auth/core-kit-provider.tsx (from Plan 02)
@apps/api/src/auth/auth.service.ts (update login for placeholder resolution)
@apps/api/src/auth/services/web3auth-verifier.service.ts (understand existing verification)
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Configure Web3Auth Dashboard Custom Verifier</name>
  <action>
Configure the `cipherbox-identity` custom JWT verifier on the Web3Auth dashboard. This MUST be done before `loginWithJWT()` can work.

**Steps:**

1. Go to <https://dashboard.web3auth.io>
2. Select the CipherBox project (the one whose Client ID is used in `VITE_WEB3AUTH_CLIENT_ID`)
3. Navigate to "Custom Authentication" or "Verifiers" section
4. Create a new **Custom JWT Verifier** with these settings:
   - **Verifier Name:** `cipherbox-identity`
   - **JWT Verifier ID Field:** `sub` (this is the userId from our CipherBox JWT)
   - **JWK Endpoint:** For devnet/local: `http://localhost:3000/auth/.well-known/jwks.json`. For staging: `https://api-staging.cipherbox.cc/auth/.well-known/jwks.json`
   - **Issuer:** `cipherbox` (must match `iss` claim in our JWTs)
   - **Audience:** `web3auth` (must match `aud` claim in our JWTs)
   - **Network:** Sapphire Devnet (for development)

**IMPORTANT NOTES:**

- The JWKS endpoint must be publicly accessible for Web3Auth to validate tokens. For local dev, you may need to use a tunnel (ngrok) or initially test on staging.
- Custom verifiers on devnet are free. Production (mainnet) requires Growth Plan.
- The verifier name `cipherbox-identity` must EXACTLY match what's used in `loginWithJWT({ verifier: 'cipherbox-identity' })` in the frontend code.
- After creating the verifier, note down any verifier ID or sub-verifier configuration needed.

**Verification:** After creating the verifier, confirm it appears in the dashboard verifier list with status "Active".
</action>
<resume-signal>Confirm the verifier is created on the Web3Auth dashboard and share the exact verifier name used (should be "cipherbox-identity"). If a different name was used, we will update the frontend code accordingly.</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Core Kit Auth Hooks + API Client Extensions</name>
  <files>
    apps/web/src/lib/web3auth/hooks.ts
    apps/web/src/lib/api/auth.ts
  </files>
  <action>
**Rewrite `hooks.ts`** -- Replace the entire PnP-based `useAuthFlow()` with `useCoreKitAuth()`:

```typescript
import * as secp256k1 from '@noble/secp256k1';
import { useCoreKit } from './core-kit-provider';
import { COREKIT_STATUS } from './core-kit';
import { authApi } from '../api/auth';

export function useCoreKitAuth() {
  const { coreKit, status, isLoggedIn, isInitialized } = useCoreKit();

  /**
   * Login with Google: Backend verifies Google idToken, issues CipherBox JWT,
   * then we call loginWithJWT on Core Kit.
   */
  async function loginWithGoogle(googleIdToken: string): Promise<void> {
    if (!coreKit) throw new Error('Core Kit not initialized');

    // 1. Send Google idToken to CipherBox backend for verification + JWT issuance
    const { idToken: cipherboxJwt, userId } = await authApi.identityGoogle(googleIdToken);

    // 2. Login to Core Kit with CipherBox JWT
    // Web3Auth custom verifier name must match dashboard config
    await coreKit.loginWithJWT({
      verifier: 'cipherbox-identity', // Single custom verifier for all CipherBox auth
      verifierId: userId,
      idToken: cipherboxJwt,
    });

    // 3. Handle status
    if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
      await coreKit.commitChanges();
    }
    // REQUIRED_SHARE means MFA is enabled but device factor missing
    // Phase 12.4 will handle this -- for now, log a warning
    if (coreKit.status === COREKIT_STATUS.REQUIRED_SHARE) {
      console.warn('[CoreKit] REQUIRED_SHARE status -- MFA challenge needed (not yet implemented)');
    }
  }

  /**
   * Login with Email: Backend handles OTP send/verify, issues CipherBox JWT.
   */
  async function loginWithEmailOtp(email: string, otp: string): Promise<void> {
    if (!coreKit) throw new Error('Core Kit not initialized');

    // 1. Verify OTP with backend, get CipherBox JWT
    const { idToken: cipherboxJwt, userId } = await authApi.identityEmailVerify(email, otp);

    // 2. Login to Core Kit
    await coreKit.loginWithJWT({
      verifier: 'cipherbox-identity',
      verifierId: userId,
      idToken: cipherboxJwt,
    });

    if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
      await coreKit.commitChanges();
    }
    if (coreKit.status === COREKIT_STATUS.REQUIRED_SHARE) {
      console.warn('[CoreKit] REQUIRED_SHARE status -- MFA challenge needed (not yet implemented)');
    }
  }

  /**
   * Get vault keypair from Core Kit's exported TSS key.
   * Replaces the PnP provider.request('private_key') approach.
   */
  async function getVaultKeypair(): Promise<{
    publicKey: Uint8Array;
    privateKey: Uint8Array;
  } | null> {
    if (!coreKit || coreKit.status !== COREKIT_STATUS.LOGGED_IN) return null;

    try {
      const privateKeyHex = await coreKit._UNSAFE_exportTssKey();
      const privKeyHex = privateKeyHex.startsWith('0x') ? privateKeyHex.slice(2) : privateKeyHex;
      const privateKey = hexToBytes(privKeyHex);
      const publicKey = secp256k1.getPublicKey(privateKey, false); // uncompressed (65 bytes)
      return { publicKey, privateKey };
    } catch (err) {
      console.error('[CoreKit] Failed to export TSS key:', err);
      return null;
    }
  }

  /**
   * Get compressed public key hex for backend auth.
   */
  async function getPublicKeyHex(): Promise<string | null> {
    const keypair = await getVaultKeypair();
    if (!keypair) return null;
    const compressed = secp256k1.getPublicKey(keypair.privateKey, true);
    return bytesToHex(compressed);
  }

  /**
   * Logout from Core Kit.
   */
  async function logout(): Promise<void> {
    if (!coreKit) return;
    try {
      if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
        await coreKit.logout();
      }
    } catch (err) {
      console.error('[CoreKit] Logout error:', err);
    }
  }

  return {
    status,
    isLoggedIn,
    isInitialized,
    loginWithGoogle,
    loginWithEmailOtp,
    getVaultKeypair,
    getPublicKeyHex,
    logout,
  };
}

// Utility functions (keep these from the existing hooks.ts)
function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}
```

**Extend `auth.ts` API client** -- Add identity provider endpoints:

Add these methods to the `authApi` object:

```typescript
/** Get CipherBox identity JWT via Google OAuth token */
identityGoogle: async (googleIdToken: string): Promise<IdentityTokenResponse> => {
  const response = await apiClient.post<IdentityTokenResponse>('/auth/identity/google', {
    idToken: googleIdToken,
  });
  return response.data;
},

/** Send email OTP */
identityEmailSendOtp: async (email: string): Promise<{ success: boolean }> => {
  const response = await apiClient.post<{ success: boolean }>('/auth/identity/email/send-otp', {
    email,
  });
  return response.data;
},

/** Verify email OTP and get CipherBox identity JWT */
identityEmailVerify: async (email: string, otp: string): Promise<IdentityTokenResponse> => {
  const response = await apiClient.post<IdentityTokenResponse>('/auth/identity/email/verify-otp', {
    email,
    otp,
  });
  return response.data;
},
```

Add the type:

```typescript
type IdentityTokenResponse = {
  idToken: string;
  userId: string;
  isNewUser: boolean;
};
```

Keep all existing methods in `authApi` (login, refresh, logout, getMethods, etc.) -- they're still used for the CipherBox backend session.
</action>
<verify> - `pnpm --filter web build` compiles without TypeScript errors - `hooks.ts` exports `useCoreKitAuth` with loginWithGoogle, loginWithEmailOtp, getVaultKeypair, getPublicKeyHex, logout - `auth.ts` exports `authApi` with new identity methods alongside existing methods
</verify>
<done>Core Kit auth hooks provide loginWithGoogle, loginWithEmailOtp, getVaultKeypair, logout. API client extended with identity provider endpoints.</done>
</task>

<task type="auto">
  <name>Task 3: Backend publicKey Placeholder Resolution + Rewrite useAuth + Mount CoreKitProvider</name>
  <files>
    apps/api/src/auth/auth.service.ts
    apps/web/src/hooks/useAuth.ts
    apps/web/src/main.tsx
    apps/web/src/stores/auth.store.ts
  </files>
  <action>
**Update `auth.service.ts` -- Handle placeholder publicKey resolution:**

The identity provider endpoints (Plan 01) create new users with placeholder `publicKey = 'pending-core-kit-{userId}'`. When the client completes Core Kit login and calls `/auth/login` with the real publicKey, the existing `login()` method does `findOne({ where: { publicKey: loginDto.publicKey } })` -- this will NOT find the placeholder user, creating a duplicate.

**Fix the `login()` method** in `AuthService`:

After the existing `findOne` by publicKey (line ~42), if no user is found, add a second lookup that extracts the userId from the Web3Auth JWT payload and checks for a placeholder user:

```typescript
async login(loginDto: LoginDto): Promise<LoginServiceResult> {
  // 1. Verify Web3Auth token (unchanged)
  const verificationKey = /* ... existing logic ... */;
  const payload = await this.web3AuthVerifier.verifyIdToken(/* ... */);

  // 2. Find user by publicKey (existing behavior)
  let user = await this.userRepository.findOne({
    where: { publicKey: loginDto.publicKey },
  });

  // 2b. NEW: If not found by publicKey, check for a placeholder user.
  // When a user first authenticates via the CipherBox identity provider,
  // they get a placeholder publicKey ('pending-core-kit-{userId}').
  // After Core Kit login, the client calls /auth/login with the REAL publicKey.
  // We need to find the placeholder user and update their publicKey.
  if (!user) {
    // The Web3Auth JWT's verifierId (in `sub` claim) is our userId
    // Check if a user exists with a placeholder publicKey for this verifierId
    const verifierId = payload.verifierId || payload.sub;
    if (verifierId) {
      const placeholderUser = await this.userRepository.findOne({
        where: { publicKey: `pending-core-kit-${verifierId}` },
      });
      if (placeholderUser) {
        // Update the placeholder publicKey to the real one
        placeholderUser.publicKey = loginDto.publicKey;
        user = await this.userRepository.save(placeholderUser);
      }
    }
  }

  // ... rest of existing login logic (create if still not found, etc.) ...
}
```

This ensures that:

- First identity login (Plan 01): User created with placeholder publicKey, gets CipherBox JWT
- Core Kit login: Client gets real publicKey from `_UNSAFE_exportTssKey()`
- Backend login: `/auth/login` finds the placeholder user, updates publicKey, returns access token
- Subsequent logins: Direct publicKey lookup works (placeholder is gone)

**Important:** The `coreKit.authenticateUser()` JWT contains `verifierId` in its payload which matches the `userId` we set as `verifierId` in `loginWithJWT()`. The existing `Web3AuthVerifierService.verifyIdToken()` will verify this JWT against `https://api-auth.web3auth.io/jwks` (same JWKS endpoint as PnP). This means backward compatibility is maintained.

**Rewrite `useAuth.ts`** to use Core Kit instead of PnP:

The overall flow changes from:

- OLD: connect() opens Web3Auth modal -> gets idToken from Web3Auth -> sends to backend -> backend verifies with Web3Auth JWKS
- NEW: User chooses Google/Email on our UI -> backend verifies credentials -> backend issues CipherBox JWT -> client calls loginWithJWT() -> after Core Kit login, get keypair + register with backend

Key changes:

1. Replace `useAuthFlow()` import with `useCoreKitAuth()` from the new hooks
2. The `login` function now takes a parameter indicating the method and credentials (it will be called from the new Login UI in Plan 04). For now, create two entry points:
   - `loginWithGoogle(googleIdToken: string)` -- calls `useCoreKitAuth().loginWithGoogle()`, then does backend auth (get publicKey, call existing `authApi.login()` to get access token + refresh token cookie)
   - `loginWithEmail(email: string, otp: string)` -- same pattern with email OTP

3. **CRITICAL**: After Core Kit login succeeds, we need to ALSO authenticate with the CipherBox backend (the existing `/auth/login` endpoint) to get the access token and refresh cookie. The flow is:
   - Core Kit login (via loginWithJWT) -> success -> export TSS key -> derive publicKey
   - Call `coreKit.authenticateUser()` to get a Web3Auth-issued idToken
   - Call `authApi.login({ idToken: web3authJwt, publicKey, loginType: 'social' })` -> get access token + refresh cookie
   - The backend will find the placeholder user (via the fix above) and update publicKey

4. **Session restoration**: On mount, if Core Kit `status === LOGGED_IN` (session restored from localStorage), skip the login flow and go straight to getting the keypair + refreshing backend token.

5. **Vault initialization**: Keep the `initializeOrLoadVault` logic, but get the keypair from `useCoreKitAuth().getVaultKeypair()` instead of `getKeypairForVault(provider)`.

6. **Logout**: Call `useCoreKitAuth().logout()` in addition to backend logout and state clearing.

7. **Remove external wallet handling** from this hook for now. External wallets will be handled via SIWE in Phase 12.3. The ADR-001 signature derivation code remains in the codebase but is unused. Remove the `isExternalWallet`, `deriveKeypairForExternalWallet` branches from the login flow. Keep the store fields so the auth store interface doesn't break other consumers.

8. **Remove E2E mode handling** -- E2E tests will need to be updated for Core Kit. Add a TODO comment: `// TODO: Restore E2E test support for Core Kit auth (Plan 05, Task 3)`

**Update `auth.store.ts`**:

- Keep the existing interface (derivedKeypair, isExternalWallet, etc.) for backward compat
- No structural changes needed -- the store is just state management

**Update `main.tsx`**:

- Import `CoreKitProvider` from `./lib/web3auth/core-kit-provider`
- Replace `Web3AuthProviderWrapper` with `CoreKitProvider` in the render tree
- Remove `WagmiProvider` (it's from PnP's wagmi integration, not needed with Core Kit)
- Keep `QueryClientProvider` and `StrictMode`
- The PnP `Web3AuthProviderWrapper` can stay in the codebase (unused) until Plan 05 cleanup

New render tree:

```tsx
<StrictMode>
  <CoreKitProvider>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </CoreKitProvider>
</StrictMode>
```

**IMPORTANT on `coreKit.authenticateUser()`**: After `loginWithJWT()`, Core Kit provides `authenticateUser()` which returns a Web3Auth-signed JWT. This JWT can be verified against `https://api-auth.web3auth.io/jwks` (same as the current PnP flow). This means the existing backend `/auth/login` + `Web3AuthVerifierService.verifyIdToken()` can work UNCHANGED (except for the placeholder resolution fix above). The flow:

1. Call CipherBox identity endpoint -> get CipherBox JWT
2. Call `coreKit.loginWithJWT()` -> Core Kit login
3. Call `coreKit.authenticateUser()` -> get Web3Auth JWT
4. Get publicKey via `_UNSAFE_exportTssKey()`
5. Call `authApi.login({ idToken: web3authJwt, publicKey, loginType: 'social' })` -> get access token + refresh cookie
6. Backend resolves placeholder user (if new) or finds existing user by publicKey

This way the backend auth layer stays unchanged for now. The backend still verifies Web3Auth JWTs, but the CLIENT is the one that decided how the user authenticated (via CipherBox identity provider).
</action>
<verify> - `pnpm --filter api build` compiles without errors (backend change) - `pnpm --filter web build` compiles without errors - `main.tsx` uses `CoreKitProvider` instead of `Web3AuthProviderWrapper` - `useAuth()` exports `loginWithGoogle`, `loginWithEmail`, `logout`, `isLoading`, `isAuthenticated` - Start both API and web: `pnpm --filter api dev` and `pnpm --filter web dev` - App loads at http://localhost:5173 without crashing - Core Kit initializes (check browser console for `[CoreKit]` log messages, no errors) - If Core Kit init fails, error is caught and displayed (not a white screen) - `pnpm --filter api test` passes (existing backend tests still pass)
</verify>
<done>useAuth hook rewritten for Core Kit. CoreKitProvider mounted in app. Login flow uses loginWithJWT() with CipherBox identity JWTs. Backend auth service handles placeholder-to-real publicKey transition. Session restoration works via Core Kit's built-in session. Backend auth preserved via coreKit.authenticateUser().</done>
</task>

</tasks>

<verification>
1. `pnpm --filter web build` and `pnpm --filter api build` both succeed
2. App loads and Core Kit initializes (console shows status transitions)
3. `loginWithGoogle()` and `loginWithEmail()` functions exist and can be called (UI wiring is Plan 04)
4. Session restoration: if a Core Kit session exists in localStorage, app detects LOGGED_IN status on load
5. Logout clears both Core Kit session and backend tokens
6. Backend `/auth/login` correctly resolves placeholder publicKey users
7. No regression in backend auth endpoints
</verification>

<success_criteria>

- Core Kit `loginWithJWT()` is called with CipherBox-issued JWTs
- `_UNSAFE_exportTssKey()` provides private key for vault ECIES operations
- Backend auth still works via `coreKit.authenticateUser()` -> existing `/auth/login` endpoint
- Backend resolves `pending-core-kit-{userId}` placeholder publicKeys to real Core Kit-derived publicKeys
- Session persistence across page reloads works via Core Kit built-in sessions
- REQUIRED_SHARE status handled gracefully (logged, treated as not-logged-in)
- External wallet login removed from active flow (deferred to Phase 12.3 SIWE)
- Web3Auth custom verifier `cipherbox-identity` is configured on dashboard
  </success_criteria>

<output>
After completion, create `.planning/phases/12-multi-factor-authentication/12-03-SUMMARY.md`
</output>
