---
phase: 12-core-kit-identity-provider
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/auth/services/jwt-issuer.service.ts
  - apps/api/src/auth/services/google-oauth.service.ts
  - apps/api/src/auth/services/email-otp.service.ts
  - apps/api/src/auth/controllers/identity.controller.ts
  - apps/api/src/auth/dto/identity.dto.ts
  - apps/api/src/auth/auth.module.ts
autonomous: true

must_haves:
  truths:
    - 'GET /auth/.well-known/jwks.json returns a valid JWKS with RS256 public key'
    - 'POST /auth/identity/google accepts Google idToken, verifies against Google JWKS, finds-or-creates user, returns CipherBox JWT with sub=userId'
    - 'POST /auth/identity/email/send-otp accepts email, stores hashed OTP in Redis with 5min TTL, returns success'
    - 'POST /auth/identity/email/verify-otp accepts email+otp, verifies against Redis, finds-or-creates user, returns CipherBox JWT with sub=userId'
    - 'All CipherBox JWTs contain iss=cipherbox, aud=web3auth, sub=userId, are RS256-signed, and expire in 5 minutes'
  artifacts:
    - path: 'apps/api/src/auth/services/jwt-issuer.service.ts'
      provides: 'RS256 keypair management, JWT signing, JWKS data generation'
      exports: ['JwtIssuerService']
    - path: 'apps/api/src/auth/services/google-oauth.service.ts'
      provides: 'Google idToken verification via Google JWKS'
      exports: ['GoogleOAuthService']
    - path: 'apps/api/src/auth/services/email-otp.service.ts'
      provides: 'OTP generation, hashed storage in Redis, verification'
      exports: ['EmailOtpService']
    - path: 'apps/api/src/auth/controllers/identity.controller.ts'
      provides: 'JWKS endpoint + Google login + email OTP endpoints'
      exports: ['IdentityController']
    - path: 'apps/api/src/auth/dto/identity.dto.ts'
      provides: 'Request/response DTOs for identity endpoints'
      exports: ['GoogleLoginDto', 'SendOtpDto', 'VerifyOtpDto', 'IdentityTokenResponseDto']
  key_links:
    - from: 'apps/api/src/auth/controllers/identity.controller.ts'
      to: 'apps/api/src/auth/services/jwt-issuer.service.ts'
      via: 'dependency injection'
      pattern: 'JwtIssuerService'
    - from: 'apps/api/src/auth/controllers/identity.controller.ts'
      to: 'apps/api/src/auth/services/google-oauth.service.ts'
      via: 'dependency injection'
      pattern: 'GoogleOAuthService'
    - from: 'apps/api/src/auth/services/jwt-issuer.service.ts'
      to: 'GET /auth/.well-known/jwks.json'
      via: 'getJwks() method provides public key data'
      pattern: 'exportJWK|jwks'
---

<objective>
Build the CipherBox backend identity provider: JWKS endpoint, Google OAuth verification, email OTP flow, and JWT issuing with `sub = userId`.

Purpose: CipherBox backend becomes the sole identity provider for Web3Auth. All auth methods (Google, email, future SIWE) flow through CipherBox, which verifies credentials and issues JWTs. Web3Auth's custom verifier validates these JWTs against our JWKS endpoint. This is the API-side foundation for the entire Core Kit migration.

Output: New identity controller with 4 endpoints, 3 new services, and DTOs. Existing auth module updated to register new providers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-multi-factor-authentication/12-CONTEXT.md
@.planning/phases/12-multi-factor-authentication/12-RESEARCH-corekit.md

Key existing files:
@apps/api/src/auth/auth.module.ts
@apps/api/src/auth/auth.service.ts
@apps/api/src/auth/auth.controller.ts
@apps/api/src/auth/services/token.service.ts
@apps/api/src/auth/entities/user.entity.ts
@apps/api/src/auth/entities/auth-method.entity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: JWT Issuer Service + JWKS Endpoint</name>
  <files>
    apps/api/src/auth/services/jwt-issuer.service.ts
    apps/api/src/auth/controllers/identity.controller.ts
    apps/api/src/auth/dto/identity.dto.ts
  </files>
  <action>
Create `JwtIssuerService` that manages an RS256 keypair for signing CipherBox identity JWTs:

1. **Keypair management**: On module init, generate an RSA keypair (2048-bit) using `jose.generateKeyPair('RS256')`. Store in memory. In production, the private key should come from env var `IDENTITY_JWT_PRIVATE_KEY` (PEM format). If env var is not set, generate ephemeral keypair (suitable for dev/staging). Use a fixed `kid` like `"cipherbox-identity-1"`.

2. **signIdentityJwt(userId: string)**: Signs a JWT with:
   - `alg: 'RS256'`
   - `kid: 'cipherbox-identity-1'`
   - `iss: 'cipherbox'`
   - `aud: 'web3auth'`
   - `sub: userId` (the CipherBox internal user UUID)
   - `iat: now`
   - `exp: now + 5 minutes`
     Use `jose.SignJWT` (already in deps).

3. **getJwksData()**: Returns the JWKS JSON object containing the RS256 public key, using `jose.exportJWK()`. Include the `kid`, `alg`, and `use: 'sig'` fields.

Create `IdentityController` at path prefix `auth`:

- `GET /auth/.well-known/jwks.json` -- public, no auth guard. Returns JWKS from `JwtIssuerService.getJwksData()`. Set `Cache-Control: public, max-age=3600`.

Create `IdentityTokenResponseDto`:

- `idToken: string` (the CipherBox-signed JWT for Web3Auth)
- `userId: string`
- `isNewUser: boolean`

**Important**: Use `jose` library (already installed v6.1.3) for ALL JWT operations in this service. Do NOT use `@nestjs/jwt` -- that's for the internal access tokens. The identity JWTs are a separate concern with different signing keys and audience.
</action>
<verify> - `pnpm --filter api build` compiles without errors - Start API: `pnpm --filter api dev`, then `curl http://localhost:3000/auth/.well-known/jwks.json` returns valid JWKS with `keys` array containing one RS256 key with `kid`, `alg`, `use` fields - Manually verify the returned JWK has `kty: "RSA"`, `alg: "RS256"`, `use: "sig"`
</verify>
<done>JWKS endpoint returns valid RS256 public key. JwtIssuerService can sign JWTs with sub=userId, iss=cipherbox, aud=web3auth.</done>
</task>

<task type="auto">
  <name>Task 2: Google OAuth + Email OTP + Identity Endpoints</name>
  <files>
    apps/api/src/auth/services/google-oauth.service.ts
    apps/api/src/auth/services/email-otp.service.ts
    apps/api/src/auth/controllers/identity.controller.ts
    apps/api/src/auth/dto/identity.dto.ts
    apps/api/src/auth/auth.module.ts
  </files>
  <action>
**GoogleOAuthService**:
- `verifyGoogleToken(idToken: string)`: Verify Google idToken using `jose.createRemoteJWKSet` against `https://www.googleapis.com/oauth2/v3/certs`. Extract and return `{ email: string, sub: string, name?: string }`. Throw `UnauthorizedException` if verification fails. Cache the JWKS client (same pattern as existing `Web3AuthVerifierService`).

**EmailOtpService**:

- Inject Redis client (the API already uses BullMQ which has Redis -- inject the existing Redis connection via `@nestjs/bullmq` or use `ioredis` directly from the existing config).
- `sendOtp(email: string)`: Generate 6-digit OTP, hash with `argon2.hash()`, store in Redis with key `otp:{email}` and TTL of 300s (5 min). Also store attempt count at `otp-attempts:{email}` with TTL 900s, max 5 attempts per 15 min. Return void (in a real system, send email -- for now, log the OTP in dev mode only: `if (process.env.NODE_ENV !== 'production') console.log('DEV OTP:', otp)`).
- `verifyOtp(email: string, otp: string)`: Retrieve hash from Redis `otp:{email}`, verify with `argon2.verify()`. Delete key on success. Throw `UnauthorizedException` on mismatch or missing. Increment and check attempt counter.

**Identity Controller endpoints** (add to the controller created in Task 1):

- `POST /auth/identity/google` -- Body: `GoogleLoginDto { idToken: string }`. Flow: verify Google token -> find-or-create user by email (using existing User + AuthMethod entities) -> sign CipherBox JWT -> return `IdentityTokenResponseDto`.
- `POST /auth/identity/email/send-otp` -- Body: `SendOtpDto { email: string }`. Flow: validate email format -> generate and store OTP -> return `{ success: true }`.
- `POST /auth/identity/email/verify-otp` -- Body: `VerifyOtpDto { email: string, otp: string }`. Flow: verify OTP -> find-or-create user by email -> sign CipherBox JWT -> return `IdentityTokenResponseDto`.

**User find-or-create logic**: For identity provider flow, look up user by email in `AuthMethod` table (type='google' or 'email_passwordless', identifier=email). If found, use that user. If not, create new User (with a placeholder publicKey -- it will be updated on first Core Kit login when we know the actual MPC-derived publicKey) and AuthMethod entry. The `publicKey` placeholder should be `'pending-core-kit-{userId}'` to make it obvious this is not a real key.

**DTOs**: Create `GoogleLoginDto`, `SendOtpDto`, `VerifyOtpDto` with class-validator decorators (`@IsString`, `@IsEmail`, `@Length`).

**Auth Module**: Register `JwtIssuerService`, `GoogleOAuthService`, `EmailOtpService`, and `IdentityController` in `auth.module.ts`. Add to providers and controllers arrays.

**Rate limiting**: Apply `@Throttle()` decorator to OTP send endpoint (max 5 requests per 15 minutes per IP). The API already has `@nestjs/throttler` installed.
</action>
<verify> - `pnpm --filter api build` compiles without errors - `pnpm --filter api test` passes (existing tests still pass) - Start API and test Google endpoint: `curl -X POST http://localhost:3000/auth/identity/google -H 'Content-Type: application/json' -d '{"idToken":"invalid"}'` returns 401 (confirming endpoint exists and validates) - Test OTP send: `curl -X POST http://localhost:3000/auth/identity/email/send-otp -H 'Content-Type: application/json' -d '{"email":"test@example.com"}'` returns 200 with `{"success":true}` (check API logs for DEV OTP) - Test OTP verify with correct code from logs: returns 200 with `idToken` and `userId` fields
</verify>
<done>
All 4 identity endpoints functional: JWKS returns RS256 public key, Google login verifies idToken and returns CipherBox JWT, email OTP send/verify flow works end-to-end. CipherBox JWTs contain iss=cipherbox, aud=web3auth, sub=userId.
</done>
</task>

</tasks>

<verification>
1. `curl http://localhost:3000/auth/.well-known/jwks.json` returns valid JWKS
2. Google login endpoint rejects invalid tokens with 401
3. Email OTP flow: send-otp -> verify-otp produces valid CipherBox JWT
4. Decode any returned JWT and verify: `iss=cipherbox`, `aud=web3auth`, `sub` is a UUID, `alg=RS256`
5. Existing auth endpoints (`/auth/login`, `/auth/refresh`, `/auth/logout`) still work unchanged
6. `pnpm --filter api build && pnpm --filter api test` both pass
</verification>

<success_criteria>

- JWKS endpoint serves RS256 public key that Web3Auth custom verifier can validate against
- Google OAuth verification produces CipherBox JWT with sub=userId
- Email OTP send + verify produces CipherBox JWT with sub=userId
- All JWTs are RS256-signed with iss=cipherbox, aud=web3auth
- Existing PnP auth flow is untouched (backward compatible)
  </success_criteria>

<output>
After completion, create `.planning/phases/12-multi-factor-authentication/12-01-SUMMARY.md`
</output>
