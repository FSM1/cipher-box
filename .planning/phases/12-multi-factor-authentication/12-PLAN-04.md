---
phase: 12-core-kit-identity-provider
plan: 04
type: execute
wave: 3
depends_on: ['12-03']
files_modified:
  - apps/web/src/routes/Login.tsx
  - apps/web/src/components/auth/AuthButton.tsx
  - apps/web/src/components/auth/GoogleLoginButton.tsx
  - apps/web/src/components/auth/EmailLoginForm.tsx
  - apps/web/src/components/auth/index.ts
  - apps/web/src/App.css
autonomous: false

must_haves:
  truths:
    - 'User sees CipherBox-branded login page with Google OAuth button and email input (not Web3Auth modal)'
    - 'Clicking Google button initiates Google OAuth popup, on success triggers Core Kit login'
    - 'User can enter email, receive OTP, enter OTP, and complete login via Core Kit'
    - 'Loading states shown during each step (Google auth, OTP send, OTP verify, Core Kit login)'
    - 'Error states shown for invalid OTP, Google popup blocked, network errors'
  artifacts:
    - path: 'apps/web/src/routes/Login.tsx'
      provides: 'Updated login page with custom auth UI instead of [CONNECT] button'
    - path: 'apps/web/src/components/auth/GoogleLoginButton.tsx'
      provides: 'Google OAuth button using GIS library'
      exports: ['GoogleLoginButton']
    - path: 'apps/web/src/components/auth/EmailLoginForm.tsx'
      provides: 'Email + OTP input form with send/verify flow'
      exports: ['EmailLoginForm']
  key_links:
    - from: 'apps/web/src/components/auth/GoogleLoginButton.tsx'
      to: 'apps/web/src/hooks/useAuth.ts'
      via: 'loginWithGoogle() call'
      pattern: 'loginWithGoogle'
    - from: 'apps/web/src/components/auth/EmailLoginForm.tsx'
      to: 'apps/web/src/lib/api/auth.ts'
      via: 'authApi.identityEmailSendOtp + useAuth.loginWithEmail'
      pattern: 'identityEmailSendOtp|loginWithEmail'
    - from: 'apps/web/src/routes/Login.tsx'
      to: 'apps/web/src/components/auth/GoogleLoginButton.tsx'
      via: 'renders GoogleLoginButton and EmailLoginForm'
      pattern: 'GoogleLoginButton|EmailLoginForm'
---

<objective>
Build the CipherBox-branded custom login UI to replace the Web3Auth modal. Users see Google OAuth button and email OTP input on a CipherBox-branded page.

Purpose: Success criteria #1 and #2 require users to log in through CipherBox-branded UI, not the Web3Auth modal popup. This plan creates the Google OAuth button (which opens a Google popup, NOT the Web3Auth modal), the email OTP form, and integrates both with the Core Kit auth flow from Plan 03.

Output: Updated login page with two auth methods, loading/error states, terminal aesthetic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-multi-factor-authentication/12-CONTEXT.md
@.planning/phases/12-multi-factor-authentication/12-03-SUMMARY.md

Key existing files:
@apps/web/src/routes/Login.tsx
@apps/web/src/components/auth/AuthButton.tsx
@apps/web/src/components/auth/index.ts
@apps/web/src/hooks/useAuth.ts
@apps/web/src/App.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Google OAuth Button + Email OTP Form Components</name>
  <files>
    apps/web/src/components/auth/GoogleLoginButton.tsx
    apps/web/src/components/auth/EmailLoginForm.tsx
    apps/web/src/components/auth/index.ts
    apps/web/src/App.css
  </files>
  <action>
**GoogleLoginButton.tsx** -- Use Google Identity Services (GIS) library:

Use the GIS library (`google.accounts.id`) to get a Google idToken via popup. This avoids Firebase (no bundle bloat) and avoids building a full OAuth redirect flow.

**Implementation steps:**

1. **Load the GIS script dynamically** on component mount:

   ```typescript
   useEffect(() => {
     const script = document.createElement('script');
     script.src = 'https://accounts.google.com/gsi/client';
     script.async = true;
     script.onload = () => setGisLoaded(true);
     document.body.appendChild(script);
     return () => {
       document.body.removeChild(script);
     };
   }, []);
   ```

2. **Initialize GIS** once the script loads:

   ```typescript
   useEffect(() => {
     if (!gisLoaded) return;
     const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;
     if (!clientId) {
       setError('Google OAuth not configured');
       return;
     }
     google.accounts.id.initialize({
       client_id: clientId,
       callback: handleCredentialResponse,
       auto_select: false,
     });
     setReady(true);
   }, [gisLoaded]);
   ```

3. **On button click**, trigger the One Tap or popup flow:

   ```typescript
   function handleClick() {
     setLoading(true);
     setError(null);
     google.accounts.id.prompt((notification) => {
       if (notification.isNotDisplayed() || notification.isSkippedMoment()) {
         // Fallback: GIS prompt was blocked or dismissed
         // This can happen if third-party cookies are blocked
         setError('Google popup was blocked. Please allow popups for this site.');
         setLoading(false);
       }
     });
   }
   ```

4. **Callback** receives the Google credential (idToken):

   ```typescript
   async function handleCredentialResponse(response: { credential: string }) {
     try {
       await onLogin(response.credential);
     } catch (err) {
       setError(err instanceof Error ? err.message : 'Google login failed');
     } finally {
       setLoading(false);
     }
   }
   ```

5. **Env var prerequisite:** `VITE_GOOGLE_CLIENT_ID` must be set to a Google Cloud OAuth 2.0 Client ID. If not set, the button renders in a disabled state with text "[GOOGLE - NOT CONFIGURED]".

6. **TypeScript types** for GIS: Add a type declaration at the top of the file or in a `.d.ts` file:

   ```typescript
   declare const google: {
     accounts: {
       id: {
         initialize: (config: {
           client_id: string;
           callback: (response: { credential: string }) => void;
           auto_select: boolean;
         }) => void;
         prompt: (
           momentListener?: (notification: {
             isNotDisplayed: () => boolean;
             isSkippedMoment: () => boolean;
           }) => void
         ) => void;
       };
     };
   };
   ```

**Component interface:**

```tsx
interface GoogleLoginButtonProps {
  onLogin: (googleIdToken: string) => Promise<void>;
  disabled?: boolean;
}

export function GoogleLoginButton({ onLogin, disabled }: GoogleLoginButtonProps) {
  // State: idle | loading | error
  // Load GIS script dynamically on mount
  // On click/callback: call onLogin(credential)
  // Show loading spinner during login
  // Show error if popup blocked or auth failed
}
```

Style with terminal aesthetic: green border, monospace font, `[GOOGLE]` label. On hover: brighter green. Disabled state: dimmed.

**EmailLoginForm.tsx**:

Two-step form:

1. **Step 1**: Email input + `[SEND OTP]` button
   - On submit: call `authApi.identityEmailSendOtp(email)`
   - Show loading state during send
   - On success: transition to step 2
   - On error: show error message

2. **Step 2**: OTP input (6 digits) + `[VERIFY]` button + `[RESEND]` link
   - On submit: call `onLogin(email, otp)` (which triggers `useAuth().loginWithEmail()`)
   - Auto-focus OTP input
   - Show loading state during verification
   - On error: show "invalid code" message, allow retry
   - Resend: throttle to once per 60s, show countdown

```tsx
interface EmailLoginFormProps {
  onLogin: (email: string, otp: string) => Promise<void>;
  disabled?: boolean;
}

export function EmailLoginForm({ onLogin, disabled }: EmailLoginFormProps) {
  // State: 'email' | 'otp'
  // email step: input + send button
  // otp step: 6-digit input + verify button + resend link
}
```

Style: terminal aesthetic inputs. Green border/text on black. Monospace. Input placeholder text in dim green.

**Update `index.ts`**: Export new components.

**CSS additions** in `App.css` (or create a dedicated auth CSS module):

- `.login-methods` container for the two auth options
- `.login-divider` for "// or" separator between Google and email
- `.google-login-btn` styled like the terminal aesthetic
- `.email-login-form` with step transitions
- `.otp-input` styled for 6-digit code entry
- `.login-error` for error messages (red text, monospace)
- `.login-loading` for loading spinners (blinking cursor or "processing..." text)

All styles must maintain the existing terminal/CRT aesthetic (green-on-black, monospace, subtle glow effects). Reference existing CSS classes in `App.css` for consistency.

**Accessibility**: All form inputs must have associated labels (visible or sr-only). Buttons must have focus-visible outlines. Error messages must be in an aria-live region.
</action>
<verify> - `pnpm --filter web build` compiles without errors - Components exported from `apps/web/src/components/auth/index.ts` - GoogleLoginButton renders without errors when mounted (even if Google client ID not set -- should show disabled state) - EmailLoginForm renders email input step, typing email and clicking send transitions to OTP step (mocked API)
</verify>
<done>Google OAuth button (using GIS library) and email OTP form components created with terminal aesthetic. Both accept onLogin callbacks. Loading and error states handled. Accessible with proper ARIA attributes.</done>
</task>

<task type="auto">
  <name>Task 2: Update Login Page to Use Custom Auth UI</name>
  <files>
    apps/web/src/routes/Login.tsx
    apps/web/src/components/auth/AuthButton.tsx
  </files>
  <action>
**Update Login.tsx**:

Replace the `<AuthButton>` (which opened the Web3Auth modal) with the new custom login UI:

```tsx
<div className="login-panel">
  <h1>CIPHERBOX</h1>
  <p className="tagline">zero-knowledge encrypted storage</p>
  <p className="login-description">your files, encrypted on your device. we never see your data.</p>

  <div className="login-methods">
    <GoogleLoginButton onLogin={handleGoogleLogin} disabled={isLoading || isApiDown} />

    <div className="login-divider">
      <span>{'// or'}</span>
    </div>

    <EmailLoginForm onLogin={handleEmailLogin} disabled={isLoading || isApiDown} />
  </div>

  {loginError && (
    <div className="login-error" role="alert" aria-live="polite">
      {loginError}
    </div>
  )}
</div>
```

Where:

- `handleGoogleLogin = async (googleIdToken: string) => { await loginWithGoogle(googleIdToken); }`
- `handleEmailLogin = async (email: string, otp: string) => { await loginWithEmail(email, otp); }`
- Both wrapped in try/catch with error state management
- Use `useAuth()` hook to get `loginWithGoogle`, `loginWithEmail`, `isLoading`, `isAuthenticated`

Keep the existing:

- `MatrixBackground` component
- `StagingBanner` component
- Health check for API down detection
- Footer with links and `StatusIndicator`
- Redirect to /files when `isAuthenticated`

**AuthButton.tsx**: Keep the file but it's no longer used from Login.tsx. Add a deprecation comment: `/** @deprecated Replaced by GoogleLoginButton + EmailLoginForm in Phase 12 */`. It may still be imported elsewhere -- check for other imports. If only Login.tsx imported it, mark as deprecated but don't delete yet (Plan 05 cleanup).

**Loading states during login**: Show `"authenticating with google..."` or `"verifying code..."` or `"initializing encryption keys..."` as the multi-step login progresses. These replace the generic "connecting..." text from the old AuthButton.
</action>
<verify> - `pnpm --filter web build` compiles without errors - Start web and API: `pnpm --filter api dev` and `pnpm --filter web dev` - Navigate to http://localhost:5173 -- see CipherBox branded login page - Google button is visible (may not work without VITE_GOOGLE_CLIENT_ID set -- verify it renders) - Email input is visible, can type email, send button is clickable - API down state: if API is not running, buttons show disabled state - No Web3Auth modal popup appears anywhere
</verify>
<done>Login page shows CipherBox-branded UI with Google and email auth options. No Web3Auth modal. Terminal aesthetic maintained.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Custom CipherBox-branded login page with Google OAuth button (using GIS library) and email OTP form, replacing the Web3Auth modal popup. Full auth flow: Google/email -> CipherBox backend -> Core Kit loginWithJWT -> vault access.</what-built>
  <how-to-verify>
1. Start API and web: `pnpm --filter api dev` and `pnpm --filter web dev`
2. Navigate to http://localhost:5173
3. Verify login page shows: CIPHERBOX heading, tagline, Google button, "// or" divider, email input
4. Verify terminal aesthetic: green-on-black, monospace, matrix background
5. Test email flow: enter a test email, click send OTP, check API console for DEV OTP code, enter OTP, verify login completes
6. After login: verify redirect to /files, vault loads, files are accessible
7. Test logout: click logout, verify return to login page
8. Test session persistence: after login, refresh the page, verify still logged in
9. (Optional) Test Google: requires VITE_GOOGLE_CLIENT_ID env var -- skip if not configured
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Login page shows Google button and email OTP form (not Web3Auth modal)
2. Email OTP flow works end-to-end: send -> verify -> Core Kit login -> vault access
3. Google OAuth flow works (if configured) or gracefully shows not-configured state
4. Terminal aesthetic maintained (green-on-black, monospace, matrix background)
5. Loading/error states displayed appropriately
6. Session persistence works across page refresh
7. `pnpm --filter web build` succeeds
</verification>

<success_criteria>

- User can log in via Google OAuth through CipherBox-branded UI (Success Criterion #1)
- User can log in via email through CipherBox-branded UI (Success Criterion #2)
- No Web3Auth modal appears during login
- Login page maintains terminal/CRT aesthetic
- Error states are user-friendly and accessible
  </success_criteria>

<output>
After completion, create `.planning/phases/12-multi-factor-authentication/12-04-SUMMARY.md`
</output>
