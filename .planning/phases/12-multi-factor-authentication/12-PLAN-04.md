---
phase: 12-core-kit-identity-provider
plan: 04
type: execute
wave: 3
depends_on: ['12-03']
files_modified:
  - apps/web/src/routes/Login.tsx
  - apps/web/src/components/auth/AuthButton.tsx
  - apps/web/src/components/auth/GoogleLoginButton.tsx
  - apps/web/src/components/auth/EmailLoginForm.tsx
  - apps/web/src/components/auth/index.ts
  - apps/web/src/App.css
autonomous: false

must_haves:
  truths:
    - 'User sees CipherBox-branded login page with Google OAuth button and email input (not Web3Auth modal)'
    - 'Clicking Google button initiates Google OAuth popup, on success triggers Core Kit login'
    - 'User can enter email, receive OTP, enter OTP, and complete login via Core Kit'
    - 'Loading states shown during each step (Google auth, OTP send, OTP verify, Core Kit login)'
    - 'Error states shown for invalid OTP, Google popup blocked, network errors'
  artifacts:
    - path: 'apps/web/src/routes/Login.tsx'
      provides: 'Updated login page with custom auth UI instead of [CONNECT] button'
    - path: 'apps/web/src/components/auth/GoogleLoginButton.tsx'
      provides: 'Google OAuth button that triggers popup and backend verification'
      exports: ['GoogleLoginButton']
    - path: 'apps/web/src/components/auth/EmailLoginForm.tsx'
      provides: 'Email + OTP input form with send/verify flow'
      exports: ['EmailLoginForm']
  key_links:
    - from: 'apps/web/src/components/auth/GoogleLoginButton.tsx'
      to: 'apps/web/src/hooks/useAuth.ts'
      via: 'loginWithGoogle() call'
      pattern: 'loginWithGoogle'
    - from: 'apps/web/src/components/auth/EmailLoginForm.tsx'
      to: 'apps/web/src/lib/api/auth.ts'
      via: 'authApi.identityEmailSendOtp + useAuth.loginWithEmail'
      pattern: 'identityEmailSendOtp|loginWithEmail'
    - from: 'apps/web/src/routes/Login.tsx'
      to: 'apps/web/src/components/auth/GoogleLoginButton.tsx'
      via: 'renders GoogleLoginButton and EmailLoginForm'
      pattern: 'GoogleLoginButton|EmailLoginForm'
---

<objective>
Build the CipherBox-branded custom login UI to replace the Web3Auth modal. Users see Google OAuth button and email OTP input on a CipherBox-branded page.

Purpose: Success criteria #1 and #2 require users to log in through CipherBox-branded UI, not the Web3Auth modal popup. This plan creates the Google OAuth button (which opens a Google popup, NOT the Web3Auth modal), the email OTP form, and integrates both with the Core Kit auth flow from Plan 03.

Output: Updated login page with two auth methods, loading/error states, terminal aesthetic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-multi-factor-authentication/12-CONTEXT.md
@.planning/phases/12-multi-factor-authentication/12-03-SUMMARY.md

Key existing files:
@apps/web/src/routes/Login.tsx
@apps/web/src/components/auth/AuthButton.tsx
@apps/web/src/components/auth/index.ts
@apps/web/src/hooks/useAuth.ts
@apps/web/src/App.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Google OAuth Button + Email OTP Form Components</name>
  <files>
    apps/web/src/components/auth/GoogleLoginButton.tsx
    apps/web/src/components/auth/EmailLoginForm.tsx
    apps/web/src/components/auth/index.ts
    apps/web/src/App.css
  </files>
  <action>
**GoogleLoginButton.tsx**:

This component handles Google OAuth WITHOUT Firebase. Instead, use Google's OAuth 2.0 popup flow directly:

1. On click, open a popup to Google's OAuth authorization endpoint:

   ```text
   https://accounts.google.com/o/oauth2/v2/auth?
     client_id={VITE_GOOGLE_CLIENT_ID}&
     redirect_uri={window.location.origin}/auth/google/callback&
     response_type=id_token&
     scope=openid email profile&
     nonce={random}&
     prompt=select_account
   ```

2. The popup redirects back to `/auth/google/callback` with the `id_token` in the URL fragment.

3. **Simplification for v1**: Rather than building a full OAuth callback page, use the Google Sign-In for Web "popup" approach. The simplest path that avoids Firebase:
   - Use the Google Identity Services (GIS) library: load `https://accounts.google.com/gsi/client` script dynamically
   - Initialize with `google.accounts.id.initialize({ client_id, callback })`
   - Render button with `google.accounts.id.renderButton()` OR use a custom button that calls `google.accounts.id.prompt()`
   - The callback receives `{ credential: idToken }` -- this is the Google JWT
   - Pass this idToken to `useAuth().loginWithGoogle(idToken)`

4. **Alternative (even simpler)**: Use `google.accounts.oauth2.initTokenClient()` for popup-based OAuth. But for getting an `id_token` specifically, GIS `google.accounts.id` is the standard approach.

5. Add a `VITE_GOOGLE_CLIENT_ID` env var. This is the Google OAuth client ID from Google Cloud Console (NOT the Web3Auth client ID). Document that this needs to be set up.

**Implementation**:

```tsx
interface GoogleLoginButtonProps {
  onLogin: (googleIdToken: string) => Promise<void>;
  disabled?: boolean;
}

export function GoogleLoginButton({ onLogin, disabled }: GoogleLoginButtonProps) {
  // State: idle | loading | error
  // Load GIS script dynamically on mount
  // On click/callback: call onLogin(credential)
  // Show loading spinner during login
  // Show error if popup blocked or auth failed
}
```

Style with terminal aesthetic: green border, monospace font, `[GOOGLE]` label. On hover: brighter green. Disabled state: dimmed.

**EmailLoginForm.tsx**:

Two-step form:

1. **Step 1**: Email input + `[SEND OTP]` button
   - On submit: call `authApi.identityEmailSendOtp(email)`
   - Show loading state during send
   - On success: transition to step 2
   - On error: show error message

2. **Step 2**: OTP input (6 digits) + `[VERIFY]` button + `[RESEND]` link
   - On submit: call `onLogin(email, otp)` (which triggers `useAuth().loginWithEmail()`)
   - Auto-focus OTP input
   - Show loading state during verification
   - On error: show "invalid code" message, allow retry
   - Resend: throttle to once per 60s, show countdown

```tsx
interface EmailLoginFormProps {
  onLogin: (email: string, otp: string) => Promise<void>;
  disabled?: boolean;
}

export function EmailLoginForm({ onLogin, disabled }: EmailLoginFormProps) {
  // State: 'email' | 'otp'
  // email step: input + send button
  // otp step: 6-digit input + verify button + resend link
}
```

Style: terminal aesthetic inputs. Green border/text on black. Monospace. Input placeholder text in dim green.

**Update `index.ts`**: Export new components.

**CSS additions** in `App.css` (or create a dedicated auth CSS module):

- `.login-methods` container for the two auth options
- `.login-divider` for "// or" separator between Google and email
- `.google-login-btn` styled like the terminal aesthetic
- `.email-login-form` with step transitions
- `.otp-input` styled for 6-digit code entry
- `.login-error` for error messages (red text, monospace)
- `.login-loading` for loading spinners (blinking cursor or "processing..." text)

All styles must maintain the existing terminal/CRT aesthetic (green-on-black, monospace, subtle glow effects). Reference existing CSS classes in `App.css` for consistency.

**Accessibility**: All form inputs must have associated labels (visible or sr-only). Buttons must have focus-visible outlines. Error messages must be in an aria-live region.
</action>
<verify> - `pnpm --filter web build` compiles without errors - Components exported from `apps/web/src/components/auth/index.ts` - GoogleLoginButton renders without errors when mounted (even if Google client ID not set -- should show disabled state) - EmailLoginForm renders email input step, typing email and clicking send transitions to OTP step (mocked API)
</verify>
<done>Google OAuth button and email OTP form components created with terminal aesthetic. Both accept onLogin callbacks. Loading and error states handled. Accessible with proper ARIA attributes.</done>
</task>

<task type="auto">
  <name>Task 2: Update Login Page to Use Custom Auth UI</name>
  <files>
    apps/web/src/routes/Login.tsx
    apps/web/src/components/auth/AuthButton.tsx
  </files>
  <action>
**Update Login.tsx**:

Replace the `<AuthButton>` (which opened the Web3Auth modal) with the new custom login UI:

```tsx
<div className="login-panel">
  <h1>CIPHERBOX</h1>
  <p className="tagline">zero-knowledge encrypted storage</p>
  <p className="login-description">your files, encrypted on your device. we never see your data.</p>

  <div className="login-methods">
    <GoogleLoginButton onLogin={handleGoogleLogin} disabled={isLoading || isApiDown} />

    <div className="login-divider">
      <span>{'// or'}</span>
    </div>

    <EmailLoginForm onLogin={handleEmailLogin} disabled={isLoading || isApiDown} />
  </div>

  {loginError && (
    <div className="login-error" role="alert" aria-live="polite">
      {loginError}
    </div>
  )}
</div>
```

Where:

- `handleGoogleLogin = async (googleIdToken: string) => { await loginWithGoogle(googleIdToken); }`
- `handleEmailLogin = async (email: string, otp: string) => { await loginWithEmail(email, otp); }`
- Both wrapped in try/catch with error state management
- Use `useAuth()` hook to get `loginWithGoogle`, `loginWithEmail`, `isLoading`, `isAuthenticated`

Keep the existing:

- `MatrixBackground` component
- `StagingBanner` component
- Health check for API down detection
- Footer with links and `StatusIndicator`
- Redirect to /files when `isAuthenticated`

**AuthButton.tsx**: Keep the file but it's no longer used from Login.tsx. Add a deprecation comment: `/** @deprecated Replaced by GoogleLoginButton + EmailLoginForm in Phase 12 */`. It may still be imported elsewhere -- check for other imports. If only Login.tsx imported it, mark as deprecated but don't delete yet (Plan 05 cleanup).

**Loading states during login**: Show `"authenticating with google..."` or `"verifying code..."` or `"initializing encryption keys..."` as the multi-step login progresses. These replace the generic "connecting..." text from the old AuthButton.
</action>
<verify> - `pnpm --filter web build` compiles without errors - Start web and API: `pnpm --filter api dev` and `pnpm --filter web dev` - Navigate to http://localhost:5173 -- see CipherBox branded login page - Google button is visible (may not work without VITE_GOOGLE_CLIENT_ID set -- verify it renders) - Email input is visible, can type email, send button is clickable - API down state: if API is not running, buttons show disabled state - No Web3Auth modal popup appears anywhere
</verify>
<done>Login page shows CipherBox-branded UI with Google and email auth options. No Web3Auth modal. Terminal aesthetic maintained.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Custom CipherBox-branded login page with Google OAuth button and email OTP form, replacing the Web3Auth modal popup. Full auth flow: Google/email -> CipherBox backend -> Core Kit loginWithJWT -> vault access.</what-built>
  <how-to-verify>
1. Start API and web: `pnpm --filter api dev` and `pnpm --filter web dev`
2. Navigate to http://localhost:5173
3. Verify login page shows: CIPHERBOX heading, tagline, Google button, "// or" divider, email input
4. Verify terminal aesthetic: green-on-black, monospace, matrix background
5. Test email flow: enter a test email, click send OTP, check API console for DEV OTP code, enter OTP, verify login completes
6. After login: verify redirect to /files, vault loads, files are accessible
7. Test logout: click logout, verify return to login page
8. Test session persistence: after login, refresh the page, verify still logged in
9. (Optional) Test Google: requires VITE_GOOGLE_CLIENT_ID env var -- skip if not configured
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Login page shows Google button and email OTP form (not Web3Auth modal)
2. Email OTP flow works end-to-end: send -> verify -> Core Kit login -> vault access
3. Google OAuth flow works (if configured) or gracefully shows not-configured state
4. Terminal aesthetic maintained (green-on-black, monospace, matrix background)
5. Loading/error states displayed appropriately
6. Session persistence works across page refresh
7. `pnpm --filter web build` succeeds
</verification>

<success_criteria>

- User can log in via Google OAuth through CipherBox-branded UI (Success Criterion #1)
- User can log in via email through CipherBox-branded UI (Success Criterion #2)
- No Web3Auth modal appears during login
- Login page maintains terminal/CRT aesthetic
- Error states are user-friendly and accessible
  </success_criteria>

<output>
After completion, create `.planning/phases/12-multi-factor-authentication/12-04-SUMMARY.md`
</output>
