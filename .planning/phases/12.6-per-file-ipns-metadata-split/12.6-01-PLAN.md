---
phase: 12.6-per-file-ipns-metadata-split
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/file/types.ts
  - packages/crypto/src/file/derive-ipns.ts
  - packages/crypto/src/file/metadata.ts
  - packages/crypto/src/file/index.ts
  - packages/crypto/src/folder/types.ts
  - packages/crypto/src/folder/metadata.ts
  - packages/crypto/src/folder/index.ts
  - packages/crypto/src/index.ts
  - packages/crypto/src/__tests__/file-ipns.test.ts
autonomous: true

must_haves:
  truths:
    - 'deriveFileIpnsKeypair produces deterministic Ed25519 keypair from userPrivateKey + fileId'
    - 'encryptFileMetadata/decryptFileMetadata round-trip correctly with parent folderKey'
    - 'v2 FolderMetadata has FilePointer children (not FileEntry) with fileMetaIpnsName field'
    - 'validateFolderMetadata accepts both v1 and v2 schemas'
  artifacts:
    - path: 'packages/crypto/src/file/types.ts'
      provides: 'FileMetadata, FilePointer, EncryptedFileMetadata types'
      contains: 'FileMetadata'
    - path: 'packages/crypto/src/file/derive-ipns.ts'
      provides: 'deriveFileIpnsKeypair function'
      exports: ['deriveFileIpnsKeypair']
    - path: 'packages/crypto/src/file/metadata.ts'
      provides: 'encryptFileMetadata, decryptFileMetadata functions'
      exports: ['encryptFileMetadata', 'decryptFileMetadata']
    - path: 'packages/crypto/src/folder/types.ts'
      provides: 'v2 FolderMetadata schema with FilePointer'
      contains: 'FilePointer'
    - path: 'packages/crypto/src/__tests__/file-ipns.test.ts'
      provides: 'Unit tests for file IPNS derivation and file metadata encryption'
      min_lines: 60
  key_links:
    - from: 'packages/crypto/src/file/derive-ipns.ts'
      to: 'packages/crypto/src/keys/derive.ts'
      via: 'deriveKey import'
      pattern: 'import.*deriveKey.*from.*keys/derive'
    - from: 'packages/crypto/src/file/metadata.ts'
      to: 'packages/crypto/src/aes'
      via: 'encryptAesGcm/decryptAesGcm imports'
      pattern: 'import.*encryptAesGcm.*from.*aes'
    - from: 'packages/crypto/src/index.ts'
      to: 'packages/crypto/src/file/index.ts'
      via: 'barrel re-export'
      pattern: 'export.*from.*file'
---

<objective>
Create the crypto primitives for per-file IPNS metadata: HKDF-based file IPNS keypair derivation, file metadata types (FileMetadata, FilePointer), encryption/decryption functions, and v2 folder metadata schema.

Purpose: Foundation layer that all other plans depend on. Defines the v2 data model and provides the cryptographic operations for per-file IPNS records.
Output: New `packages/crypto/src/file/` module + updated folder types for v2 + unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-per-file-ipns-metadata-split/12.6-RESEARCH.md

# Key source files to reference

@packages/crypto/src/vault/derive-ipns.ts
@packages/crypto/src/folder/types.ts
@packages/crypto/src/folder/metadata.ts
@packages/crypto/src/folder/index.ts
@packages/crypto/src/index.ts
@packages/crypto/src/keys/derive.ts
@packages/crypto/src/constants.ts
@packages/crypto/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file IPNS module (types, derivation, encryption)</name>
  <files>
    packages/crypto/src/file/types.ts
    packages/crypto/src/file/derive-ipns.ts
    packages/crypto/src/file/metadata.ts
    packages/crypto/src/file/index.ts
  </files>
  <action>
Create `packages/crypto/src/file/` directory with four files:

**types.ts** -- Per-file metadata types:

- `FileMetadata` type: `{ version: 'v1', cid: string, fileKeyEncrypted: string, fileIv: string, size: number, mimeType: string, createdAt: number, modifiedAt: number }`. No `versionHistory` field (Phase 13 adds it later with `?? []` fallback).
- `FilePointer` type: `{ type: 'file', id: string, name: string, fileMetaIpnsName: string, createdAt: number, modifiedAt: number }`. This is the slim reference stored in v2 folder metadata.
- `EncryptedFileMetadata` type: `{ iv: string, data: string }` -- same format as EncryptedFolderMetadata (hex IV + base64 ciphertext).

**derive-ipns.ts** -- HKDF file IPNS keypair derivation:

- Follow `packages/crypto/src/vault/derive-ipns.ts` pattern EXACTLY.
- Same salt: `new TextEncoder().encode('CipherBox-v1')`
- Info string: `new TextEncoder().encode('cipherbox-file-ipns-v1:${fileId}')` -- fileId provides per-file domain separation.
- Export `deriveFileIpnsKeypair(userPrivateKey: Uint8Array, fileId: string): Promise<{ privateKey: Uint8Array; publicKey: Uint8Array; ipnsName: string }>`
- Validate: `userPrivateKey.length !== SECP256K1_PRIVATE_KEY_SIZE` throws CryptoError. `fileId` must be non-empty string (at least 10 chars for UUID).
- Import `deriveKey` from `../keys/derive`, `ed.getPublicKeyAsync` from `@noble/ed25519`, `deriveIpnsName` from `../ipns/derive-name`, `CryptoError` from `../types`, `SECP256K1_PRIVATE_KEY_SIZE` from `../constants`.

**metadata.ts** -- File metadata encryption/decryption:

- Follow `packages/crypto/src/folder/metadata.ts` pattern EXACTLY.
- `encryptFileMetadata(metadata: FileMetadata, folderKey: Uint8Array): Promise<EncryptedFileMetadata>` -- encrypts with parent folder's folderKey (NOT the file's own key). JSON serialize, AES-256-GCM encrypt, return {iv: hex, data: base64}.
- `decryptFileMetadata(encrypted: EncryptedFileMetadata, folderKey: Uint8Array): Promise<FileMetadata>` -- decrypt, JSON parse, validate.
- Include `validateFileMetadata(data: unknown): FileMetadata` runtime validator. Check: version === 'v1', cid is string, fileKeyEncrypted is string, fileIv is string, size is number, mimeType is string, createdAt is number, modifiedAt is number.
- Use same `uint8ArrayToBase64` chunked encoding pattern from folder metadata.ts for large file metadata blobs.

**index.ts** -- barrel exports:

- Export all types from types.ts
- Export `deriveFileIpnsKeypair` from derive-ipns.ts
- Export `encryptFileMetadata`, `decryptFileMetadata` from metadata.ts
  </action>
  <verify>
  Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto build` -- must compile without errors.
  Verify exports: `grep -r "deriveFileIpnsKeypair\|FileMetadata\|FilePointer\|EncryptedFileMetadata\|encryptFileMetadata\|decryptFileMetadata" packages/crypto/src/file/index.ts` shows all expected exports.
  </verify>
  <done>
  Four files created in `packages/crypto/src/file/`. `deriveFileIpnsKeypair` derives deterministic Ed25519 IPNS keypair from userPrivateKey + fileId via HKDF. `encryptFileMetadata`/`decryptFileMetadata` handle AES-256-GCM encryption of file metadata with the parent folder's key. All types exported.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Update folder types for v2 schema + barrel exports + tests</name>
  <files>
    packages/crypto/src/folder/types.ts
    packages/crypto/src/folder/metadata.ts
    packages/crypto/src/folder/index.ts
    packages/crypto/src/index.ts
    packages/crypto/src/__tests__/file-ipns.test.ts
  </files>
  <action>
**folder/types.ts** -- Add v2 types alongside v1 (both must coexist for the validator):

- Keep ALL existing types (`FolderMetadata`, `FolderChild`, `FolderEntry`, `FileEntry`, `EncryptedFolderMetadata`) unchanged.
- Add new types:
  - `FolderMetadataV2 = { version: 'v2'; children: FolderChildV2[] }`
  - `FolderChildV2 = FolderEntry | FilePointer` -- import `FilePointer` from `../file/types`
  - `AnyFolderMetadata = FolderMetadata | FolderMetadataV2` -- union type for validation
- Export all new types.

**folder/metadata.ts** -- Update validator to accept v2:

- Update `validateFolderMetadata` to accept `v1` OR `v2` version field. Return type becomes `FolderMetadata | FolderMetadataV2`.
- For v2 children, accept child.type === 'file' entries that have `fileMetaIpnsName` (FilePointer) instead of `cid` (FileEntry). Both shapes valid.
- Update `encryptFolderMetadata` signature to accept `FolderMetadata | FolderMetadataV2`.
- Update `decryptFolderMetadata` return type to `FolderMetadata | FolderMetadataV2`.
- Add a type guard export: `isV2Metadata(m: FolderMetadata | FolderMetadataV2): m is FolderMetadataV2` that checks `m.version === 'v2'`.

**folder/index.ts** -- Add new type exports:

- Add `FolderMetadataV2`, `FolderChildV2`, `AnyFolderMetadata` to the type exports.
- Add `isV2Metadata` to function exports.
- Keep `FilePointer` exported from `../file` module (don't re-export from folder).

**packages/crypto/src/index.ts** -- Add file module exports:

- Add new export block for file module with `deriveFileIpnsKeypair`, `encryptFileMetadata`, `decryptFileMetadata`, `type FileMetadata`, `type FilePointer`, `type EncryptedFileMetadata` from `'./file'`.
- Add `FolderMetadataV2`, `FolderChildV2`, `AnyFolderMetadata`, `isV2Metadata` to the folder export block.

**\_\_tests\_\_/file-ipns.test.ts** -- Unit tests:

- Test `deriveFileIpnsKeypair`:
  - Same userPrivateKey + same fileId = same keypair (deterministic)
  - Same userPrivateKey + different fileId = different keypair (domain separation)
  - Different userPrivateKey + same fileId = different keypair
  - Invalid key length throws CryptoError
  - Empty/short fileId throws CryptoError
  - Returned ipnsName starts with 'k51' or 'bafzaa'
- Test `encryptFileMetadata` / `decryptFileMetadata`:
  - Round-trip: encrypt then decrypt returns identical FileMetadata
  - Wrong folderKey fails decryption (throws CryptoError)
  - Validate all fields present after decrypt
- Test `validateFolderMetadata` (v2):
  - v2 metadata with FilePointer children validates correctly
  - v2 metadata with FolderEntry children validates correctly
  - v2 metadata with mixed FilePointer + FolderEntry validates correctly
  - `isV2Metadata` type guard returns true for v2, false for v1
    </action>
    <verify>
    Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto test` -- all tests pass.
    Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto build` -- builds clean.
    </verify>
    <done>
    v2 folder types added (FolderMetadataV2, FolderChildV2, AnyFolderMetadata). Folder metadata validator accepts both v1 and v2. File module fully exported from @cipherbox/crypto barrel. All unit tests pass including deterministic derivation, domain separation, encryption round-trip, and v2 validation.
    </done>
    </task>

</tasks>

<verification>

- `pnpm --filter @cipherbox/crypto build` succeeds
- `pnpm --filter @cipherbox/crypto test` all tests pass
- `grep "deriveFileIpnsKeypair" packages/crypto/src/index.ts` shows export
- `grep "FilePointer" packages/crypto/src/file/types.ts` shows type definition
- `grep "FolderMetadataV2" packages/crypto/src/folder/types.ts` shows v2 schema
- `grep "isV2Metadata" packages/crypto/src/folder/metadata.ts` shows type guard

</verification>

<success_criteria>

- @cipherbox/crypto compiles and all tests pass
- `deriveFileIpnsKeypair` is deterministic (same inputs = same outputs) and domain-separated (different fileId = different keypair)
- `encryptFileMetadata`/`decryptFileMetadata` round-trip correctly with parent folderKey
- v2 folder metadata types and validator coexist with v1 without breaking existing code
- All new types and functions exported from package barrel

</success_criteria>

<output>
After completion, create `.planning/phases/12.6-per-file-ipns-metadata-split/12.6-01-SUMMARY.md`
</output>
