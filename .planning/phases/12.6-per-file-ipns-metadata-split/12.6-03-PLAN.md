---
phase: 12.6-per-file-ipns-metadata-split
plan: 03
type: execute
wave: 2
depends_on: ['12.6-01', '12.6-02']
files_modified:
  - apps/web/src/services/file-metadata.service.ts
  - apps/web/src/services/ipns.service.ts
  - apps/web/src/services/folder.service.ts
  - apps/web/src/services/upload.service.ts
  - apps/web/src/services/download.service.ts
  - apps/web/src/services/delete.service.ts
  - apps/web/src/stores/folder.store.ts
  - apps/web/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - 'File upload creates per-file IPNS record and slim FilePointer in folder metadata'
    - 'Content update (re-upload) publishes only the file IPNS record, not the folder'
    - 'File rename publishes only the folder IPNS record, not the file'
    - 'File download resolves per-file IPNS to get CID, then fetches and decrypts'
    - 'Batch upload publishes all file IPNS + folder IPNS via single batch API call'
    - 'File deletion unenrolls file IPNS from TEE republishing'
    - 'Folder loading works with v2 metadata and FilePointer children'
  artifacts:
    - path: 'apps/web/src/services/file-metadata.service.ts'
      provides: 'Per-file IPNS operations: create, resolve, update file metadata'
      exports: ['createFileMetadata', 'resolveFileMetadata', 'updateFileMetadata']
    - path: 'apps/web/src/services/folder.service.ts'
      provides: 'v2 folder operations using FilePointer instead of FileEntry'
      contains: 'FilePointer'
    - path: 'apps/web/src/services/ipns.service.ts'
      provides: 'Batch IPNS publish via publish-batch endpoint'
      contains: 'batchPublishIpnsRecords'
    - path: 'apps/web/src/stores/folder.store.ts'
      provides: 'FolderNode with FolderChildV2 children'
      contains: 'FolderChildV2'
  key_links:
    - from: 'apps/web/src/services/file-metadata.service.ts'
      to: '@cipherbox/crypto'
      via: 'deriveFileIpnsKeypair, encryptFileMetadata, decryptFileMetadata imports'
      pattern: 'import.*deriveFileIpnsKeypair.*from.*@cipherbox/crypto'
    - from: 'apps/web/src/services/folder.service.ts'
      to: 'apps/web/src/services/file-metadata.service.ts'
      via: 'createFileMetadata call in addFileToFolder'
      pattern: 'createFileMetadata'
    - from: 'apps/web/src/services/ipns.service.ts'
      to: 'apps/web/src/api/'
      via: 'generated batch publish API client call'
      pattern: 'ipnsControllerPublishBatch'
    - from: 'apps/web/src/services/download.service.ts'
      to: 'apps/web/src/services/file-metadata.service.ts'
      via: 'resolveFileMetadata call before download'
      pattern: 'resolveFileMetadata'
---

<objective>
Rewrite the frontend service layer to use per-file IPNS metadata (v2 schema). This plan covers ONLY the service files and store types -- NOT the hooks and components that consume them.

Purpose: This is where the architectural change becomes functional. Every file operation now correctly separates content updates from folder updates, unlocking the primary benefit of the split. The hooks and components are updated in Plan 04 to adapt to the new service API signatures.
Output: Updated services, new file-metadata service, updated store types. All file operations use v2 metadata flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.6-per-file-ipns-metadata-split/12.6-RESEARCH.md

# Prior plan summaries (needed for crypto types and API endpoint)

@.planning/phases/12.6-per-file-ipns-metadata-split/12.6-01-SUMMARY.md
@.planning/phases/12.6-per-file-ipns-metadata-split/12.6-02-SUMMARY.md

# Key source files to reference

@apps/web/src/services/folder.service.ts
@apps/web/src/services/upload.service.ts
@apps/web/src/services/download.service.ts
@apps/web/src/services/delete.service.ts
@apps/web/src/services/ipns.service.ts
@apps/web/src/stores/folder.store.ts
@apps/web/src/stores/auth.store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: File metadata service + batch IPNS publish + store types</name>
  <files>
    apps/web/src/services/file-metadata.service.ts
    apps/web/src/services/ipns.service.ts
    apps/web/src/services/index.ts
    apps/web/src/stores/folder.store.ts
  </files>
  <action>
**file-metadata.service.ts** -- New service for per-file IPNS operations:

Create this new file with three core functions:

1. `createFileMetadata(params: { fileId: string, cid: string, fileKeyEncrypted: string, fileIv: string, size: number, mimeType: string, folderKey: Uint8Array, userPrivateKey: Uint8Array, encryptionMode?: 'GCM' | 'CTR' }): Promise<{ fileMetaIpnsName: string, ipnsRecord: { ipnsName: string, recordBase64: string, metadataCid: string, encryptedIpnsPrivateKey?: string, keyEpoch?: number } }>`
   - Derive file IPNS keypair: `deriveFileIpnsKeypair(userPrivateKey, fileId)`.
   - Create FileMetadata object: `{ version: 'v1', cid, fileKeyEncrypted, fileIv, size, mimeType, encryptionMode: encryptionMode ?? 'GCM', createdAt: Date.now(), modifiedAt: Date.now() }`.
   - Encrypt with parent folderKey: `encryptFileMetadata(metadata, folderKey)`.
   - Upload encrypted metadata to IPFS: `addToIpfs(new Blob([JSON.stringify(encrypted)], { type: 'application/json' }))`.
   - Create IPNS record: `createIpnsRecord(ipnsKeypair.privateKey, '/ipfs/' + metadataCid, 1n, 24*60*60*1000)`.
   - Marshal and base64 encode the record.
   - TEE enrollment: encrypt IPNS private key with TEE public key (same pattern as createFolder in folder.service.ts -- check useAuthStore.getState().teeKeys).
   - Return the IPNS name and the complete record payload ready for batch publish.

2. `resolveFileMetadata(fileMetaIpnsName: string, folderKey: Uint8Array): Promise<FileMetadata>`
   - Resolve IPNS: `resolveIpnsRecord(fileMetaIpnsName)` -- reuse existing function.
   - If null, throw Error('File metadata IPNS not found').
   - Fetch encrypted metadata from IPFS: `fetchFromIpfs(resolved.cid)`.
   - Parse and decrypt: `decryptFileMetadata(JSON.parse(new TextDecoder().decode(bytes)), folderKey)`.
   - Return decrypted FileMetadata.

3. `updateFileMetadata(params: { fileId: string, folderKey: Uint8Array, userPrivateKey: Uint8Array, currentMetadata: FileMetadata, updates: Partial<Pick<FileMetadata, 'cid' | 'fileKeyEncrypted' | 'fileIv' | 'size'>> }): Promise<{ ipnsRecord: { ipnsName: string, recordBase64: string, metadataCid: string } }>`
   - Merge updates into currentMetadata, update modifiedAt.
   - Re-derive file IPNS keypair from userPrivateKey + fileId.
   - Resolve current IPNS to get sequence number, then increment.
   - Encrypt updated metadata with folderKey, upload to IPFS.
   - Create new IPNS record with incremented sequence number.
   - Return record payload ready for publish (single record, no TEE enrollment needed -- already enrolled).

Import from `@cipherbox/crypto`: `deriveFileIpnsKeypair`, `encryptFileMetadata`, `decryptFileMetadata`, `createIpnsRecord`, `marshalIpnsRecord`, `wrapKey`, `bytesToHex`, `hexToBytes`, `type FileMetadata`.
Import `addToIpfs`, `fetchFromIpfs` from `../lib/api/ipfs`.
Import `resolveIpnsRecord` from `./ipns.service`.
Import `useAuthStore` from `../stores/auth.store`.

**ipns.service.ts** -- Add batch publish function:

Add `batchPublishIpnsRecords(records: Array<{ ipnsName: string, recordBase64: string, metadataCid: string, encryptedIpnsPrivateKey?: string, keyEpoch?: number, recordType?: 'folder' | 'file' }>): Promise<{ totalSucceeded: number, totalFailed: number }>`

- Import the generated batch publish API client function (will be named something like `ipnsControllerPublishBatch` from `../api/ipns/ipns`).
- Map records to the DTO format expected by the backend.
- Call the batch endpoint.
- Return success/failure counts.
- Keep existing `createAndPublishIpnsRecord` for single-record publishes (backward compat).

**folder.store.ts** -- Update types:

- Change `children: FolderChild[]` to `children: FolderChildV2[]` in the FolderNode type.
- Import `FolderChildV2` from `@cipherbox/crypto` instead of `FolderChild`.
- Update `updateFolderChildren` action signature to accept `FolderChildV2[]`.
- This is a type-only change; the runtime behavior is unchanged since FolderChildV2 is a union of FolderEntry | FilePointer.

**services/index.ts** -- Add file-metadata.service.ts export if barrel exists.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && pnpm --filter web typecheck` (or `tsc --noEmit`) -- must compile without errors.
Verify new service: `grep "createFileMetadata\|resolveFileMetadata\|updateFileMetadata" apps/web/src/services/file-metadata.service.ts`.
Verify batch publish: `grep "batchPublishIpnsRecords" apps/web/src/services/ipns.service.ts`.
Verify store type: `grep "FolderChildV2" apps/web/src/stores/folder.store.ts`.
</verify>
<done>
file-metadata.service.ts provides create/resolve/update for per-file IPNS metadata. ipns.service.ts has batchPublishIpnsRecords for batch API calls. folder.store.ts FolderNode uses FolderChildV2 (FilePointer instead of FileEntry).
</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite folder.service.ts + update download/delete for v2</name>
  <files>
    apps/web/src/services/folder.service.ts
    apps/web/src/services/download.service.ts
    apps/web/src/services/delete.service.ts
  </files>
  <action>
**folder.service.ts** -- Major rewrite for v2 metadata:

Update imports: Add `FilePointer`, `FolderMetadataV2`, `FolderChildV2`, `isV2Metadata`, `deriveFileIpnsKeypair` from `@cipherbox/crypto`. Import `createFileMetadata`, `resolveFileMetadata`, `updateFileMetadata` from `./file-metadata.service`. Import `batchPublishIpnsRecords` from `./ipns.service`.

**loadFolder** -- Update to handle v2:

- After decrypting metadata, check `isV2Metadata(metadata)`.
- For v2 metadata, children are already `FolderChildV2[]` (FilePointer | FolderEntry). Return as-is.
- The caller (folder store/UI) gets FilePointer entries with `fileMetaIpnsName` instead of embedded CID/key.
- Do NOT eagerly resolve per-file IPNS records during folder load (Pitfall 1 from research). File metadata is lazy-loaded on download/preview.

**updateFolderMetadata** -- Update for v2:

- Change metadata version to `'v2'`.
- Accept `FolderChildV2[]` children.
- Type the metadata as `FolderMetadataV2`.

**addFileToFolder** -- Complete rewrite:

- New signature: remove `cid`, `fileKeyEncrypted`, `fileIv` params. Add `fileId: string` (pre-generated by caller), `fileIpnsRecord: { ipnsName: string, recordBase64: string, metadataCid: string, encryptedIpnsPrivateKey?: string, keyEpoch?: number }`.
- Create FilePointer: `{ type: 'file', id: fileId, name, fileMetaIpnsName: fileIpnsRecord.ipnsName, createdAt: now, modifiedAt: now }`.
- Add FilePointer to parent's children array.
- Build batch records array: [fileIpnsRecord, folderIpnsRecord].
- Use `batchPublishIpnsRecords` instead of `createAndPublishIpnsRecord`.
- Return `{ filePointer, newSequenceNumber }`.

**addFilesToFolder** -- Complete rewrite for batch:

- New signature: accept `files: Array<{ fileId: string, name: string, fileIpnsRecord: { ipnsName: string, recordBase64: string, metadataCid: string, encryptedIpnsPrivateKey?: string, keyEpoch?: number } }>`.
- Create FilePointer for each file.
- Build batch records: all N file IPNS records + 1 folder IPNS record.
- Single `batchPublishIpnsRecords` call for entire batch.
- Return `{ filePointers, newSequenceNumber }`.

**replaceFileInFolder** -- Rewrite for content update:

- Find FilePointer by fileId in parent children (it's now a FilePointer, not FileEntry).
- The caller provides the updated file IPNS record payload (from `updateFileMetadata`).
- Content update publishes ONLY the file IPNS record (folder metadata untouched -- this is THE primary benefit).
- Use `batchPublishIpnsRecords` with single-element array (the file IPNS record).
- Do NOT update folder metadata or folder IPNS. The folder's FilePointer still points to the same fileMetaIpnsName, which now resolves to the new content.
- Return old CID for unpinning (caller must resolve current file metadata to get old CID before calling this).

**renameFile** -- Minimal change:

- Still updates folder metadata only (FilePointer.name changes, file IPNS record untouched).
- Update type cast from `FileEntry` to `FilePointer` where applicable.
- Use `updateFolderMetadata` with v2 schema.

**deleteFileFromFolder** -- Update:

- Find FilePointer by fileId.
- Remove from parent children.
- Update folder metadata and publish.
- Return fileMetaIpnsName so caller can unenroll from TEE (handled in delete.service.ts).

**moveFile** -- Update:

- Cast to `FilePointer` instead of `FileEntry`.
- FilePointer contains fileMetaIpnsName which stays the same across moves.
- No file IPNS record changes needed -- only folder metadata changes (remove from source, add to dest).

**moveFolder**, **renameFolder**, **deleteFolder**, **createFolder** -- These operate on folder entries only and don't touch file IPNS records directly. Update type annotations from `FolderChild` to `FolderChildV2` where needed.

**deleteFolder** recursive CID collection:

- For v2, files in the folder are FilePointers, not FileEntries. The CID is not directly available in the folder metadata.
- Change collectCids to collect `fileMetaIpnsName` values instead of CIDs. Return these so the caller can resolve file metadata to get CIDs for unpinning AND unenroll file IPNS from TEE.
- Rename return type to reflect it returns ipnsNames, not CIDs.

**fetchAndDecryptMetadata** -- Update return type:

- Return `FolderMetadata | FolderMetadataV2` (uses updated decryptFolderMetadata which now returns the union type).

**download.service.ts** -- Update for per-file IPNS:

- The `FileMetadata` type in download.service.ts currently expects `cid`, `iv`, `wrappedKey` directly.
- Keep the existing `downloadFile(metadata: FileMetadata, privateKey, onProgress)` function signature for low-level download (it still takes cid/iv/wrappedKey).
- Add a new convenience function: `downloadFileFromIpns(params: { fileMetaIpnsName: string, folderKey: Uint8Array, privateKey: Uint8Array, fileName: string, onProgress?: DownloadProgressCallback }): Promise<Uint8Array>`:
  1. Call `resolveFileMetadata(fileMetaIpnsName, folderKey)` to get the FileMetadata with cid, fileKeyEncrypted, fileIv.
  2. Call existing `downloadFile({ cid: meta.cid, iv: meta.fileIv, wrappedKey: meta.fileKeyEncrypted, originalName: fileName }, privateKey, onProgress)`.
  3. Return decrypted content.
- This function is what hooks/components will call instead of the low-level `downloadFile`.

**delete.service.ts** -- Update for file IPNS unenrollment:

- For now, the pragmatic approach: on file delete, the folder metadata is updated (FilePointer removed). The file IPNS record and TEE enrollment are left to expire. Add a TODO comment noting Phase 14 should add explicit unenrollment.
- If the republish service has an `unenrollIpns` method exposed via API (check generated client after Plan 02), call it. Otherwise, log a warning about the orphaned TEE enrollment.
  </action>
  <verify>
  Run `cd /Users/michael/Code/cipher-box && pnpm --filter web typecheck` (or `tsc --noEmit`) -- must compile without errors.
  Run `cd /Users/michael/Code/cipher-box && pnpm --filter web build` -- builds without errors.
  Verify v2 metadata: `grep "version: 'v2'" apps/web/src/services/folder.service.ts`.
  Verify batch publish in upload: `grep "batchPublishIpnsRecords" apps/web/src/services/folder.service.ts`.
  Verify download helper: `grep "downloadFileFromIpns" apps/web/src/services/download.service.ts`.
  Verify content update skips folder: The `replaceFileInFolder` function should NOT call `updateFolderMetadata`.
  </verify>
  <done>
  folder.service.ts fully rewritten for v2 metadata. Upload creates per-file IPNS records with batch publish. Content update (replaceFileInFolder) publishes only file IPNS (folder untouched). File rename publishes only folder IPNS (file untouched). download.service.ts has downloadFileFromIpns convenience function for IPNS-based download. Batch upload uses single API call for N file records + 1 folder record. Note: hooks and components still reference v1 types -- they are updated in Plan 04.
  </done>
  </task>

</tasks>

<verification>
- `pnpm --filter web typecheck` succeeds (service layer compiles; hooks/components may have type errors until Plan 04)
- Content update path: `replaceFileInFolder` does NOT call `updateFolderMetadata` (primary architectural benefit)
- File rename path: `renameFile` does NOT touch file IPNS record
- Batch upload: `addFilesToFolder` builds array of N+1 records for single `batchPublishIpnsRecords` call
- Download flow: `downloadFileFromIpns` resolves fileMetaIpnsName before fetching encrypted file content
- Folder load: does NOT eagerly resolve per-file IPNS records (lazy loading)
</verification>

<success_criteria>

- All service files and store types use v2 metadata schema (FilePointer in folder, FileMetadata in per-file IPNS)
- Content update publishes only file IPNS record, not folder (the primary optimization)
- File rename publishes only folder IPNS record, not file
- Batch upload sends all records in single API call
- File download has downloadFileFromIpns for IPNS-based resolution + download
- folder.store.ts FolderNode uses FolderChildV2
- Service layer compiles without errors

</success_criteria>

<output>
After completion, create `.planning/phases/12.6-per-file-ipns-metadata-split/12.6-03-SUMMARY.md`
</output>
