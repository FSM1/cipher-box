# Phase 12.6: Per-File IPNS Metadata Split - Research

**Researched:** 2026-02-17
**Domain:** IPNS metadata architecture, HKDF key derivation, TEE scalability
**Confidence:** HIGH

## Summary

This phase splits file metadata out of folder IPNS records into individual per-file IPNS records. The research investigated the current codebase implementation (folder metadata schema, IPNS publishing flow, TEE enrollment, batch publish, vault export, FUSE client) and evaluated the HKDF derivation strategy, encryption approach, and TEE scalability impact.

The codebase already has well-established patterns for HKDF IPNS key derivation (vault IPNS, device registry IPNS), AES-256-GCM metadata encryption, and TEE enrollment. The per-file IPNS implementation is a direct extension of these patterns with the same salt (`CipherBox-v1`) and a new info string (`cipherbox-file-ipns-v1:<fileId>`). The primary technical challenge is TEE republish scalability -- per-file IPNS multiplies the republish workload proportionally to file count.

Since CONTEXT.md specifies a clean break (v2-only, no backward compatibility), this is a greenfield schema change with no migration burden. The folder metadata version changes from `v1` to `v2`, and the `FileEntry` type is replaced with a slim `FilePointer` type containing only the name, IPNS pointer, and timestamps.

**Primary recommendation:** Follow the existing HKDF derivation pattern exactly. Use file-ID-parameterized info strings for domain separation. Encrypt per-file metadata with the parent folder's `folderKey` (not the file's own key) since the file record must be decryptable by anyone who can read the folder. Use batch IPNS publish for all operations. Implement conservative TEE capacity limits with staleness-based prioritization.

## Standard Stack

This phase extends the existing stack with no new libraries.

### Core

| Library             | Version  | Purpose                                                   | Why Standard                                              |
| ------------------- | -------- | --------------------------------------------------------- | --------------------------------------------------------- |
| `@cipherbox/crypto` | existing | HKDF derivation, AES-GCM encryption, IPNS record creation | In-house crypto package, all patterns already established |
| `@noble/ed25519`    | existing | Ed25519 keypair derivation from HKDF seed                 | Already used for vault/registry IPNS derivation           |
| `@libp2p/crypto`    | existing | Ed25519 key conversion for IPNS                           | Already used in `derive-name.ts` and `create-record.ts`   |
| `ipns`              | existing | IPNS record creation and signing                          | Already used in `create-record.ts`                        |
| `typeorm`           | existing | Database entities/migrations                              | Already used for `FolderIpns`, `IpnsRepublishSchedule`    |

### Supporting

| Library           | Version  | Purpose                          | When to Use                          |
| ----------------- | -------- | -------------------------------- | ------------------------------------ |
| `class-validator` | existing | DTO validation for batch publish | Already used in publish DTO          |
| `@nestjs/bullmq`  | existing | Republish job scheduling         | Already used for republish processor |

### Alternatives Considered

| Instead of                                | Could Use                        | Tradeoff                                                                                                                                        |
| ----------------------------------------- | -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| Parent folderKey for file meta encryption | Separate per-file encryption key | Adds complexity; anyone reading the folder already has the folderKey, so separate key provides no security benefit for the current access model |
| HKDF per-file derivation                  | Random Ed25519 keypairs          | HKDF is deterministic = recoverable from privateKey + fileId alone; random keys require storage                                                 |

**Installation:** No new packages needed.

## Architecture Patterns

### Current vs. New Data Model

**Current (v1) -- File metadata embedded in folder:**

```text
FolderMetadata (encrypted with folderKey, stored on IPFS, addressed by folder IPNS):
  version: "v1"
  children: [
    { type: "file", id, name, cid, fileKeyEncrypted, fileIv, encryptionMode, size, createdAt, modifiedAt }
    { type: "folder", id, name, ipnsName, ipnsPrivateKeyEncrypted, folderKeyEncrypted, createdAt, modifiedAt }
  ]
```

**New (v2) -- File metadata in separate IPNS record:**

```text
FolderMetadata (encrypted with folderKey, stored on IPFS, addressed by folder IPNS):
  version: "v2"
  children: [
    { type: "file", id, name, fileMetaIpnsName, createdAt, modifiedAt }
    { type: "folder", id, name, ipnsName, ipnsPrivateKeyEncrypted, folderKeyEncrypted, createdAt, modifiedAt }
  ]

FileMetadata (encrypted with folderKey, stored on IPFS, addressed by per-file IPNS):
  version: "v1"
  cid: string           // IPFS CID of encrypted file content
  fileKeyEncrypted: string  // ECIES-wrapped AES-256 file decryption key
  fileIv: string           // Hex-encoded IV for file decryption
  size: number             // Original file size in bytes
  mimeType: string         // MIME type (for future use; currently inferred from name)
  createdAt: number        // Unix ms
  modifiedAt: number       // Unix ms
```

### HKDF File IPNS Derivation Pattern

```typescript
// Source: packages/crypto/src/vault/derive-ipns.ts (existing pattern)
// New function follows identical pattern with file-specific info string

const FILE_HKDF_SALT = new TextEncoder().encode('CipherBox-v1'); // same salt as vault/registry

function fileHkdfInfo(fileId: string): Uint8Array {
  // Format: "cipherbox-file-ipns-v1:<uuid>"
  // The fileId provides per-file domain separation within the same HKDF domain
  return new TextEncoder().encode(`cipherbox-file-ipns-v1:${fileId}`);
}

export async function deriveFileIpnsKeypair(
  userPrivateKey: Uint8Array,
  fileId: string
): Promise<{ privateKey: Uint8Array; publicKey: Uint8Array; ipnsName: string }> {
  // Validate input
  if (userPrivateKey.length !== 32) {
    throw new CryptoError('Invalid private key size', 'INVALID_KEY_SIZE');
  }

  // 1. HKDF: secp256k1 privateKey -> 32-byte Ed25519 seed
  //    Domain separation via info="cipherbox-file-ipns-v1:<fileId>"
  const ed25519Seed = await deriveKey({
    inputKey: userPrivateKey,
    salt: FILE_HKDF_SALT,
    info: fileHkdfInfo(fileId),
    outputLength: 32,
  });

  // 2. Ed25519 public key from seed
  const ed25519PublicKey = await ed.getPublicKeyAsync(ed25519Seed);

  // 3. IPNS name from public key
  const ipnsName = await deriveIpnsName(ed25519PublicKey);

  return { privateKey: ed25519Seed, publicKey: ed25519PublicKey, ipnsName };
}
```

**HKDF domain separation rationale (HIGH confidence):**

- Same salt (`CipherBox-v1`) across all HKDF uses in the codebase -- this is correct per RFC 5869; salt provides extraction-phase domain separation
- Different info strings provide expand-phase domain separation:
  - Vault IPNS: `cipherbox-vault-ipns-v1`
  - Device registry IPNS: `cipherbox-device-registry-ipns-v1`
  - File IPNS: `cipherbox-file-ipns-v1:<fileId>`
- Including `fileId` in info guarantees unique per-file keys even from same master key
- This is the standard HKDF pattern per RFC 5869 Section 3.2

### File Metadata Encryption Decision

**Key question:** What key encrypts the per-file IPNS record?

**Answer: Use the parent folder's `folderKey`.**

Rationale:

1. The file metadata record contains `fileKeyEncrypted` (ECIES-wrapped), `cid`, `fileIv`, `size`, `mimeType` -- all of which are currently accessible to anyone with the `folderKey` (since they're embedded in folder metadata today)
2. Using the `folderKey` maintains the same security boundary -- if you can read the folder, you can read file metadata
3. This is critical for listing: the web app must decrypt file metadata to display file size and (future) mimeType in folder listings
4. For future per-file sharing (SHARE-01): the shared file's metadata would be re-encrypted with a share-specific key, but that's a Phase 14 concern
5. The file's `fileKeyEncrypted` is ECIES-wrapped with the _user's_ publicKey, not the folderKey, so the actual file content encryption key remains wrapped at the user level

**Encryption format:** Same as folder metadata -- `EncryptedFolderMetadata` structure with `{iv: hex, data: base64}` AES-256-GCM envelope. Can reuse or rename to `EncryptedMetadataEnvelope`.

### Recommended Project Structure Changes

```text
packages/crypto/src/
  file/                     # NEW: per-file metadata types and encryption
    types.ts                # FileMetadata, FilePointer, EncryptedFileMetadata types
    metadata.ts             # encryptFileMetadata(), decryptFileMetadata()
    derive-ipns.ts          # deriveFileIpnsKeypair()
    index.ts                # barrel export
  folder/
    types.ts                # MODIFIED: v2 schema - FileEntry -> FilePointer
    metadata.ts             # MODIFIED: validateFolderMetadata supports v2

apps/api/src/
  ipns/
    dto/publish.dto.ts      # MODIFIED: batch publish DTO (array of records)
    ipns.controller.ts      # MODIFIED: new batch publish endpoint
    ipns.service.ts         # MODIFIED: batch publish logic
    entities/
      folder-ipns.entity.ts # MODIFIED: rename to ipns-record.entity.ts, add record_type column
  republish/
    republish.service.ts    # MODIFIED: handle file IPNS records alongside folder records

apps/web/src/
  services/
    folder.service.ts       # MODIFIED: all file operations use per-file IPNS
    file-metadata.service.ts # NEW: per-file IPNS operations
  stores/
    folder.store.ts         # MODIFIED: FolderNode children use FilePointer
```

### Operation Flows

**Upload file (new):**

1. Client encrypts file content -> upload to IPFS -> get CID
2. Client generates fileId (UUID)
3. Client derives file IPNS keypair: `deriveFileIpnsKeypair(userPrivateKey, fileId)`
4. Client creates FileMetadata: `{cid, fileKeyEncrypted, fileIv, size, mimeType, timestamps}`
5. Client encrypts FileMetadata with parent's `folderKey` -> upload to IPFS -> get metadataCID
6. Client creates signed IPNS record for file pointing to metadataCID
7. Client creates FilePointer in folder: `{type: "file", id: fileId, name, fileMetaIpnsName, timestamps}`
8. Client updates folder metadata with new FilePointer -> upload to IPFS -> get folderMetadataCID
9. Client creates signed IPNS record for folder pointing to folderMetadataCID
10. **Single API call:** sends both IPNS records + TEE enrollment for file IPNS key

**Content update (re-upload):**

1. Client re-encrypts file content -> upload to IPFS -> get new CID
2. Client updates FileMetadata with new CID/key/IV -> encrypt with folderKey -> upload to IPFS
3. Client creates new signed IPNS record for file pointing to new metadataCID
4. **Single API call:** sends only the file IPNS record (folder IPNS untouched)

**File rename:**

1. Client updates FilePointer name in folder metadata
2. Client re-encrypts folder metadata -> upload to IPFS
3. Client creates new signed IPNS record for folder
4. **Single API call:** sends only the folder IPNS record (file IPNS untouched)

**Batch upload (N files):**

1. Client encrypts all N files -> upload all to IPFS
2. Client creates N FileMetadata objects -> encrypt all with folderKey -> upload all to IPFS
3. Client creates N signed file IPNS records
4. Client creates N FilePointers -> updates folder metadata -> upload to IPFS
5. Client creates 1 signed folder IPNS record
6. **Single API call:** sends N+1 IPNS records + N TEE enrollments

**Loading folder contents:**

1. Resolve folder IPNS -> get folder metadata CID -> fetch and decrypt
2. For each FilePointer in children: resolve fileMetaIpnsName -> get file metadata CID -> fetch and decrypt
3. Combine FilePointer (name, timestamps from folder) + FileMetadata (size, cid, etc.) for display

### Anti-Patterns to Avoid

- **Individual IPNS publishes per file in a batch:** NEVER publish file IPNS records one-at-a-time. Always batch.
- **Encrypting file metadata with user's publicKey instead of folderKey:** This would make folder listing require ECIES decryption per file, which is slow and wrong for the current access model.
- **Storing file IPNS private key in folder metadata:** The key is HKDF-derived from userPrivateKey + fileId, so it's deterministically recoverable. Don't store it.
- **Making the IPNS name the primary identifier:** Use `fileId` (UUID) as the stable identifier. The IPNS name is derived from it.

## Don't Hand-Roll

| Problem                     | Don't Build                   | Use Instead                                                           | Why                                           |
| --------------------------- | ----------------------------- | --------------------------------------------------------------------- | --------------------------------------------- |
| HKDF derivation             | Custom key stretching         | `deriveKey()` from `packages/crypto/src/keys/derive.ts`               | Web Crypto HKDF is audited, constant-time     |
| IPNS record creation        | Manual protobuf/CBOR encoding | `createIpnsRecord()` from `packages/crypto/src/ipns/create-record.ts` | Complex multi-version signature format        |
| IPNS name derivation        | Manual multihash encoding     | `deriveIpnsName()` from `packages/crypto/src/ipns/derive-name.ts`     | libp2p-key codec, base36 encoding             |
| Ed25519 from seed           | Custom derivation             | `@noble/ed25519` `getPublicKeyAsync()`                                | Already used, deterministic                   |
| AES-GCM metadata encryption | Custom encrypt/serialize      | `encryptFolderMetadata()` pattern                                     | Handles chunked base64, IV generation         |
| Batch retry logic           | Custom retry per record       | Backend retry in `ipns.service.ts`                                    | Existing 3-attempt exponential backoff        |
| TEE enrollment              | Custom enrollment API         | `republishService.enrollFolder()` pattern                             | Existing pattern handles create/update upsert |

**Key insight:** Every cryptographic and IPNS operation needed for per-file metadata already has an established implementation pattern in the codebase. The work is composing these existing primitives into new flows, not inventing new ones.

## Common Pitfalls

### Pitfall 1: Folder Listing Performance Regression

**What goes wrong:** Naive implementation resolves every file's IPNS name when loading a folder, causing N additional network requests per folder.
**Why it happens:** The v1 schema had all file data embedded in the folder blob (1 fetch = all data). v2 separates it.
**How to avoid:**

- For initial folder listing, use only data from the FilePointer (name, timestamps). This is sufficient for sorted lists.
- Lazy-load file metadata (size, mimeType) only when the user scrolls or clicks.
- Use the backend's DB-cached CID for file IPNS resolution (not delegated routing) for speed.
- Batch-resolve file IPNS names in parallel (Promise.all with concurrency limit).

**Warning signs:** Folder load time increases linearly with file count; UI shows loading spinners for each file.

### Pitfall 2: TEE Republish Overload

**What goes wrong:** A vault with 1,000 files has ~1,050 IPNS records to republish every 6 hours. At ~2s per sequential publish, that's ~35 minutes.
**Why it happens:** Each file IPNS record needs signing by TEE and publishing to delegated routing.
**How to avoid:**

- **Parallelize TEE publishes:** The TEE can sign all records in a batch (already does this). After signing, publish to delegated routing in parallel (10-20 concurrent requests).
- **Staleness-based priority:** Sort by `lastRepublishAt` ascending. If the batch can't finish in time, at least the stalest records get refreshed.
- **Soft capacity warning:** Log a warning when a user exceeds ~1,000 file IPNS records. This is not a hard limit, but signals potential degradation.
- **Hard capacity limit:** Consider ~5,000 file IPNS records per user as an initial hard limit. At 20 concurrent publishes and ~2s each, 5,000 records take ~8.3 minutes per cycle.

**Warning signs:** Republish job exceeds the 6-hour interval; records expire before republishing.

### Pitfall 3: Sequence Number Conflicts

**What goes wrong:** Two devices update the same file's IPNS record simultaneously, producing two records with the same sequence number pointing to different CIDs.
**Why it happens:** IPNS uses monotonically increasing sequence numbers. The higher sequence number wins.
**How to avoid:**

- The existing sequence number tracking in `FolderIpns` entity + DB upsert already handles this.
- For per-file records, apply the same pattern: track sequence numbers in DB.
- The client should read the current sequence number before publishing (resolve -> increment -> publish).

**Warning signs:** File content appears to revert after updates from another device.

### Pitfall 4: HKDF Derivation Mismatch Between Client and Recovery

**What goes wrong:** The recovery tool derives a different IPNS name for a file because it uses a different info string format.
**Why it happens:** The info string must include the exact fileId, and the format must match exactly.
**How to avoid:**

- Document the info string format: `cipherbox-file-ipns-v1:<uuid>` where uuid is the file's `id` field from the FilePointer.
- The fileId is stored in the folder metadata (which the recovery tool can read), so it's always available.
- Add test vectors for file IPNS derivation.

**Warning signs:** Recovery tool can't find file IPNS records; IPNS names don't match.

### Pitfall 5: Orphaned File IPNS Records on Deletion

**What goes wrong:** When a file is deleted, the folder metadata is updated (FilePointer removed), but the file's IPNS record and TEE enrollment remain.
**Why it happens:** Deletion currently only removes the entry from the folder and unpins the file CID.
**How to avoid:**

- On file deletion: also unenroll the file IPNS from TEE republishing.
- The file IPNS record itself can be left to expire (IPNS records have 24h TTL). No need to "unpublish."
- Add an `unenrollIpns(userId, ipnsName)` method to `RepublishService`.

**Warning signs:** TEE republish schedule grows unboundedly; stale entries accumulate.

### Pitfall 6: Batch Publish Atomicity

**What goes wrong:** In a batch upload, some file IPNS records publish successfully but the folder IPNS publish fails. The folder doesn't reference the new files, but the file IPNS records exist.
**Why it happens:** Network errors during the folder publish step.
**How to avoid:**

- Orphaned file IPNS records are harmless -- they point to valid encrypted data but are unreachable without the folder reference.
- On retry, the client can re-derive the file IPNS keypairs from fileIds (HKDF is deterministic) and re-publish.
- The backend should return partial success indicators so the client knows which records published.
- CONTEXT.md already acknowledges this: "Orphaned file records (from partial publish before rollback) are harmless."

**Warning signs:** Files don't appear in folder listing after upload despite successful upload to IPFS.

## Code Examples

### File IPNS Derivation (extends vault/registry pattern)

```typescript
// Source: packages/crypto/src/vault/derive-ipns.ts (existing pattern to follow)
// New: packages/crypto/src/file/derive-ipns.ts

import { deriveKey } from '../keys/derive';
import * as ed from '@noble/ed25519';
import { deriveIpnsName } from '../ipns/derive-name';
import { CryptoError } from '../types';
import { SECP256K1_PRIVATE_KEY_SIZE } from '../constants';

const FILE_HKDF_SALT = new TextEncoder().encode('CipherBox-v1');

export async function deriveFileIpnsKeypair(
  userPrivateKey: Uint8Array,
  fileId: string
): Promise<{ privateKey: Uint8Array; publicKey: Uint8Array; ipnsName: string }> {
  if (userPrivateKey.length !== SECP256K1_PRIVATE_KEY_SIZE) {
    throw new CryptoError('Invalid private key size for file derivation', 'INVALID_KEY_SIZE');
  }
  if (!fileId || fileId.length < 10) {
    throw new CryptoError('Invalid fileId for file IPNS derivation', 'INVALID_KEY_SIZE');
  }

  const info = new TextEncoder().encode(`cipherbox-file-ipns-v1:${fileId}`);

  const ed25519Seed = await deriveKey({
    inputKey: userPrivateKey,
    salt: FILE_HKDF_SALT,
    info,
    outputLength: 32,
  });

  const ed25519PublicKey = await ed.getPublicKeyAsync(ed25519Seed);
  const ipnsName = await deriveIpnsName(ed25519PublicKey);

  return { privateKey: ed25519Seed, publicKey: ed25519PublicKey, ipnsName };
}
```

### v2 Folder Metadata Types

```typescript
// Source: packages/crypto/src/folder/types.ts (to be modified)

/** v2 folder metadata -- file pointers replace embedded file entries */
export type FolderMetadataV2 = {
  version: 'v2';
  children: FolderChildV2[];
};

export type FolderChildV2 = FolderEntry | FilePointer;

/** Slim file pointer -- only name + IPNS reference in folder metadata */
export type FilePointer = {
  type: 'file';
  id: string; // UUID (used for HKDF derivation)
  name: string; // Plaintext file name
  fileMetaIpnsName: string; // IPNS name pointing to encrypted file metadata
  createdAt: number;
  modifiedAt: number;
};

// FolderEntry stays unchanged
```

### Per-File Metadata Types

```typescript
// Source: new packages/crypto/src/file/types.ts

/** Per-file metadata stored in its own IPNS record */
export type FileMetadata = {
  version: 'v1';
  cid: string; // IPFS CID of encrypted file content
  fileKeyEncrypted: string; // ECIES-wrapped AES-256 file key (hex)
  fileIv: string; // Hex-encoded IV for file decryption
  size: number; // Original file size in bytes
  mimeType: string; // MIME type (e.g., "image/png")
  createdAt: number; // Unix ms
  modifiedAt: number; // Unix ms
  // versionHistory: omitted per CONTEXT.md -- Phase 13 adds it
};

/** Encrypted file metadata envelope (same format as folder metadata) */
export type EncryptedFileMetadata = {
  iv: string; // Hex-encoded 12-byte AES-GCM IV
  data: string; // Base64-encoded AES-GCM ciphertext
};
```

### Batch Publish DTO

```typescript
// Source: apps/api/src/ipns/dto/publish.dto.ts (to be modified/extended)

export class BatchPublishIpnsDto {
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => PublishIpnsEntryDto)
  @ArrayMaxSize(200) // reasonable upper bound for single batch
  records!: PublishIpnsEntryDto[];
}

export class PublishIpnsEntryDto {
  @IsString()
  @Matches(/^(k51qzi5uqu5[a-z0-9]{40,60}|bafzaa[a-z2-7]{50,70})$/)
  @MaxLength(70)
  ipnsName!: string;

  @IsString()
  @IsBase64()
  @MaxLength(10000)
  record!: string;

  @IsString()
  @Matches(/^(bafy|bafk|Qm)[a-zA-Z0-9]+$/)
  @MaxLength(100)
  metadataCid!: string;

  @IsString()
  @IsOptional()
  @Matches(/^[0-9a-fA-F]+$/)
  @MinLength(100)
  @MaxLength(1000)
  encryptedIpnsPrivateKey?: string;

  @IsNumber()
  @IsOptional()
  keyEpoch?: number;

  @IsString()
  @IsOptional()
  recordType?: 'folder' | 'file'; // for DB tracking
}
```

### Backend Batch Publish Service

```typescript
// Source: apps/api/src/ipns/ipns.service.ts (to be extended)

async publishBatch(userId: string, dto: BatchPublishIpnsDto): Promise<BatchPublishResponseDto> {
  const results: PublishIpnsResponseDto[] = [];

  // Publish all records to delegated routing with concurrency limit
  const CONCURRENCY = 10;
  for (let i = 0; i < dto.records.length; i += CONCURRENCY) {
    const batch = dto.records.slice(i, i + CONCURRENCY);
    const batchResults = await Promise.allSettled(
      batch.map(entry => this.publishRecord(userId, entry))
    );

    for (const result of batchResults) {
      if (result.status === 'fulfilled') {
        results.push(result.value);
      } else {
        // Log failure, continue with remaining records
        this.logger.warn(`Batch publish entry failed: ${result.reason}`);
        // Retry logic: 3 attempts with backoff (handled in publishRecord)
      }
    }
  }

  return { results, totalSucceeded: results.length, totalFailed: dto.records.length - results.length };
}
```

## State of the Art

| Old Approach (v1)                                             | New Approach (v2)                                        | Impact                                  |
| ------------------------------------------------------------- | -------------------------------------------------------- | --------------------------------------- |
| File metadata embedded in folder IPNS record                  | Per-file IPNS records with folder pointers               | Content updates don't republish folders |
| Content update = folder republish (all children re-encrypted) | Content update = file record republish only              | Significant performance improvement     |
| Per-file sharing impossible without folder access             | File IPNS name + re-wrapped key = shareable unit         | Foundation for SHARE-01                 |
| Folder metadata grows O(N) with file count                    | Folder metadata grows O(N) in names only (slim pointers) | Reduced folder blob size                |
| Single IPNS publish per operation                             | Batch IPNS publish for multi-file operations             | Same atomicity, more records            |
| ~50 IPNS records per vault (folders only)                     | ~1,050 IPNS records per vault (folders + files)          | TEE republish workload increases ~20x   |

**Deprecated/outdated:**

- `FileEntry` type with embedded `cid`, `fileKeyEncrypted`, `fileIv`, `size` in folder metadata -- replaced by `FilePointer` with only `fileMetaIpnsName`
- Single `PublishIpnsDto` for one record at a time -- extended with `BatchPublishIpnsDto`
- `folder_ipns` entity/table name -- should be renamed or generalized to handle both folder and file IPNS records

## TEE Republish Scalability Analysis

### Current State

- TEE republishes in batches of 50 (`BATCH_SIZE = 50` in `republish.service.ts`)
- Republish interval: 6 hours
- Max entries queried per cycle: 500
- Sequential publish to delegated routing after TEE signing
- Average time per publish to delegated routing: ~1-3 seconds

### Impact of Per-File IPNS

| Metric                                       | Before (folders only) | After (folders + files) | Notes                     |
| -------------------------------------------- | --------------------- | ----------------------- | ------------------------- |
| Records per vault (100 files, 10 folders)    | ~10                   | ~110                    | 11x increase              |
| Records per vault (1,000 files, 50 folders)  | ~50                   | ~1,050                  | 21x increase              |
| Records per vault (5,000 files, 100 folders) | ~100                  | ~5,100                  | 51x increase              |
| Time per cycle (1,000 files, sequential)     | ~100s                 | ~2,100s (35 min)        | Exceeds reasonable window |
| Time per cycle (1,000 files, 10 parallel)    | ~10s                  | ~210s (3.5 min)         | Acceptable                |
| Time per cycle (5,000 files, 20 parallel)    | ~5s                   | ~510s (8.5 min)         | Acceptable                |

### Recommendations (Claude's Discretion per CONTEXT.md)

- **TEE signing parallelism:** Already batched (50 per request). Keep as-is; TEE signing is fast.
- **Delegated routing publish parallelism:** Implement 10-20 concurrent `fetch()` calls after TEE signing. This is the bottleneck.
- **Soft limit warning:** 1,000 file IPNS records per user. Log warning, no user-facing impact.
- **Hard limit:** 5,000 file IPNS records per user. Return error on upload if exceeded.
- **Priority ordering:** Sort due entries by `lastRepublishAt ASC` (stalest first) per CONTEXT.md decision. This is already partially implemented (query orders by `nextRepublishAt ASC`).
- **Batch size increase:** Increase `BATCH_SIZE` from 50 to 100 for file IPNS records (they're smaller payloads than folder records).
- **getDueEntries limit:** Increase `take: 500` to `take: 2000` to handle larger vaults.

### Backend Retry Strategy (Claude's Discretion per CONTEXT.md)

- **Max attempts:** 3 (already exists)
- **Backoff timing:** 1s, 2s, 4s exponential (already exists)
- **Partial batch failure:** Return results array with per-entry success/failure. Client retries failed entries.

## Vault Export Impact

### Current Export Format (v1.0)

```json
{
  "format": "cipherbox-vault-export",
  "version": "1.0",
  "rootIpnsName": "k51...",
  "encryptedRootFolderKey": "hex...",
  "encryptedRootIpnsPrivateKey": "hex..."
}
```

### Required Changes for v2

The vault export format does NOT need to change. The export contains only the root IPNS name and root keys. The recovery procedure already walks the IPNS hierarchy recursively. With v2:

1. Recovery resolves root IPNS -> root folder metadata (v2)
2. For each `FilePointer` in children: recovery derives the file IPNS keypair using `HKDF(userPrivateKey, fileId)`, resolves the file IPNS name, decrypts file metadata with the parent's folderKey
3. For each `FolderEntry`: same as before (recursive)

**Key insight:** File IPNS keypairs are HKDF-derived, so the recovery tool can re-derive them from `userPrivateKey + fileId`. The fileId is stored in the folder metadata (FilePointer.id), which the recovery tool has already decrypted.

**Changes needed:**

- Recovery tool (`apps/web/public/recovery.html`) must understand v2 folder metadata schema
- Recovery tool must implement `deriveFileIpnsKeypair()` for IPNS resolution
- Recovery tool must decrypt file metadata with parent folderKey
- Since this is v2-only (clean break), the recovery tool only needs to handle v2

### Export Version Bump

- Export `version` should remain `"1.0"` since the export JSON structure itself doesn't change
- The recovery tool detects v2 vaults by checking `FolderMetadata.version === "v2"` after decrypting

## Desktop FUSE Client Impact

**Status:** Desktop update deferred per CONTEXT.md.

### Current Desktop Implementation

The Rust desktop client in `apps/desktop/src-tauri/src/crypto/folder.rs` has:

- `FolderMetadata` struct with `version: String` and `children: Vec<FolderChild>`
- `FileEntry` struct with `cid`, `file_key_encrypted`, `file_iv`, `size`, `encryption_mode`
- `FolderEntry` struct with `ipns_name`, `folder_key_encrypted`, `ipns_private_key_encrypted`

### Changes Needed (Deferred)

1. Add `FilePointer` Rust struct (matching TypeScript `FilePointer`)
2. Add `FileMetadata` Rust struct for per-file IPNS records
3. Modify `FolderChild` enum to include `FilePointer` variant
4. Add file IPNS resolution in the FUSE read path
5. Add HKDF file IPNS derivation (reimplement `deriveFileIpnsKeypair` in Rust)
6. **Critical:** FUSE `readdir` callback must NOT resolve per-file IPNS records (too slow for NFS). Use cached data from folder metadata (name, timestamps). Only resolve file metadata on `open()`/`read()`.

### Impact Until Updated

- Desktop client will NOT work with v2 vaults (will fail to parse v2 folder metadata)
- This is acceptable per CONTEXT.md: "Desktop may not work with v2 vaults until updated"

## Frontend Sync/Polling Impact

### Current Sync Flow

```text
useSyncPolling (30s interval) -> onSync callback ->
  resolveIpnsRecord(rootIpnsName) -> compare CID with local ->
  if changed: fetchAndDecryptMetadata(newCid, folderKey) -> update folder store
```

### v2 Sync Flow Changes

The sync polling continues to poll folder IPNS records (unchanged). When a folder's CID changes:

1. Fetch and decrypt new folder metadata (v2)
2. For each FilePointer: check if fileMetaIpnsName is new/changed
3. Resolve changed file IPNS names -> fetch and decrypt file metadata
4. Update local state with combined data

**Optimization:** The folder IPNS CID changing doesn't mean all file metadata changed. Only file additions/removals change the folder CID. File content updates only change the file's own IPNS record. So:

- Folder sync: only needed for structural changes (add/remove/rename files/folders)
- File content sync: poll file IPNS records for each loaded file (lower priority; Phase 13 concern)

For v1 of this phase: **only sync when folder CID changes**. Don't independently poll file IPNS records. If another device updates file content, it won't be detected until the file is re-opened and its IPNS is re-resolved. This is acceptable for v1.

## Database Schema Changes

### Option: Rename `folder_ipns` to `ipns_record`

The `folder_ipns` table currently tracks folder IPNS records. With per-file IPNS, it should be generalized:

```sql
-- Add record_type column to distinguish folder vs file IPNS records
ALTER TABLE folder_ipns ADD COLUMN record_type varchar(10) DEFAULT 'folder';

-- Or: create a new table for file IPNS records (preferred for separation)
CREATE TABLE file_ipns (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  ipns_name varchar(255) NOT NULL,
  file_id varchar(36) NOT NULL,  -- UUID of the file in folder metadata
  parent_ipns_name varchar(255),  -- folder IPNS name for reference
  latest_cid varchar(255),
  sequence_number bigint NOT NULL DEFAULT 0,
  encrypted_ipns_private_key bytea,
  key_epoch int,
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP NOT NULL DEFAULT now(),
  UNIQUE(user_id, ipns_name)
);
CREATE INDEX idx_file_ipns_user_id ON file_ipns(user_id);
```

The `ipns_republish_schedule` table already works for both folder and file records (it only cares about ipnsName, encryptedIpnsKey, latestCid, sequenceNumber). No changes needed.

## Open Questions

1. **File metadata resolution latency**
   - What we know: Each file's metadata requires an additional IPNS resolve + IPFS fetch
   - What's unclear: Real-world latency for batch-resolving 50+ file IPNS names through delegated routing
   - Recommendation: Use DB-cached CIDs for file IPNS resolution (fast, already implemented for folder IPNS). Delegated routing only as fallback.

2. **Rate limiting on delegated-ipfs.dev for batch publishes**
   - What we know: No documented rate limit was found for delegated-ipfs.dev. The backend already handles 429 responses with retry.
   - What's unclear: Actual limits at scale (publishing 50+ records in rapid succession)
   - Recommendation: Implement conservative client-side throttling (10-20 concurrent requests max). Monitor 429 responses in production.

3. **File IPNS record encryption key when sharing (Phase 14)**
   - What we know: Currently, file metadata is encrypted with parent's folderKey. For sharing, the recipient won't have the folderKey.
   - What's unclear: Whether to re-encrypt with a share-specific key or restructure the encryption
   - Recommendation: Defer to Phase 14. Document that the encryption key for file metadata may change when sharing is implemented.

## Sources

### Primary (HIGH confidence)

- `packages/crypto/src/vault/derive-ipns.ts` -- Existing HKDF vault IPNS derivation (identical pattern to follow)
- `packages/crypto/src/registry/derive-ipns.ts` -- Existing HKDF registry IPNS derivation (confirms domain separation pattern)
- `packages/crypto/src/keys/derive.ts` -- HKDF-SHA256 implementation via Web Crypto API
- `packages/crypto/src/folder/types.ts` -- Current v1 folder metadata schema
- `packages/crypto/src/folder/metadata.ts` -- Current folder metadata encryption/decryption
- `apps/api/src/ipns/ipns.service.ts` -- Current IPNS publish/resolve flow
- `apps/api/src/republish/republish.service.ts` -- Current TEE enrollment and republish orchestration
- `apps/api/src/tee/tee.service.ts` -- TEE worker communication interface
- `apps/web/src/services/folder.service.ts` -- Current client-side folder operations
- `apps/web/src/services/ipns.service.ts` -- Current client-side IPNS record creation/publishing
- `apps/web/src/stores/folder.store.ts` -- Current in-memory folder tree management
- `apps/desktop/src-tauri/src/crypto/folder.rs` -- Rust desktop client metadata types
- `docs/VAULT_EXPORT_FORMAT.md` -- Current vault export specification
- [RFC 5869 - HKDF](https://datatracker.ietf.org/doc/html/rfc5869) -- HKDF standard, domain separation via info parameter

### Secondary (MEDIUM confidence)

- [Delegated Routing V1 HTTP API Spec](https://specs.ipfs.tech/routing/http-routing-v1/) -- IPNS publish/resolve protocol
- [IPIP-0379: Delegated IPNS HTTP API](https://specs.ipfs.tech/ipips/ipip-0379/) -- IPNS delegated routing specification
- [Understanding HKDF](https://soatok.blog/2021/11/17/understanding-hkdf/) -- HKDF domain separation best practices
- [How to use HKDF to derive new keys](https://cendyne.dev/posts/2023-01-30-how-to-use-hkdf.html) -- Practical HKDF patterns

### Tertiary (LOW confidence)

- [IPFS Forums: IPNS update limits](https://discuss.ipfs.tech/t/are-there-theorical-limits-to-how-frequently-and-how-many-total-ipns-updates-can-be-performed/12171) -- Community discussion on IPNS scalability (no definitive rate limits found)
- delegated-ipfs.dev rate limits: No official documentation found. Assumed reasonable tolerance for batches of 10-20 concurrent requests based on the service being designed for delegated routing at scale.

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH -- all libraries already in use, no new dependencies
- Architecture: HIGH -- direct extension of existing vault/registry IPNS pattern
- HKDF derivation: HIGH -- follows RFC 5869 exactly, existing codebase patterns
- File metadata encryption: HIGH -- uses established AES-GCM envelope pattern with folderKey
- Batch publish: MEDIUM -- new API endpoint but follows existing single-publish pattern
- TEE scalability: MEDIUM -- capacity estimates based on observed publish times; needs production validation
- Delegated routing rate limits: LOW -- no official documentation found
- Pitfalls: HIGH -- derived from codebase analysis and known IPNS/FUSE behaviors

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (30 days -- stable domain, no fast-moving dependencies)
