---
phase: 08-tee-integration
plan: 02
type: execute
wave: 2
depends_on: ['08-01']
files_modified:
  - docker/docker-compose.yml
  - apps/api/src/republish/republish-schedule.entity.ts
  - apps/api/src/republish/republish.service.ts
  - apps/api/src/republish/republish.processor.ts
  - apps/api/src/republish/republish-health.controller.ts
  - apps/api/src/republish/republish.module.ts
  - apps/api/src/app.module.ts
  - apps/api/.env.example
  - apps/api/.env
  - apps/api/package.json
autonomous: true

must_haves:
  truths:
    - 'BullMQ cron job fires every 6 hours to process due republish entries'
    - 'Processor queries due entries, batches them, sends to TEE, publishes signed records'
    - 'Failed republish entries retry with exponential backoff'
    - 'Admin health endpoint returns aggregate counts of pending/failed/stale jobs'
    - 'Redis is available as infrastructure dependency for BullMQ'
  artifacts:
    - path: 'apps/api/src/republish/republish-schedule.entity.ts'
      provides: 'ipns_republish_schedule TypeORM entity'
      contains: 'class IpnsRepublishSchedule'
    - path: 'apps/api/src/republish/republish.processor.ts'
      provides: 'BullMQ worker that processes republish batches'
      contains: 'class RepublishProcessor'
    - path: 'apps/api/src/republish/republish.service.ts'
      provides: 'Core republish orchestration logic'
      contains: 'class RepublishService'
    - path: 'apps/api/src/republish/republish-health.controller.ts'
      provides: 'Admin health endpoint'
      contains: 'republish-health'
    - path: 'apps/api/src/republish/republish.module.ts'
      provides: 'NestJS module with BullMQ queue registration'
      contains: 'BullModule.registerQueue'
  key_links:
    - from: 'apps/api/src/republish/republish.processor.ts'
      to: 'apps/api/src/tee/tee.service.ts'
      via: 'TeeService injection'
      pattern: "teeService\\.republish"
    - from: 'apps/api/src/republish/republish.service.ts'
      to: 'apps/api/src/ipns/ipns.service.ts'
      via: 'IpnsService for delegated routing publish'
      pattern: 'ipnsService'
    - from: 'apps/api/src/republish/republish.module.ts'
      to: 'BullMQ queue'
      via: 'BullModule.registerQueue'
      pattern: 'name.*republish'
---

<objective>
Implement BullMQ-based republish scheduling with Redis, the republish schedule entity, processor, orchestration service, and admin health endpoint.

Purpose: This is the core scheduling engine that automatically republishes IPNS records every 6 hours via the TEE worker. It handles batching, retry with exponential backoff, failure tracking, and admin observability.

Output: RepublishModule with BullMQ processor, cron scheduling, health endpoint, and Redis infrastructure.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-tee-integration/08-CONTEXT.md
@.planning/phases/08-tee-integration/08-RESEARCH.md
@.planning/phases/08-tee-integration/08-01-SUMMARY.md
@apps/api/src/app.module.ts
@apps/api/src/ipns/ipns.service.ts
@apps/api/src/ipns/entities/folder-ipns.entity.ts
@docker/docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redis infrastructure and republish schedule entity</name>
  <files>
    docker/docker-compose.yml
    apps/api/src/republish/republish-schedule.entity.ts
    apps/api/.env.example
    apps/api/.env
    apps/api/package.json
  </files>
  <action>
**docker/docker-compose.yml** -- Add Redis service:

```yaml
redis:
  image: redis:7-alpine
  container_name: cipherbox-redis
  restart: unless-stopped
  ports:
    - '127.0.0.1:6379:6379'
  volumes:
    - redis_data:/data
  healthcheck:
    test: ['CMD', 'redis-cli', 'ping']
    interval: 5s
    timeout: 5s
    retries: 5
```

Add `redis_data:` to the volumes section.

**Install BullMQ dependencies:**
Run `pnpm --filter api add @nestjs/bullmq bullmq ioredis`

**.env.example** -- Add Redis config:

```ini
# Redis (required for BullMQ job scheduling)
REDIS_HOST=localhost
REDIS_PORT=6379
```

**.env** -- Add same Redis config with default values.

**republish-schedule.entity.ts** - TypeORM entity for `ipns_republish_schedule` table:

- `id` UUID PrimaryGeneratedColumn
- `userId` uuid, indexed (column: `user_id`) -- FK to User
- `ipnsName` varchar(255) (column: `ipns_name`) -- the IPNS name being republished
- `encryptedIpnsKey` bytea (column: `encrypted_ipns_key`) -- TEE-encrypted Ed25519 private key
- `keyEpoch` int (column: `key_epoch`) -- which TEE epoch this key was encrypted for
- `latestCid` varchar(255) (column: `latest_cid`) -- most recent metadata CID
- `sequenceNumber` bigint as string (column: `sequence_number`) -- current IPNS sequence
- `nextRepublishAt` timestamp (column: `next_republish_at`) -- when next republish is due
- `lastRepublishAt` timestamp, nullable (column: `last_republish_at`)
- `consecutiveFailures` int, default 0 (column: `consecutive_failures`)
- `status` varchar(20) -- 'active', 'retrying', 'stale' (default: 'active')
- `lastError` text, nullable (column: `last_error`) -- last failure message (never contains keys)
- `createdAt` CreateDateColumn
- `updatedAt` UpdateDateColumn
- Index on `(status, next_republish_at)` for efficient due-entry queries
- Unique constraint on `(user_id, ipns_name)`
- ManyToOne relation to User entity with CASCADE delete

Follow existing entity patterns in the codebase (snake_case columns, Buffer for bytea, string for bigint).
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && npx tsc --noEmit -p apps/api/tsconfig.build.json`. Verify Redis container starts: `docker compose -f docker/docker-compose.yml up -d redis && docker compose -f docker/docker-compose.yml ps redis` shows healthy.
</verify>
<done>
Redis service running in Docker. BullMQ packages installed. IpnsRepublishSchedule entity defines the schedule table with all required columns and indices.
</done>
</task>

<task type="auto">
  <name>Task 2: BullMQ processor, republish service, health controller, and module</name>
  <files>
    apps/api/src/republish/republish.service.ts
    apps/api/src/republish/republish.processor.ts
    apps/api/src/republish/republish-health.controller.ts
    apps/api/src/republish/republish.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**republish.service.ts** - Core orchestration service:
- `@Injectable()` class `RepublishService`
- Constructor injects:
  - `Repository<IpnsRepublishSchedule>` via `@InjectRepository`
  - `Repository<FolderIpns>` via `@InjectRepository` (for sequence number sync)
  - `TeeService` (from TeeModule)
  - `ConfigService`
  - `Logger`
- Properties:
  - `BATCH_SIZE = 50` -- max entries per TEE request (per RESEARCH.md pitfall 4)
  - `MAX_CONSECUTIVE_FAILURES = 10` -- after which entry marked 'stale'
  - `REPUBLISH_INTERVAL_HOURS = 6`
  - `delegatedRoutingUrl` from ConfigService
- Methods:
  - `async getDueEntries(): Promise<IpnsRepublishSchedule[]>` -- query where `status IN ('active', 'retrying') AND next_republish_at <= NOW()` ordered by `next_republish_at ASC`, limit 500
  - `async processRepublishBatch(): Promise<{ processed: number; succeeded: number; failed: number }>` -- main orchestration:
    1. Call getDueEntries()
    2. Split into batches of BATCH_SIZE
    3. For each batch, call teeService.republish(entries)
    4. For successful results: publish signed record to delegated routing (PUT to delegated-ipfs.dev), update `sequence_number`, `latest_cid`, `last_republish_at`, reset `consecutive_failures` to 0, set `next_republish_at` to now + 6 hours, set status to 'active'
    5. If TEE returned `upgradedEncryptedKey` (re-encrypted for current epoch), update `encrypted_ipns_key` and `key_epoch`
    6. Also update the corresponding FolderIpns.sequenceNumber to stay in sync
    7. For failed results: increment `consecutive_failures`, set `last_error`, if consecutive_failures >= MAX_CONSECUTIVE_FAILURES set status to 'stale', otherwise set status to 'retrying' and set `next_republish_at` to now + exponential backoff (min(30 * 2^failures, 3600) seconds)
    8. IMPORTANT: Separate TEE signing from IPNS publishing (per RESEARCH.md pitfall 6). If signing succeeds but publishing fails, still count as a partial success and retry publishing only.
  - `async publishSignedRecord(ipnsName: string, signedRecordBase64: string): Promise<void>` -- PUT to `{delegatedRoutingUrl}/routing/v1/ipns/{ipnsName}` with `Content-Type: application/vnd.ipfs.ipns-record`. Includes retry logic (3 attempts with exponential backoff).
  - `async enrollFolder(userId: string, ipnsName: string, encryptedIpnsKey: Buffer, keyEpoch: number, latestCid: string, sequenceNumber: string): Promise<void>` -- upserts into ipns_republish_schedule, setting next_republish_at to now + 6 hours
  - `async getHealthStats(): Promise<{ pending: number; failed: number; stale: number; lastRunAt: Date | null; currentEpoch: number | null; teeHealthy: boolean }>` -- aggregate counts by status, check TEE health
  - `async reactivateStaleEntries(): Promise<number>` -- when TEE recovers, reset all 'stale' entries to 'active' with next_republish_at = now

NEVER log key material. Log only ipnsName, epoch numbers, success/failure counts.

**republish.processor.ts** - BullMQ worker:

- `@Processor('republish')` class `RepublishProcessor extends WorkerHost`
- Injects `RepublishService`
- `async process(job: Job)` method:
  1. Log job start
  2. Call `republishService.processRepublishBatch()`
  3. Log results: `{ processed, succeeded, failed }`
  4. If all failed and TEE was unreachable, call `republishService.reactivateStaleEntries()` on recovery

**republish-health.controller.ts** - Admin endpoint:

- `@Controller('admin')` class `RepublishHealthController`
- `@Get('republish-health')` endpoint
- Uses `@UseGuards(JwtAuthGuard)` for authentication (admin check deferred -- JWT auth is sufficient for v1 tech demo)
- Calls `republishService.getHealthStats()` and returns the result
- Swagger decorators: ApiTags('Admin'), ApiOperation, ApiResponse

**republish.module.ts** - NestJS module:

- Imports:
  - `BullModule.registerQueue({ name: 'republish' })` -- registers the queue
  - `TypeOrmModule.forFeature([IpnsRepublishSchedule, FolderIpns])`
  - `TeeModule` (for TeeService)
  - `ConfigModule`
- Providers: `RepublishService`, `RepublishProcessor`
- Controllers: `RepublishHealthController`
- Exports: `RepublishService`
- Implements `OnModuleInit`:
  - `this.queue.upsertJobScheduler('republish-cron', { pattern: '0 */6 * * *' }, { name: 'republish-batch' })` -- every 6 hours
  - Wrap in try/catch (log warning if Redis unavailable)

**app.module.ts** updates:

- Import `BullModule` from `@nestjs/bullmq`:

  ```typescript
  BullModule.forRootAsync({
    imports: [ConfigModule],
    useFactory: (config: ConfigService) => ({
      connection: {
        host: config.get('REDIS_HOST', 'localhost'),
        port: config.get<number>('REDIS_PORT', 6379),
      },
    }),
    inject: [ConfigService],
  }),
  ```

- Add `IpnsRepublishSchedule` to entities array
- Import `RepublishModule`

IMPORTANT: The BullMQ connection must be configured globally in AppModule via `BullModule.forRootAsync`, and the queue registered locally in RepublishModule via `BullModule.registerQueue`.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && npx tsc --noEmit -p apps/api/tsconfig.build.json`. Start Redis (`docker compose -f docker/docker-compose.yml up -d redis`), then start the API (`pnpm --filter api dev`) and verify:

1. No startup crashes (BullMQ connects to Redis)
2. Log shows "republish-cron" job scheduler registered
3. `curl http://localhost:3000/admin/republish-health` returns JSON with `pending`, `failed`, `stale` counts (all 0)
   </verify>
   <done>
   BullMQ processor fires on 6-hour cron schedule. RepublishService orchestrates TEE signing + delegated routing publishing with batch processing and exponential backoff retry. Admin health endpoint at GET /admin/republish-health returns aggregate stats. Redis running in Docker. API starts cleanly with full republish infrastructure.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit -p apps/api/tsconfig.build.json` passes
2. Redis Docker container running and healthy
3. API starts with BullMQ connected to Redis
4. Cron job scheduler registered (visible in startup logs)
5. Health endpoint returns valid JSON at `/admin/republish-health`
6. No key material in any log statements
</verification>

<success_criteria>

- IpnsRepublishSchedule entity tracks per-folder republish state with status, retry counts, and scheduling
- BullMQ processor runs every 6 hours via cron scheduler
- Batch processing sends groups of 50 entries to TEE worker
- Exponential backoff retry for failures, entries go stale after 10 consecutive failures
- TEE signing separated from IPNS publishing for independent retry
- Admin health endpoint returns pending/failed/stale counts and TEE status
- Folder enrollment method available for Plan 03 to call during publish
  </success_criteria>

<output>
After completion, create `.planning/phases/08-tee-integration/08-02-SUMMARY.md`
</output>
