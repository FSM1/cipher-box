---
phase: 08-tee-integration
plan: 03
type: execute
wave: 2
depends_on: ['08-01']
files_modified:
  - apps/api/src/vault/vault.service.ts
  - apps/api/src/vault/dto/init-vault.dto.ts
  - apps/api/src/vault/vault.controller.ts
  - apps/api/src/vault/vault.module.ts
  - apps/api/src/ipns/ipns.service.ts
  - apps/api/src/ipns/ipns.module.ts
  - apps/web/src/hooks/useAuth.ts
  - apps/web/src/services/folder.service.ts
  - apps/web/src/services/ipns.service.ts
  - apps/web/src/stores/folder.store.ts
autonomous: true

must_haves:
  truths:
    - 'Backend returns TEE public keys in vault GET response (API-08)'
    - 'Client encrypts IPNS private key with TEE public key on folder creation'
    - 'Client sends encryptedIpnsPrivateKey and keyEpoch on first IPNS publish for each folder'
    - 'Backend auto-enrolls folders for TEE republishing when encryptedIpnsPrivateKey is provided'
    - 'Client re-publishes stale folders on login as safety net recovery path'
  artifacts:
    - path: 'apps/api/src/vault/dto/init-vault.dto.ts'
      provides: 'VaultResponseDto with teeKeys field'
      contains: 'teeKeys'
    - path: 'apps/api/src/vault/vault.service.ts'
      provides: 'Vault service returning TEE keys'
      contains: 'teeKeyStateService'
    - path: 'apps/web/src/hooks/useAuth.ts'
      provides: 'Login flow stores TEE keys in auth store'
      contains: 'setTeeKeys'
    - path: 'apps/web/src/services/folder.service.ts'
      provides: 'Folder creation encrypts IPNS key with TEE public key'
      contains: 'wrapKey.*teePublicKey'
  key_links:
    - from: 'apps/api/src/vault/vault.service.ts'
      to: 'apps/api/src/tee/tee-key-state.service.ts'
      via: 'Service injection'
      pattern: "teeKeyStateService\\.getTeeKeysDto"
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/stores/auth.store.ts'
      via: 'setTeeKeys call'
      pattern: 'setTeeKeys'
    - from: 'apps/web/src/services/folder.service.ts'
      to: '@cipherbox/crypto wrapKey'
      via: 'ECIES encryption of IPNS key'
      pattern: 'wrapKey.*ipnsPrivateKey.*teePublicKey'
    - from: 'apps/api/src/ipns/ipns.service.ts'
      to: 'apps/api/src/republish/republish.service.ts'
      via: 'enrollFolder call on publish'
      pattern: "republishService\\.enrollFolder"
---

<objective>
Wire the client-side TEE key encryption on folder publish and the backend TEE key delivery (API-08). When clients create folders, they encrypt the IPNS private key with the TEE public key and send it with the IPNS publish request. The backend auto-enrolls folders for TEE republishing.

Purpose: This completes the TEE-01/TEE-02 requirement chain -- clients encrypt IPNS keys for the TEE, and the backend enrolls folders into the republish schedule.

Output: Full client-to-backend TEE key flow, from key delivery on login to encrypted key submission on publish to automatic republish enrollment.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-tee-integration/08-CONTEXT.md
@.planning/phases/08-tee-integration/08-RESEARCH.md
@.planning/phases/08-tee-integration/08-01-SUMMARY.md
@apps/api/src/vault/vault.service.ts
@apps/api/src/vault/vault.controller.ts
@apps/api/src/vault/dto/init-vault.dto.ts
@apps/api/src/vault/vault.module.ts
@apps/api/src/ipns/ipns.service.ts
@apps/api/src/ipns/ipns.module.ts
@apps/web/src/hooks/useAuth.ts
@apps/web/src/stores/auth.store.ts
@apps/web/src/services/folder.service.ts
@apps/web/src/services/ipns.service.ts
@apps/web/src/stores/folder.store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend returns TEE keys on vault fetch and auto-enrolls on publish</name>
  <files>
    apps/api/src/vault/vault.service.ts
    apps/api/src/vault/dto/init-vault.dto.ts
    apps/api/src/vault/vault.controller.ts
    apps/api/src/vault/vault.module.ts
    apps/api/src/ipns/ipns.service.ts
    apps/api/src/ipns/ipns.module.ts
  </files>
  <action>
**VaultResponseDto** (init-vault.dto.ts) -- Add optional `teeKeys` field:
```typescript
@ApiProperty({
  description: 'TEE public keys for IPNS key encryption',
  required: false,
  nullable: true,
})
teeKeys!: {
  currentEpoch: number;
  currentPublicKey: string; // hex-encoded uncompressed secp256k1
  previousEpoch: number | null;
  previousPublicKey: string | null;
} | null;
```

**VaultService** (vault.service.ts):

- Add `TeeKeyStateService` injection to constructor. Import it from `../tee/tee-key-state.service`.
- Update `toVaultResponse(vault)` to accept an optional `teeKeys` parameter and include it in the response.
- Update `getVault(userId)` to also fetch TEE keys via `teeKeyStateService.getTeeKeysDto()` and pass them to `toVaultResponse()`.
- Update `initializeVault(userId, dto)` similarly -- return TEE keys in the response.
- Update `findVault(userId)` similarly.

**VaultModule** (vault.module.ts):

- Import `TeeModule` so that `TeeKeyStateService` is available for injection in VaultService.

**IpnsService** (ipns.service.ts) -- Auto-enroll folders for TEE republishing:

- Add injection: Import and inject `RepublishService` from `../republish/republish.service` (will need to handle circular dependency -- use `forwardRef` if needed, or import RepublishModule in IpnsModule).
- In `upsertFolderIpns()` method, after saving the folder IPNS entry:
  - If `encryptedIpnsPrivateKey` is provided and is non-null, call `republishService.enrollFolder(userId, ipnsName, Buffer.from(encryptedIpnsPrivateKey, 'hex'), keyEpoch, metadataCid, folder.sequenceNumber)`.
  - Wrap in try/catch -- log warning but don't fail the publish if enrollment fails.

**IpnsModule** (ipns.module.ts):

- Import `RepublishModule` (or use `forwardRef(() => RepublishModule)` if circular dependency) to make `RepublishService` available.
- NOTE: If circular dependency occurs between IpnsModule and RepublishModule (since RepublishModule imports FolderIpns), resolve using `forwardRef` on both sides. Alternatively, move the `enrollFolder` call to the IpnsController level where both services can be injected independently.

After making the API changes, regenerate the API client: `pnpm api:generate`. This ensures the web app gets the updated VaultResponseDto type with `teeKeys`.

IMPORTANT: The encryptedIpnsPrivateKey and keyEpoch fields in PublishIpnsDto are already optional (from Phase 5). They become required in practice now that TEE keys are available, but keep them optional in the DTO for backward compatibility.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box && npx tsc --noEmit -p apps/api/tsconfig.build.json`. Start the API and verify `GET /vault` returns a response including `teeKeys: null` (since no TEE state initialized yet). Run `pnpm api:generate` to regenerate the web client and verify the generated types include `teeKeys`.
</verify>
<done>
VaultResponseDto includes teeKeys field. VaultService returns TEE epoch keys on vault fetch. IpnsService auto-enrolls folders for TEE republishing when encrypted key provided. API client regenerated with updated types.
</done>
</task>

<task type="auto">
  <name>Task 2: Client encrypts IPNS keys with TEE public key on publish</name>
  <files>
    apps/web/src/hooks/useAuth.ts
    apps/web/src/services/folder.service.ts
    apps/web/src/services/ipns.service.ts
    apps/web/src/stores/folder.store.ts
  </files>
  <action>
**useAuth.ts** -- Store TEE keys from vault response:
- In `initializeOrLoadVault`, after successfully loading or creating a vault:
  - Check if the vault response contains `teeKeys`
  - If yes, call `useAuthStore.getState().setTeeKeys(response.teeKeys)` -- the `setTeeKeys` action already exists in auth.store.ts
  - For existing vault case: `const existingVault = await vaultApi.getVault(); if (existingVault.teeKeys) { useAuthStore.getState().setTeeKeys(existingVault.teeKeys); }`
  - For new vault case (initializeVault): same pattern after `vaultApi.initVault()` returns

**folder.service.ts** -- Encrypt IPNS key with TEE public key:

- Import `useAuthStore` from `../stores/auth.store`
- Import `hexToBytes` from `@cipherbox/crypto`
- In `createFolderEntry()` function (around line 100-150 where new folder IPNS keypairs are generated):
  - After generating the IPNS keypair (`const ipnsKeypair = await generateEd25519Keypair()`):
  - Get TEE keys: `const teeKeys = useAuthStore.getState().teeKeys`
  - If teeKeys exist and teeKeys.currentPublicKey is available:
    - `const teePublicKey = hexToBytes(teeKeys.currentPublicKey)`
    - `const encryptedIpnsKey = await wrapKey(ipnsKeypair.privateKey, teePublicKey)`
    - `const encryptedIpnsPrivateKeyHex = bytesToHex(encryptedIpnsKey)`
    - Return this along with the folder entry, so it can be passed to the IPNS publish call
  - If teeKeys are null (TEE not yet initialized), proceed without encryption (backward compatible)
- The return type of `createFolderEntry` needs to be extended to include `encryptedIpnsPrivateKey?: string` and `keyEpoch?: number`

- In every call to `updateFolderMetadata()` that creates a new folder (the first publish for a folder):
  - Pass `encryptedIpnsPrivateKey` and `keyEpoch` from the createFolderEntry result
  - These flow through to `createAndPublishIpnsRecord()` which already accepts these params

**folder.store.ts** -- Look at how `createFolder` action calls `createFolderEntry` and `updateFolderMetadata`:

- In the `createFolder` action (or wherever it is in the store), ensure the encrypted TEE key flows from createFolderEntry to the first publish call.
- The encrypted key only needs to be sent on the FIRST publish for each folder (not on every metadata update). Subsequent publishes don't need to resend it.

**IMPORTANT:** The `wrapKey` function from `@cipherbox/crypto` uses ECIES (secp256k1) -- the same function used for wrapping folder keys with the user's public key. The TEE public key is also uncompressed secp256k1 (65 bytes, 0x04 prefix), so the same function works directly.

**Client recovery path (belt-and-suspenders per CONTEXT.md):**

- This is deferred for now. The CONTEXT.md mentions "client re-publishes stale folders on next login as safety net." This would require the backend to return a list of stale folder IDs. For v1, the automatic TEE retry queue provides sufficient recovery. If needed, a future enhancement can add client-side re-publish on login.
  </action>
  <verify>
  Run `cd /Users/michael/Code/cipher-box && npx tsc --noEmit -p apps/web/tsconfig.json` to verify the web app compiles. Check that `folder.service.ts` calls `wrapKey` with the TEE public key. Verify the flow: createFolderEntry returns encrypted key -> updateFolderMetadata passes it to createAndPublishIpnsRecord -> API receives it in PublishIpnsDto.
  </verify>
  <done>
  Client receives TEE keys on login from vault response. Client encrypts IPNS private key with TEE public key during folder creation. Encrypted key sent to backend on first IPNS publish. Backend auto-enrolls folder for TEE republishing. Full TEE-01/TEE-02 requirement chain complete.
  </done>
  </task>

</tasks>

<verification>
1. `npx tsc --noEmit -p apps/api/tsconfig.build.json` passes (API)
2. `npx tsc --noEmit -p apps/web/tsconfig.json` passes (Web)
3. API client regenerated with teeKeys in VaultResponseDto
4. GET /vault response includes teeKeys field
5. folder.service.ts uses wrapKey with TEE public key for IPNS key encryption
6. IpnsService auto-enrolls folders when encryptedIpnsPrivateKey is provided
</verification>

<success_criteria>

- API-08 satisfied: Backend returns TEE public keys on login
- TEE-02 satisfied: Client encrypts IPNS private key with TEE public key before sending
- Automatic enrollment: Folders auto-enrolled for TEE republishing on first publish
- Backward compatible: Publish still works without TEE keys (teeKeys null)
- API client types updated via pnpm api:generate
  </success_criteria>

<output>
After completion, create `.planning/phases/08-tee-integration/08-03-SUMMARY.md`
</output>
