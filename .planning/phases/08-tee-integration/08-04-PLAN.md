---
phase: 08-tee-integration
plan: 04
type: execute
wave: 3
depends_on: ['08-02', '08-03']
files_modified:
  - tee-worker/package.json
  - tee-worker/tsconfig.json
  - tee-worker/src/index.ts
  - tee-worker/src/routes/republish.ts
  - tee-worker/src/routes/health.ts
  - tee-worker/src/routes/public-key.ts
  - tee-worker/src/services/ipns-signer.ts
  - tee-worker/src/services/key-manager.ts
  - tee-worker/src/services/tee-keys.ts
  - tee-worker/src/middleware/auth.ts
  - tee-worker/Dockerfile
  - tee-worker/docker-compose.yml
  - tee-worker/.env.example
autonomous: true

must_haves:
  truths:
    - 'TEE worker starts as standalone Express HTTP server'
    - 'TEE worker decrypts IPNS private keys with epoch-derived secp256k1 key'
    - 'TEE worker signs IPNS records using decrypted Ed25519 keys'
    - 'TEE worker immediately zeros IPNS private keys after signing'
    - 'TEE worker authenticates requests via shared secret'
    - 'TEE worker supports current and previous epoch for grace period decryption'
    - 'TEE worker re-encrypts old-epoch keys with current epoch during republish'
  artifacts:
    - path: 'tee-worker/src/index.ts'
      provides: 'Express server entry point'
      contains: 'app.listen'
    - path: 'tee-worker/src/routes/republish.ts'
      provides: 'POST /republish endpoint'
      contains: 'router.post.*republish'
    - path: 'tee-worker/src/services/key-manager.ts'
      provides: 'ECIES decrypt and key zeroing'
      contains: 'fill(0)'
    - path: 'tee-worker/src/services/tee-keys.ts'
      provides: 'Epoch-based key derivation'
      contains: 'getKey|getKeypair'
    - path: 'tee-worker/src/services/ipns-signer.ts'
      provides: 'IPNS record creation and signing'
      contains: 'createIPNSRecord|marshalIPNSRecord'
    - path: 'tee-worker/Dockerfile'
      provides: 'Docker image for Phala Cloud CVM'
      contains: 'dstack.sock|tappd.sock'
  key_links:
    - from: 'tee-worker/src/routes/republish.ts'
      to: 'tee-worker/src/services/key-manager.ts'
      via: 'decryptIpnsKey call'
      pattern: 'decryptIpnsKey'
    - from: 'tee-worker/src/routes/republish.ts'
      to: 'tee-worker/src/services/ipns-signer.ts'
      via: 'signIpnsRecord call'
      pattern: 'signIpnsRecord'
    - from: 'tee-worker/src/services/key-manager.ts'
      to: 'tee-worker/src/services/tee-keys.ts'
      via: 'getKeypair for epoch'
      pattern: 'getKeypair.*epoch'
---

<objective>
Build the standalone TEE worker application -- a Node.js/Express HTTP server that runs on Phala Cloud CVM. It receives encrypted IPNS private keys, decrypts them using epoch-derived keys, signs IPNS records, and returns signed records while immediately zeroing sensitive key material.

Purpose: This is the TEE (Trusted Execution Environment) component that satisfies TEE-03 -- IPNS key decryption and signing happens inside hardware-isolated confidential VM. For local development, the worker runs as a regular Node.js app with simulated key derivation (no actual TEE hardware needed).

Output: Complete tee-worker package at project root, ready for Phala Cloud CVM deployment.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-tee-integration/08-CONTEXT.md
@.planning/phases/08-tee-integration/08-RESEARCH.md
@.planning/phases/08-tee-integration/08-01-SUMMARY.md
@.planning/phases/08-tee-integration/08-02-SUMMARY.md
@.planning/phases/08-tee-integration/08-03-SUMMARY.md
@packages/crypto/src/ipns/create-record.ts
@packages/crypto/src/ipns/marshal.ts
@packages/crypto/src/ecies/decrypt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TEE worker project scaffold with key derivation and ECIES decrypt</name>
  <files>
    tee-worker/package.json
    tee-worker/tsconfig.json
    tee-worker/.env.example
    tee-worker/src/index.ts
    tee-worker/src/middleware/auth.ts
    tee-worker/src/services/tee-keys.ts
    tee-worker/src/services/key-manager.ts
    tee-worker/src/routes/health.ts
    tee-worker/src/routes/public-key.ts
  </files>
  <action>
Create `tee-worker/` directory at project root (NOT inside apps/ -- this is a separate deployable, not a pnpm workspace member).

**package.json:**

```json
{
  "name": "cipherbox-tee-worker",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "express": "^4.21.0",
    "eciesjs": "^0.4.16",
    "@noble/secp256k1": "^2.2.3",
    "@noble/ed25519": "^2.2.3",
    "@noble/hashes": "^1.7.0",
    "@libp2p/crypto": "^5.1.13",
    "ipns": "^10.1.3",
    "multiformats": "^13.3.0"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/node": "^20.19.0",
    "tsx": "^4.7.1",
    "typescript": "^5.4.2"
  }
}
```

**tsconfig.json:**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "outDir": "dist",
    "rootDir": "src",
    "declaration": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"]
}
```

**.env.example:**

```ini
PORT=3001
TEE_WORKER_SECRET=your-shared-secret-here
# Set to 'true' when running inside Phala Cloud CVM
TEE_MODE=simulator
```

**src/index.ts** - Express server entry point:

- Creates Express app with JSON body parsing (limit: '10mb' for batch requests)
- Mounts routes: `/health`, `/public-key`, `/republish`
- Applies auth middleware to `/republish` and `/public-key` routes
- Listens on `PORT` env var (default 3001)
- Logs startup message with mode (simulator vs CVM)

**src/middleware/auth.ts** - Shared secret auth:

- Express middleware function
- Reads `Authorization: Bearer <secret>` header
- Compares against `TEE_WORKER_SECRET` env var
- Returns 401 if missing or mismatched
- Skips auth check for `/health` route (health is public)

**src/services/tee-keys.ts** - Epoch-based key derivation:

- `async function getKeypair(epoch: number): Promise<{ publicKey: Uint8Array; privateKey: Uint8Array }>`
- If `TEE_MODE=simulator` (development):
  - Use HKDF-SHA256 to derive a deterministic 32-byte secp256k1 private key from a seed: `HKDF(SHA256, "cipherbox-tee-simulator-seed", salt="cipherbox-dev", info="epoch-{epoch}")`. Use `@noble/hashes` for HKDF.
  - Derive uncompressed public key from private key using `@noble/secp256k1`
  - This gives deterministic keys per epoch for development/testing
- If `TEE_MODE=cvm` (production Phala Cloud):
  - Dynamic import `@phala/dstack-sdk` (not in dependencies for simulator mode)
  - Call `new DstackClient().getKey('cipherbox/ipns-republish', 'epoch-{epoch}')`
  - Extract 32-byte private key from result `.asUint8Array().slice(0, 32)`
  - Derive public key
- IMPORTANT: Never log or return private keys. Only return public keys from the `/public-key` endpoint.
- Cache public keys per epoch in memory (Map<number, Uint8Array>) to avoid repeated derivation for the same epoch.

**src/services/key-manager.ts** - ECIES decrypt with key zeroing:

- `import { decrypt } from 'eciesjs'`
- `async function decryptIpnsKey(encryptedIpnsKey: Uint8Array, epoch: number): Promise<Uint8Array>`:
  1. Get keypair for epoch via `getKeypair(epoch)`
  2. `const ipnsPrivateKey = new Uint8Array(decrypt(keypair.privateKey, encryptedIpnsKey))`
  3. Return ipnsPrivateKey
  4. Caller is responsible for zeroing after use
- `async function decryptWithFallback(encryptedIpnsKey: Uint8Array, currentEpoch: number, previousEpoch: number | null): Promise<{ ipnsPrivateKey: Uint8Array; usedEpoch: number }>`:
  1. Try decryptIpnsKey with currentEpoch first
  2. If fails and previousEpoch is not null, try previousEpoch
  3. Return the key and which epoch succeeded
  4. If both fail, throw error
- `async function reEncryptForEpoch(ipnsPrivateKey: Uint8Array, targetEpoch: number): Promise<Uint8Array>`:
  1. Get target epoch's public key
  2. `import { encrypt } from 'eciesjs'`
  3. `const reEncrypted = new Uint8Array(encrypt(targetPublicKey, ipnsPrivateKey))`
  4. Return reEncrypted

**src/routes/health.ts** - GET /health:

- Returns `{ status: 'ok', mode: process.env.TEE_MODE || 'simulator', uptime: process.uptime() }`

**src/routes/public-key.ts** - GET /public-key?epoch=N:

- Parse `epoch` from query param (integer)
- Call `getKeypair(epoch)` and return the public key as hex
- Response: `{ epoch: number, publicKey: string (hex, 130 chars for 65 bytes) }`

Run `cd tee-worker && npm install` to install dependencies.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box/tee-worker && npx tsc --noEmit` to verify TypeScript compiles. Start the worker: `TEE_WORKER_SECRET=test TEE_MODE=simulator npx tsx src/index.ts &` and verify:

- `curl http://localhost:3001/health` returns JSON with status 'ok'
- `curl -H "Authorization: Bearer test" "http://localhost:3001/public-key?epoch=1"` returns a hex public key
- `curl http://localhost:3001/public-key?epoch=1` returns 401 (no auth)
  </verify>
  <done>
  TEE worker starts as Express server on port 3001. Health endpoint returns status. Public key endpoint returns deterministic epoch-based secp256k1 public keys. Auth middleware validates shared secret. Key manager decrypts ECIES with epoch fallback and re-encryption support.
  </done>
  </task>

<task type="auto">
  <name>Task 2: IPNS signing route and Docker deployment config</name>
  <files>
    tee-worker/src/routes/republish.ts
    tee-worker/src/services/ipns-signer.ts
    tee-worker/Dockerfile
    tee-worker/docker-compose.yml
  </files>
  <action>
**src/services/ipns-signer.ts** - IPNS record creation:
- Replicates the IPNS signing logic from `@cipherbox/crypto` but without requiring the full crypto package (standalone deployment):

```typescript
import { createIPNSRecord } from 'ipns';
import { marshalIPNSRecord } from 'ipns';
import { privateKeyFromRaw } from '@libp2p/crypto/keys';
import * as ed from '@noble/ed25519';
```

- `async function signIpnsRecord(ed25519PrivateKey: Uint8Array, cid: string, sequenceNumber: bigint): Promise<Uint8Array>`:
  1. Derive Ed25519 public key from private key: `const publicKey = await ed.getPublicKeyAsync(ed25519PrivateKey)`
  2. Create libp2p-format 64-byte key: `const libp2pKeyBytes = new Uint8Array(64); libp2pKeyBytes.set(ed25519PrivateKey, 0); libp2pKeyBytes.set(publicKey, 32);`
  3. `const libp2pPrivateKey = privateKeyFromRaw(libp2pKeyBytes)`
  4. Zero intermediate: `libp2pKeyBytes.fill(0)`
  5. Create IPNS record: `const record = await createIPNSRecord(libp2pPrivateKey, '/ipfs/' + cid, sequenceNumber, 48 * 60 * 60 * 1000, { v1Compatible: true })` -- 48h lifetime for TEE-republished records (more than enough given 6h interval)
  6. Marshal: `return marshalIPNSRecord(record)`

**src/routes/republish.ts** - POST /republish:

- Request body schema: `{ entries: Array<{ encryptedIpnsKey: string (base64), keyEpoch: number, ipnsName: string, latestCid: string, sequenceNumber: string, currentEpoch: number, previousEpoch: number | null }> }`
- For each entry:
  1. Decode encryptedIpnsKey from base64 to Uint8Array
  2. Call `decryptWithFallback(encryptedIpnsKey, entry.currentEpoch, entry.previousEpoch)`
  3. Sign IPNS record: `const signedRecord = await signIpnsRecord(ipnsPrivateKey, entry.latestCid, BigInt(entry.sequenceNumber) + 1n)`
  4. If decryption used previous epoch (not current), re-encrypt for current: `const upgradedKey = await reEncryptForEpoch(ipnsPrivateKey, entry.currentEpoch)`
  5. IMMEDIATELY zero the IPNS private key: `ipnsPrivateKey.fill(0)`
  6. Build result: `{ ipnsName, success: true, signedRecord: base64(signedRecord), newSequenceNumber: (BigInt(entry.sequenceNumber) + 1n).toString() }`
  7. If re-encrypted: add `upgradedEncryptedKey: base64(upgradedKey)` and `upgradedKeyEpoch: entry.currentEpoch`
- Catch errors per-entry (one failure should not block others):
  - `{ ipnsName, success: false, error: error.message }` -- never include key material in error messages
- Response: `{ results: [...] }`
- IMPORTANT: The `currentEpoch` and `previousEpoch` come from the CipherBox backend (which reads them from tee_key_state). This allows the TEE worker to be stateless regarding epoch management.
- Log processing summary: total entries, successes, failures, epochs used. NEVER log key material.

**Dockerfile** - For Phala Cloud CVM deployment:

```dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm ci --production

COPY dist/ ./dist/

ENV NODE_ENV=production
ENV TEE_MODE=cvm
ENV PORT=3001

EXPOSE 3001

CMD ["node", "dist/index.js"]
```

**docker-compose.yml** - For Phala Cloud CVM:

```yaml
version: '3.8'
services:
  tee-worker:
    build: .
    volumes:
      - /var/run/tappd.sock:/var/run/tappd.sock
    ports:
      - '3001:3001'
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - PORT=3001
      - TEE_MODE=cvm
      - TEE_WORKER_SECRET=${TEE_WORKER_SECRET}
```

After creating all files, run `cd /Users/michael/Code/cipher-box/tee-worker && npm install` if not already done.
</action>
<verify>
Run `cd /Users/michael/Code/cipher-box/tee-worker && npx tsc --noEmit` to verify TypeScript compiles.

Integration test (manual verification in simulator mode):

1. Start the TEE worker: `cd /Users/michael/Code/cipher-box/tee-worker && TEE_WORKER_SECRET=test TEE_MODE=simulator npx tsx src/index.ts &`
2. Get the public key for epoch 1: `curl -s -H "Authorization: Bearer test" "http://localhost:3001/public-key?epoch=1"` -- save the publicKey hex
3. Generate a test encrypted IPNS key using node:

   ```bash
   cd /Users/michael/Code/cipher-box && node -e "
     const { encrypt } = require('eciesjs');
     const { getPublicKey } = require('@noble/secp256k1');
     const crypto = require('crypto');
     // Simulate: encrypt a random 32-byte Ed25519 key with TEE public key
     const teePublicKeyHex = '<paste public key from step 2>';
     const teePublicKey = Buffer.from(teePublicKeyHex, 'hex');
     const fakeIpnsKey = crypto.randomBytes(32);
     const encrypted = encrypt(teePublicKey, fakeIpnsKey);
     console.log(encrypted.toString('base64'));
   "
   ```

4. Call republish with the encrypted key from step 3 and verify success response with signed record.
5. Kill the background TEE worker process.

If the integration test is too complex to automate, at minimum verify TypeScript compiles and the server starts.
</verify>
<done>
TEE worker republish endpoint receives encrypted IPNS keys, decrypts with epoch key, signs IPNS records, zeros key material, returns signed records. Supports epoch fallback and re-encryption for key rotation. Dockerfile and docker-compose.yml ready for Phala Cloud CVM deployment. Worker runs in simulator mode for local development.
</done>
</task>

</tasks>

<verification>
1. `cd tee-worker && npx tsc --noEmit` passes
2. TEE worker starts in simulator mode
3. Health endpoint returns ok
4. Public key endpoint returns valid secp256k1 key per epoch
5. Republish endpoint decrypts, signs, and returns results
6. Key material is zeroed after each entry (verified by code inspection)
7. Dockerfile builds successfully
</verification>

<success_criteria>

- TEE-03 satisfied: TEE decrypts key in hardware (simulated), signs record, immediately zeros memory
- Standalone deployable: tee-worker runs independently from the NestJS backend
- Epoch-aware: Supports current + previous epoch with fallback and re-encryption
- Secure: Shared secret auth, no key material in logs or error messages
- Phala Cloud ready: Dockerfile mounts tappd.sock, docker-compose.yml for CVM deployment
- Simulator mode: Works locally without Phala hardware for development and testing
  </success_criteria>

<output>
After completion, create `.planning/phases/08-tee-integration/08-04-SUMMARY.md`
</output>
