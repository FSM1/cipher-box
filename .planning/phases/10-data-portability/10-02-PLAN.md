---
phase: 10-data-portability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/public/recovery.html
autonomous: true

must_haves:
  truths:
    - 'User can load a vault export JSON file into the recovery tool'
    - 'User can provide their private key via paste or file upload'
    - 'Tool ECIES-decrypts root keys using the provided private key'
    - 'Tool resolves IPNS names via public gateways without CipherBox infrastructure'
    - 'Tool recursively traverses folder hierarchy decrypting metadata'
    - 'Tool downloads and decrypts all files'
    - 'Tool delivers a zip file preserving folder structure'
    - 'Recovery tool works as a single static HTML file with no server dependencies'
  artifacts:
    - path: 'apps/web/public/recovery.html'
      provides: 'Standalone recovery tool'
      min_lines: 300
      contains: 'cipherbox-vault-export'
  key_links:
    - from: 'recovery.html'
      to: 'CDN noble-curves'
      via: 'ESM import from jsdelivr'
      pattern: 'cdn.jsdelivr.net/npm/@noble/curves'
    - from: 'recovery.html'
      to: 'CDN noble-hashes'
      via: 'ESM import from jsdelivr'
      pattern: 'cdn.jsdelivr.net/npm/@noble/hashes'
    - from: 'recovery.html ECIES decrypt'
      to: 'eciesjs@0.4.16 format'
      via: 'byte layout: ephemeralPK(65) || nonce(16) || tag(16) || ciphertext(N)'
      pattern: "slice\\(0,\\s*65\\)"
    - from: 'recovery.html AES-GCM'
      to: 'Web Crypto API'
      via: 'crypto.subtle.decrypt'
      pattern: "crypto\\.subtle\\.decrypt"
---

<objective>
Build the standalone vault recovery HTML page that allows users to recover their entire vault independently of CipherBox infrastructure.

Purpose: This is the core of PORT-03 (export format is publicly documented) and the recovery mechanism for PORT-01/PORT-02. The tool proves CipherBox's data sovereignty promise: users can recover all their files using only their export JSON, their private key, and public IPFS gateways.

Output: A single `recovery.html` file placed in `apps/web/public/` (accessible at the web app root). The file is self-contained: embedded CSS and JS, with only CDN imports for crypto libraries.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-data-portability/10-CONTEXT.md
@.planning/phases/10-data-portability/10-RESEARCH.md

@packages/crypto/src/ecies/decrypt.ts
@packages/crypto/src/aes/decrypt.ts
@packages/crypto/src/folder/metadata.ts
@packages/crypto/src/folder/types.ts
@packages/crypto/src/utils/encoding.ts
@packages/crypto/src/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Standalone recovery HTML page</name>
  <files>apps/web/public/recovery.html</files>
  <action>
Create `apps/web/public/recovery.html` as a single self-contained HTML file with embedded CSS and JavaScript. This is the most critical deliverable of Phase 10.

**HTML Structure (guided walkthrough with 4 steps):**

Step 1 -- Load Export: File input for vault export JSON (accept=".json") OR textarea for paste. "Load Export" button. Validates `format === "cipherbox-vault-export"` and `version === "1.0"`. On success: shows parsed fields (rootIpnsName, derivationInfo if present), advances to step 2.

Step 2 -- Provide Private Key: Textarea for hex or base64 private key paste OR file input for key file. Auto-detect format: if 64 hex chars -> hex, if ~44 chars with base64 alphabet -> base64. "Decrypt Keys" button. On click: ECIES-decrypt both `encryptedRootFolderKey` and `encryptedRootIpnsPrivateKey`. Show derivation hint from export (if present). On success: shows "Root keys decrypted successfully", advances to step 3.

Step 3 -- Configure Gateway: Pre-filled gateway URL `https://delegated-ipfs.dev` for IPNS resolution. Pre-filled IPFS gateway `https://ipfs.io` for content fetch. Alternative suggestions listed: `dweb.link`, `cloudflare-ipfs.com`. User can override both fields. "Start Recovery" button.

Step 4 -- Recovery Progress: Shows live progress log (terminal-style dark background, monospace text). Steps logged: "Resolving root IPNS...", "Fetching root metadata...", "Decrypting root folder...", for each subfolder: "Resolving {name}...", for each file: "Downloading {name}...". Error handling: show errors inline with retry option per step. On complete: "Recovery complete. {N} files recovered." + download button. Downloads a zip file preserving folder structure.

**CSS (embedded in style tag):** Dark terminal aesthetic (dark background, green/white monospace text). Simple, clean layout. Single column centered, max-width 700px. Step indicators (1/2/3/4) with active/complete/pending states. Progress log area with scrollable pre/code block. Responsive for mobile.

**JavaScript (embedded in script type="module"):**

CDN imports (ESM from jsdelivr):

```javascript
import { secp256k1 } from 'https://cdn.jsdelivr.net/npm/@noble/curves@1/secp256k1/+esm';
import { hkdf } from 'https://cdn.jsdelivr.net/npm/@noble/hashes@1/hkdf/+esm';
import { sha256 } from 'https://cdn.jsdelivr.net/npm/@noble/hashes@1/sha2/+esm';
import { concatBytes } from 'https://cdn.jsdelivr.net/npm/@noble/hashes@1/utils/+esm';
```

For zip creation, use fflate UMD loaded via a non-module script tag (before the module script) from `https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js`, which sets `window.fflate`.

**Critical crypto implementations:**

A) `eciesDecrypt(privateKeyBytes, encryptedHex)` -- MUST match eciesjs@0.4.16 exactly: Parse hex to bytes. Extract ephemeral public key: bytes[0:65] (uncompressed, 0x04 prefix). Extract nonce: bytes[65:81] (16 bytes -- NOT 12!). Extract tag: bytes[81:97] (16 bytes). Extract ciphertext: bytes[97:]. Compute ECDH shared point: `secp256k1.getSharedSecret(privateKeyBytes, ephemeralPK, false)` -- uncompressed. Compute IKM: `concatBytes(ephemeralPK, sharedPoint)` -- sender point is ephemeral PK. Derive key: `hkdf(sha256, ikm, undefined, undefined, 32)` -- no salt, no info. Decrypt: Use Web Crypto `crypto.subtle.decrypt({name: 'AES-GCM', iv: nonce}, key, concat(ciphertext, tag))`. Note: Web Crypto expects ciphertext||tag concatenated, but eciesjs stores nonce||tag||ciphertext. Reconstruct as ciphertext||tag.

B) `decryptFolderMetadata(encryptedJson, folderKey)` -- matches @cipherbox/crypto: `encryptedJson` = `{ iv: "hex", data: "base64" }`. IV: `hexToBytes(encryptedJson.iv)` (12 bytes). Ciphertext: `base64ToBytes(encryptedJson.data)` (includes 16-byte auth tag appended). Decrypt: `crypto.subtle.decrypt({name: 'AES-GCM', iv}, key, ciphertext)`. Parse result as JSON: `JSON.parse(new TextDecoder().decode(plaintext))`.

C) `decryptFile(encryptedBytes, fileKey, fileIvHex)` -- matches @cipherbox/crypto: IV: `hexToBytes(fileIvHex)` (12 bytes). Decrypt: `crypto.subtle.decrypt({name: 'AES-GCM', iv}, key, encryptedBytes)`.

D) IPNS resolution `resolveIpns(ipnsName, gatewayUrl)`: Primary: `GET ${gatewayUrl}/routing/v1/ipns/${ipnsName}` (delegated routing). Parse the response to extract the IPNS record value (CID). The delegated routing API returns a JSON response with records. Parse the record to extract the CID value. Fallback: try `https://ipfs.io/api/v0/name/resolve?arg=${ipnsName}` if primary fails. Retry with exponential backoff (3 attempts). IMPORTANT: The IPNS record value from delegated routing is the CID path (e.g., `/ipfs/bafy...`). Extract just the CID part.

E) IPFS content fetch `fetchFromIpfs(cid, ipfsGatewayUrl)`: `GET ${ipfsGatewayUrl}/ipfs/${cid}`. Return as ArrayBuffer. Retry with exponential backoff (3 attempts).

F) Recursive folder traversal `recoverFolder(ipnsName, folderKey, path, gatewayConfig)`: Resolve IPNS name -> get CID. Fetch encrypted metadata from IPFS by CID. Parse as JSON (the encrypted metadata format: `{ iv, data }`). Decrypt with folderKey using `decryptFolderMetadata`. For each child of type "folder": ECIES-decrypt `folderKeyEncrypted` and `ipnsPrivateKeyEncrypted` (the ipnsPrivateKey is 64-byte libp2p format = seed||pubkey, we only need it for name verification not for signing). Then recurse. For each child of type "file": ECIES-decrypt `fileKeyEncrypted`, fetch encrypted file from IPFS by `cid`, decrypt with file key and `fileIv`. Add to zip. Build zip entries with path-preserving names (e.g., `Documents/photo.jpg`).

G) Zip creation and download: Use `fflate.zipSync()` to create zip from collected files. Trigger download as `cipherbox-recovery-YYYY-MM-DD.zip`.

**Utility functions (embedded):** `hexToBytes(hex)` -- standard hex decoder. `bytesToHex(bytes)` -- standard hex encoder. `base64ToBytes(b64)` -- decode base64 to Uint8Array using `atob()`. `log(message)` -- append to progress log element.

**Error handling:** Each step catches errors and shows them inline. ECIES decryption failure: "Failed to decrypt keys. Make sure you are using the correct private key." IPNS resolution failure: "Failed to resolve IPNS name. Try a different gateway or check if the record is still published." Individual file failures: log the error but continue recovering other files.

**Security notes in the UI:** Header area shows a brief explanation: "This tool recovers your CipherBox vault using only your export file and private key. It connects directly to public IPFS gateways -- no CipherBox servers are contacted." After recovery: "Your private key was used in-memory only and is not stored or transmitted."
</action>
<verify>
Open `apps/web/public/recovery.html` directly in a browser (file:// protocol or via `python3 -m http.server` in that directory). Verify: Page loads without JS errors in console. CDN imports resolve (noble-curves, noble-hashes, fflate). Step 1 file input and textarea render correctly. Step navigation works (steps show/hide). CSS renders dark terminal aesthetic. Additionally, verify that `pnpm --filter web build` still succeeds (static file in public/ should be copied as-is).
</verify>
<done>
A single `recovery.html` file exists in `apps/web/public/` that implements the complete vault recovery flow: load export JSON, provide private key, ECIES-decrypt root keys, resolve IPNS, traverse folders, decrypt files, download as zip. No CipherBox server dependencies. Works from file:// or any static host.
</done>
</task>

</tasks>

<verification>

1. `recovery.html` is a single file with no external dependencies except CDN-loaded crypto libraries
2. ECIES decrypt matches eciesjs@0.4.16 byte format (65-byte ephemeral PK, 16-byte nonce, 16-byte tag, ciphertext)
3. AES-256-GCM decrypt matches @cipherbox/crypto format (12-byte IV for folders/files)
4. IPNS resolution uses public gateways (delegated-ipfs.dev, ipfs.io), not CipherBox API
5. Zip download preserves folder hierarchy
6. `pnpm --filter web build` succeeds

</verification>

<success_criteria>

- recovery.html loads in browser without errors
- CDN imports for noble-curves, noble-hashes, fflate resolve
- UI shows 4-step guided walkthrough
- ECIES decrypt function correctly parses eciesjs@0.4.16 binary format (16-byte nonce, not 12)
- Folder metadata decryption handles { iv: hex, data: base64 } format
- File decryption uses correct IV format
- No fetch calls to any CipherBox backend URL

</success_criteria>

<output>
After completion, create `.planning/phases/10-data-portability/10-02-SUMMARY.md`
</output>
