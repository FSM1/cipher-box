---
phase: 11.2-remove-v1-folder-metadata
plan: 03
type: execute
wave: 2
depends_on: ['11.2-01', '11.2-02']
files_modified:
  - apps/desktop/src-tauri/src/fuse/operations.rs
  - apps/desktop/src-tauri/src/fuse/mod.rs
  - apps/desktop/src-tauri/src/fuse/inode.rs
  - apps/web/public/recovery.html
autonomous: true

must_haves:
  truths:
    - 'Desktop FUSE create() derives a file IPNS keypair from user privateKey + fileId via HKDF'
    - "Desktop FUSE release() publishes per-file FileMetadata to the file's own IPNS record after upload"
    - 'build_folder_metadata never produces FilePointer with empty file_meta_ipns_name'
    - 'Recovery tool handles only v2 FilePointer path -- v1 inline FileEntry branch removed'
    - 'All tests pass: pnpm test and cargo test --features fuse'
  artifacts:
    - path: 'apps/desktop/src-tauri/src/fuse/operations.rs'
      provides: 'create() with HKDF file IPNS derivation, release() with FileMetadata publish'
      contains: 'derive_file_ipns_keypair'
    - path: 'apps/web/public/recovery.html'
      provides: 'v2-only recovery tool'
  key_links:
    - from: 'apps/desktop/src-tauri/src/fuse/operations.rs create()'
      to: 'apps/desktop/src-tauri/src/crypto/hkdf.rs'
      via: 'derive_file_ipns_keypair(private_key, file_id)'
      pattern: 'derive_file_ipns_keypair'
    - from: 'apps/desktop/src-tauri/src/fuse/operations.rs release()'
      to: 'apps/desktop/src-tauri/src/crypto/folder.rs'
      via: 'encrypt_file_metadata'
      pattern: 'encrypt_file_metadata'
---

<objective>
Add per-file IPNS publishing to desktop FUSE create/release, update recovery tool to v2-only, and run full cross-platform verification.

Purpose: Desktop currently creates files without IPNS keypair derivation, meaning build_folder_metadata would produce FilePointers with empty ipns names. This plan completes the desktop's per-file IPNS support (matching the web app) and cleans up the last v1 remnant in recovery.html.

Output: Desktop FUSE derives file IPNS keypairs on create, publishes FileMetadata on release, and recovery tool handles only v2 format.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.2-remove-v1-folder-metadata/GOAL.md
@.planning/phases/11.2-remove-v1-folder-metadata/11.2-01-SUMMARY.md
@.planning/phases/11.2-remove-v1-folder-metadata/11.2-02-SUMMARY.md
@apps/desktop/src-tauri/src/fuse/operations.rs
@apps/desktop/src-tauri/src/fuse/mod.rs
@apps/desktop/src-tauri/src/crypto/hkdf.rs
@apps/web/public/recovery.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-file IPNS derivation in create() and FileMetadata publish in release()</name>
  <files>
    apps/desktop/src-tauri/src/fuse/operations.rs
    apps/desktop/src-tauri/src/fuse/mod.rs
    apps/desktop/src-tauri/src/fuse/inode.rs
  </files>
  <action>
**Desktop FUSE `create()` callback** (in operations.rs):

When a new file is created via FUSE create(), the desktop currently:

1. Creates a new inode with InodeKind::File { cid: "", file_meta_ipns_name: None, ... }
2. Opens a temp file for writes

After Plan 02, build_folder_metadata emits FilePointer which needs `file_meta_ipns_name`. So create() must derive this upfront.

Add to create() after the inode is allocated:

1. Generate a fileId for the new file (UUID v4, same as `uuid_from_ino(ino)` -- use this directly)
2. Call `crate::crypto::hkdf::derive_file_ipns_keypair(&self.private_key, &file_id)` to get `(ipns_private_key, ipns_public_key, ipns_name)`
3. Store `file_meta_ipns_name: Some(ipns_name.clone())` in the InodeKind::File
4. Store the file IPNS private key somewhere accessible to release(). Options:
   - Add a new field to InodeKind::File: `file_ipns_private_key: Option<Vec<u8>>`
   - Or store in a HashMap<u64, Vec<u8>> on CipherBoxFS keyed by ino
   - Preferred: Add `file_ipns_private_key: Option<Zeroizing<Vec<u8>>>` to InodeKind::File (matches how folder IPNS keys are stored)

In `apps/desktop/src-tauri/src/fuse/inode.rs`, update `InodeKind::File`:

- Add field: `file_ipns_private_key: Option<Zeroizing<Vec<u8>>>` (import Zeroizing)
- Update ALL places that construct InodeKind::File to include this field (set to None for files loaded from remote metadata, set to Some for newly created files)

**Desktop FUSE `release()` callback** (in operations.rs):

After the file content is uploaded to IPFS (the existing upload_tx/spawn_upload flow), the release must also publish a FileMetadata IPNS record.

The current flow in release():

1. Read temp file contents
2. Encrypt with AES-GCM (or CTR for media)
3. Upload encrypted blob to IPFS -> new_cid
4. Send UploadComplete via upload_tx
5. Queue parent folder for debounced metadata publish

Add after step 3 (inside the upload thread/spawn, after getting new_cid): 6. Build a `FileMetadata` struct:

```rust
FileMetadata {
    version: "v1".to_string(), // per-file IPNS schema version, NOT folder schema
    cid: new_cid.clone(),
    file_key_encrypted: encrypted_file_key.clone(),
    file_iv: iv_hex.clone(),
    size: original_size,
    mime_type: mime_type.clone(), // detect from filename extension
    encryption_mode: encryption_mode.clone(),
    created_at: now_ms,
    modified_at: now_ms,
}
```

7. Get the parent folder's folder_key (needed to encrypt FileMetadata -- file metadata is encrypted with parent folder key, NOT the file's own key)
8. Call `encrypt_file_metadata(&file_metadata, &folder_key)` to get sealed bytes
9. Wrap the sealed bytes in the JSON envelope format: `{ "iv": "<hex>", "data": "<base64>" }` (matching the TypeScript EncryptedFileMetadata format)
10. Upload the encrypted file metadata to IPFS -> file_meta_cid
11. Create IPNS record for the file: sign with file_ipns_private_key, publish via API
12. If IPNS publish fails, log warning but don't fail the upload (non-blocking, same as folder publishes)

**MIME type detection:** Use the file extension to determine MIME type. A simple match on common extensions is sufficient:

- `.jpg`/`.jpeg` -> `image/jpeg`, `.png` -> `image/png`, `.pdf` -> `application/pdf`
- `.mp4` -> `video/mp4`, `.mp3` -> `audio/mpeg`, `.txt` -> `text/plain`
- Default: `application/octet-stream`

**Important details:**

- `FileMetadata.version` is `"v1"` -- this is the per-file IPNS record schema version, completely separate from the folder metadata version. Do NOT change this.
- The `file_key_encrypted` in FileMetadata is the ECIES-wrapped file key (same hex string stored in the inode). It's encrypted with the user's public key.
- The `file_iv` is the hex-encoded AES IV.
- The FileMetadata is encrypted with the parent folder's folder_key (not the file's own key). This matches the web app behavior.
- Use `encrypt_file_metadata()` which does JSON serialize + AES-GCM seal. Then wrap in `{ "iv": hex(first_12_bytes), "data": base64(rest) }` -- wait, actually `encrypt_file_metadata` returns sealed bytes (iv||ciphertext||tag). You need to extract iv (first 12 bytes) and ciphertext+tag (rest), then build the JSON envelope. Look at how `encrypt_metadata_to_json()` in mod.rs does it for folder metadata -- follow the same pattern.

**For file replacement (re-upload):** The release() code already handles overwriting existing files. The same IPNS publish logic applies -- derive the same file IPNS keypair (deterministic from privateKey + fileId), publish updated FileMetadata. The IPNS sequence number will increment.

**Threading concern:** The file IPNS publish should happen in the same background thread as the file upload (inside the spawned thread in release). It should NOT block the FUSE thread. Use the same tokio runtime handle.
</action>
<verify>
Run `cargo check --manifest-path apps/desktop/src-tauri/Cargo.toml --features fuse` -- compiles.
Run `cargo test --manifest-path apps/desktop/src-tauri/Cargo.toml --features fuse` -- all tests pass.
Grep: `grep -n "derive_file_ipns_keypair" apps/desktop/src-tauri/src/fuse/operations.rs` -- confirms HKDF derivation in create().
Grep: `grep -n "encrypt_file_metadata" apps/desktop/src-tauri/src/fuse/` -- confirms publish in release() flow.
</verify>
<done>
Desktop FUSE create() derives file IPNS keypair via HKDF and stores it on the inode. release() publishes per-file FileMetadata IPNS record after upload. build_folder_metadata produces FilePointer with valid file_meta_ipns_name for all files. cargo test passes.
</done>
</task>

<task type="auto">
  <name>Task 2: Update recovery tool to v2-only and run full cross-platform verification</name>
  <files>
    apps/web/public/recovery.html
  </files>
  <action>
**`apps/web/public/recovery.html`:**

Find the folder processing section that branches on `isV2` (around line 842):

Current code has:

```javascript
const isV2 = metadata.version === 'v2';
// ...
if (child.type === 'file' && isV2 && child.fileMetaIpnsName) {
  // v2 FilePointer path
} else if (child.type === 'file') {
  // v1 inline FileEntry path
}
```

Replace with v2-only logic:

1. Remove the `isV2` variable and check
2. Remove the v1 inline FileEntry branch entirely (the `else if` that handles `child.cid`, `child.fileKeyEncrypted`, `child.fileIv`)
3. For file children, ONLY handle the FilePointer path (resolve per-file IPNS to get FileMetadata)
4. Add a validation check: if `child.type === 'file'` and `child.fileMetaIpnsName` is missing, log error "Invalid file child: missing fileMetaIpnsName (v1 format not supported)" and increment errorCount
5. Update the log message: remove "(v2 schema)" annotation since there's only one schema now

Also update the version check at the start of folder processing:

- If `metadata.version !== 'v2'`, log error "Unsupported metadata version: {version} (only v2 supported)" and skip this folder (don't crash, just warn and continue to next folder)

**Cross-platform verification (commands to run):**

After all changes, run the full test suite:

```bash
# TypeScript crypto package
pnpm --filter @cipherbox/crypto test

# Web app type check and build
pnpm --filter web typecheck
pnpm --filter web build

# Desktop Rust
cargo test --manifest-path apps/desktop/src-tauri/Cargo.toml --features fuse
```

Also do a final grep sweep to confirm no v1 remnants:

```bash
# Should return ZERO results (excluding node_modules, target, dist)
grep -r "FolderMetadataV2\|FolderChildV2\|AnyFolderMetadata\|isV2Metadata" \
  packages/crypto/src/ apps/web/src/ apps/desktop/src-tauri/src/ \
  apps/web/public/recovery.html \
  --include="*.ts" --include="*.tsx" --include="*.rs" --include="*.html"

# FileEntry only in Rust (file-level, not folder-level) -- should return zero
grep -r "FileEntry" packages/crypto/src/ apps/web/src/ apps/desktop/src-tauri/src/ \
  --include="*.ts" --include="*.tsx" --include="*.rs" | grep -v "node_modules" | grep -v "target"
```

  </action>
  <verify>
1. `pnpm --filter @cipherbox/crypto test` -- all tests pass
2. `pnpm --filter web typecheck && pnpm --filter web build` -- passes
3. `cargo test --manifest-path apps/desktop/src-tauri/Cargo.toml --features fuse` -- passes
4. Grep sweep for v1 type remnants returns zero results: `grep -r "FolderMetadataV2\|FolderChildV2\|AnyFolderMetadata\|isV2Metadata\|isV2\b" packages/crypto/src/ apps/web/src/ apps/desktop/src-tauri/src/ apps/web/public/recovery.html --include="*.ts" --include="*.tsx" --include="*.rs" --include="*.html"`
5. `grep -c "fileMetaIpnsName" apps/web/public/recovery.html` returns at least 1 (v2 path exists)
6. Verify no v1 branching in recovery.html: `grep -P "isV2\b|const isV2|else if.*child\.type.*file" apps/web/public/recovery.html` returns 0 results
  </verify>
  <done>
Recovery tool handles only v2 FilePointer path. All tests pass across TypeScript and Rust. No v1 remnants in any source file. Phase 11.2 success criteria fully met.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @cipherbox/crypto test` passes
2. `pnpm --filter web typecheck` passes
3. `pnpm --filter web build` succeeds
4. `cargo test --manifest-path apps/desktop/src-tauri/Cargo.toml --features fuse` passes
5. Zero grep results for v1 remnants across all source files
6. recovery.html has no v1/v2 branching
7. Desktop create() uses derive_file_ipns_keypair
8. Desktop release() publishes FileMetadata IPNS record
</verification>

<success_criteria>

- Desktop FUSE create() derives file IPNS keypair via HKDF from privateKey + fileId
- Desktop FUSE release() encrypts and publishes per-file FileMetadata to file's IPNS record
- build_folder_metadata produces FilePointer with valid file_meta_ipns_name for ALL files
- Recovery tool processes only v2 FilePointer children (v1 inline path deleted)
- Recovery tool rejects non-v2 metadata with clear error message
- All 8 success criteria from GOAL.md are satisfied
- Full test suite passes: pnpm test + cargo test --features fuse
  </success_criteria>

<output>
After completion, create `.planning/phases/11.2-remove-v1-folder-metadata/11.2-03-SUMMARY.md`
</output>
