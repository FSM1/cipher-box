# Phase 12.4: MFA + Cross-Device Approval - Research

**Researched:** 2026-02-15
**Domain:** Web3Auth MPC Core Kit MFA, cross-device factor transfer, bulletin board API
**Confidence:** HIGH (Core Kit APIs verified from source code + type declarations in node_modules)

## Summary

Phase 12.4 adds MFA enrollment, recovery phrase backup, cross-device approval, and factor management to CipherBox. The implementation builds on the existing Web3Auth MPC Core Kit v3.5.0 integration (Phase 12), the encrypted device registry on IPFS (Phase 12.2), and the identity cleanup from Phase 12.3.1.

The Core Kit SDK provides a complete factor management API: `enableMFA()` creates a device factor + recovery factor in one call, `createFactor()` adds additional factors, `inputFactorKey()` handles recovery/device approval on new devices, and `deleteFactor()` removes factors. The SDK's `COREKIT_STATUS.REQUIRED_SHARE` status (already wired in the provider) signals when a new device needs a factor before login completes. The TSS private key does NOT change when MFA is enabled -- factor keys are wrappers around TSS share fragments, not the key itself.

The cross-device approval flow requires a new bulletin board API on the CipherBox backend (3 endpoints) and an ECIES ephemeral key exchange using the existing `eciesjs` library in `@cipherbox/crypto`. The existing device registry (Phase 12.2) already stores per-device Ed25519 public keys needed for the key exchange.

**Primary recommendation:** Use the Core Kit SDK's built-in `enableMFA()` and `keyToMnemonic()` for the enrollment wizard, implement `REQUIRED_SHARE` handling in the existing auth flow for recovery/approval, and build a thin bulletin board REST API with 5-minute TTL for cross-device factor transfer.

## Standard Stack

### Core (already installed)

| Library                  | Version | Purpose                                                                     | Why Standard                                                 |
| ------------------------ | ------- | --------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `@web3auth/mpc-core-kit` | ^3.5.0  | MFA factor management (`enableMFA`, `createFactor`, `inputFactorKey`, etc.) | Already integrated; provides complete MFA lifecycle          |
| `bn.js`                  | ^5.2.1  | Big Number for factor keys                                                  | Transitive dep of mpc-core-kit; factor keys are BN instances |
| `eciesjs`                | ^0.4.16 | ECIES encryption for cross-device key exchange                              | Already used in `@cipherbox/crypto` for vault key wrapping   |
| `@noble/secp256k1`       | ^2.2.3  | secp256k1 operations for factor key public key derivation                   | Already used in web3auth hooks                               |

### Supporting (no new dependencies needed)

| Library   | Version  | Purpose                                          | When to Use                                 |
| --------- | -------- | ------------------------------------------------ | ------------------------------------------- |
| `zustand` | existing | MFA state store (enrollment status, factor list) | New `mfa.store.ts` for MFA-related UI state |
| `typeorm` | existing | Bulletin board entity for approval requests      | New `DeviceApproval` entity in API          |

**No new npm packages required.** All needed functionality exists in current dependencies.

### Exports from `@web3auth/mpc-core-kit` to use

```typescript
import {
  COREKIT_STATUS,
  generateFactorKey,
  keyToMnemonic,
  mnemonicToKey,
  TssShareType,
  FactorKeyTypeShareDescription,
} from '@web3auth/mpc-core-kit';
import BN from 'bn.js';
```

## Architecture Patterns

### Recommended Project Structure (new files)

```text
apps/web/src/
  components/
    mfa/
      MfaEnrollmentWizard.tsx    # Step-by-step enrollment (Settings > Security)
      MfaEnrollmentPrompt.tsx    # Post-login dismissable prompt
      RecoveryPhraseGrid.tsx     # 4-column, 24-word numbered grid
      DeviceApprovalModal.tsx    # Approval dialog on existing device
      DeviceWaitingScreen.tsx    # Full-screen waiting on new device
      SecurityTab.tsx            # Settings > Security tab content
      AuthorizedDevices.tsx      # Device list with revoke actions
      RecoveryPhraseSection.tsx  # Recovery phrase management in Settings
  hooks/
    useMfa.ts                   # Core Kit MFA operations wrapper
    useDeviceApproval.ts        # Bulletin board polling + approval logic
  stores/
    mfa.store.ts                # MFA state: enrolled, factor count, etc.
  services/
    device-approval.service.ts  # Bulletin board API client

apps/api/src/
  device-approval/
    device-approval.module.ts
    device-approval.controller.ts
    device-approval.service.ts
    device-approval.entity.ts
    dto/
      create-approval.dto.ts
      respond-approval.dto.ts
```

### Pattern 1: Core Kit MFA Enrollment Flow

**What:** The complete MFA enablement sequence using `enableMFA()`.
**When to use:** When user clicks "Enable MFA" in Settings or responds to first-login prompt.

```typescript
// Source: mpc-core-kit@3.5.0 source code + official examples
import {
  generateFactorKey,
  keyToMnemonic,
  TssShareType,
  FactorKeyTypeShareDescription,
  COREKIT_STATUS,
} from '@web3auth/mpc-core-kit';

async function enrollMfa(coreKit: Web3AuthMPCCoreKit): Promise<string> {
  // IMPORTANT: commitChanges MUST be called before enableMFA if manualSync is true
  if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
    await coreKit.commitChanges();
  }

  // enableMFA() does ALL of the following atomically:
  // 1. Creates a DEVICE factor and stores it in localStorage
  // 2. Sets device factor as the active factor via inputFactorKey
  // 3. Deletes the "hashed factor key" (cloud custodial key)
  // 4. Creates a RECOVERY factor (if recoveryFactor=true, which is default)
  // 5. Returns the recovery factor key as hex string
  //
  // After this, the account is 2/3 threshold (device + recovery + social/cloud)
  const backupFactorKeyHex = await coreKit.enableMFA({});

  // Convert the recovery factor key to a 24-word BIP39 mnemonic
  const mnemonic = keyToMnemonic(backupFactorKeyHex);

  // Commit the changes
  if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
    await coreKit.commitChanges();
  }

  return mnemonic; // Display to user in the wizard
}
```

**Critical:** `enableMFA()` is idempotent-safe -- calling it when MFA is already enabled throws `CoreKitError.mfaAlreadyEnabled()`. Check with `getKeyDetails()` first.

### Pattern 2: REQUIRED_SHARE Handling (New Device Login)

**What:** When a user logs in on a new device without a device factor, Core Kit enters `REQUIRED_SHARE` status. The app must provide a factor key to complete login.
**When to use:** After `loginWithJWT()` when `coreKit.status === COREKIT_STATUS.REQUIRED_SHARE`.

```typescript
// Source: mpc-core-kit@3.5.0 interfaces.d.ts + source code
import BN from 'bn.js';

// Currently in hooks.ts, loginWithCoreKit throws on REQUIRED_SHARE.
// Phase 12.4 replaces that throw with proper handling:

async function handleRequiredShare(
  coreKit: Web3AuthMPCCoreKit,
  factorKeyHex: string
): Promise<void> {
  const factorKey = new BN(factorKeyHex, 'hex');
  await coreKit.inputFactorKey(factorKey);
  // If successful, status transitions to LOGGED_IN
  // If wrong key, throws CoreKitError with code 1302

  // Create and store a device factor for this new device
  const newDeviceFactorKey = generateFactorKey();
  await coreKit.createFactor({
    shareType: TssShareType.DEVICE,
    factorKey: newDeviceFactorKey.private,
    shareDescription: FactorKeyTypeShareDescription.DeviceShare,
    additionalMetadata: {
      browserName: /* from bowser or navigator */,
      deviceName: /* OS name */,
    },
  });
  await coreKit.setDeviceFactor(newDeviceFactorKey.private);
  await coreKit.commitChanges();
}
```

### Pattern 3: Recovery via Mnemonic

**What:** Convert user-entered 24-word mnemonic back to factor key and input it.
**When to use:** When user clicks "Use recovery phrase" on login screen.

```typescript
import { mnemonicToKey } from '@web3auth/mpc-core-kit';

async function recoverWithMnemonic(coreKit: Web3AuthMPCCoreKit, mnemonic: string): Promise<void> {
  // mnemonicToKey converts BIP39 mnemonic to hex factor key
  const factorKeyHex = mnemonicToKey(mnemonic.trim().toLowerCase());
  await handleRequiredShare(coreKit, factorKeyHex);
}
```

### Pattern 4: Cross-Device Factor Transfer via Bulletin Board

**What:** Transfer a factor key from an existing device to a new device using ECIES ephemeral key exchange over a CipherBox API bulletin board.
**When to use:** When new device requests approval and existing device approves.

```text
Sequence:
1. New device: generate ephemeral secp256k1 keypair
2. New device: POST /device-approval/request
   Body: { userId, deviceId, deviceName, ephemeralPublicKey }
   -> Returns: { requestId }
3. New device: polls GET /device-approval/{requestId}/status every 3s
4. Existing device: polls GET /device-approval/pending (every 5s when app is open)
   -> Sees pending request with deviceName, ephemeralPublicKey
5. Existing device user clicks --approve:
   a. Get current factor key: coreKit.getCurrentFactorKey()
   b. ECIES-encrypt factor key with new device's ephemeralPublicKey
   c. POST /device-approval/{requestId}/respond
      Body: { action: 'approve', encryptedFactorKey }
6. New device: poll returns status='approved' with encryptedFactorKey
7. New device: ECIES-decrypt with ephemeral private key -> factor key hex
8. New device: inputFactorKey(factorKey) -> LOGGED_IN
9. New device: createFactor() for its own device share, setDeviceFactor()
```

### Pattern 5: Checking MFA Status

**What:** Determine if MFA is enabled and get factor details.
**When to use:** Settings page, enrollment prompt logic, factor management UI.

```typescript
// Source: mpc-core-kit@3.5.0 interfaces.d.ts
function isMfaEnabled(coreKit: Web3AuthMPCCoreKit): boolean {
  const keyDetails = coreKit.getKeyDetails();
  // threshold > 0 means MFA is enabled (2/3 vs single-factor)
  // requiredFactors > 0 would mean we're in REQUIRED_SHARE state
  // totalFactors shows how many factors exist
  return keyDetails.totalFactors >= 2;
}

// MPCKeyDetails type:
// {
//   metadataPubKey: TkeyPoint;
//   threshold: number;         // e.g., 2
//   requiredFactors: number;   // 0 when logged in, >0 when needing more shares
//   totalFactors: number;      // total number of registered factors
//   shareDescriptions: ShareDescriptionMap;  // factor pub -> JSON description array
//   tssPubKey?: TkeyPoint;     // TSS public key (stays same after MFA)
// }
```

### Pattern 6: Factor Deletion (Device Revocation)

**What:** Remove a device factor. Cannot delete the current active factor or the last factor.
**When to use:** Settings > Security > --revoke button.

```typescript
import { Point } from '@tkey/common-types';
import { factorKeyCurve } from '@web3auth/mpc-core-kit';

async function revokeDevice(
  coreKit: Web3AuthMPCCoreKit,
  factorPubHex: string // compressed public key hex of the factor to delete
): Promise<void> {
  const factorPub = Point.fromSEC1(factorKeyCurve, factorPubHex);
  await coreKit.deleteFactor(factorPub);
  await coreKit.commitChanges();
}

// IMPORTANT: deleteFactor enforces:
// - Cannot delete if only 1 factor remains
// - Cannot delete the currently active factor (the one used to log in)
```

### Anti-Patterns to Avoid

- **Calling enableMFA() without commitChanges() first:** If `manualSync` is true (which it is in CipherBox -- see `core-kit.ts` line 25), you MUST call `commitChanges()` before `enableMFA()`. The SDK checks for pending local metadata transitions and throws `CoreKitError.commitChangesBeforeMFA()` if any exist.

- **Storing factor keys in state/localStorage manually:** The SDK manages its own device factor storage via `setDeviceFactor()` which writes to localStorage keyed by the metadata public key. Do not duplicate this.

- **Attempting to disable MFA:** `enableMFA()` deletes the hashed cloud factor key permanently. There is no `disableMFA()`. This is a one-way operation, which aligns with the CONTEXT.md decision.

- **Using `_UNSAFE_exportTssKey()` as the factor key:** The TSS key and factor keys are different things. Factor keys are wrappers that encrypt TSS share fragments. The TSS private key is the vault key derived from all factors combined.

- **Blocking login on device registry sync:** The existing pattern in `useAuth.ts` correctly makes registry sync fire-and-forget. Cross-device approval polling should be similarly non-blocking for the core auth flow.

## Don't Hand-Roll

| Problem                           | Don't Build                      | Use Instead                                                 | Why                                                                       |
| --------------------------------- | -------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------------------- |
| Factor key generation             | Custom random key gen            | `generateFactorKey()` from mpc-core-kit                     | Returns properly typed `{ private: BN, pub: Point }` on the correct curve |
| Mnemonic encoding                 | BIP39 library integration        | `keyToMnemonic()` / `mnemonicToKey()` from mpc-core-kit     | Already handles the Core Kit factor key format, 24 words                  |
| Device factor storage             | Custom IndexedDB/localStorage    | `setDeviceFactor()` / `getDeviceFactor()` from mpc-core-kit | Keyed by metadata public key, handles replace logic                       |
| Factor deletion validation        | Custom "minimum 2 factors" check | `deleteFactor()` from mpc-core-kit                          | Built-in check for remaining factors and active factor                    |
| MFA status check                  | Custom factor counting           | `getKeyDetails()` from mpc-core-kit                         | Returns threshold, totalFactors, shareDescriptions                        |
| ECIES encryption for key exchange | Custom ECDH+HKDF+AES             | `wrapKey()` / `unwrapKey()` from `@cipherbox/crypto`        | Already tested, uses eciesjs, handles ephemeral keys                      |

**Key insight:** The Core Kit SDK handles the entire MFA lifecycle internally. CipherBox code only needs to call the SDK methods and build UI around them. The only custom infrastructure needed is the bulletin board API for cross-device communication.

## Common Pitfalls

### Pitfall 1: commitChanges() Ordering with enableMFA()

**What goes wrong:** `enableMFA()` throws `CoreKitError.commitChangesBeforeMFA()` if there are pending local metadata transitions.
**Why it happens:** `manualSync: true` in Core Kit config means changes aren't auto-synced. If any operation (like login) left uncommitted changes, enableMFA fails.
**How to avoid:** Always call `await coreKit.commitChanges()` immediately before `enableMFA()`.
**Warning signs:** Error message: "Please call commitChanges before enabling MFA"

### Pitfall 2: BN Type Handling

**What goes wrong:** Factor keys are `BN` objects but many operations return/accept hex strings. Mixing types causes silent failures.
**Why it happens:** `enableMFA()` returns a hex string. `inputFactorKey()` takes a `BN`. `generateFactorKey()` returns `{ private: BN, pub: Point }`.
**How to avoid:** Consistent conversion: `new BN(hexString, 'hex')` to go from string to BN, `bn.toString('hex')` for BN to string.
**Warning signs:** "Invalid FactorKey provided" errors.

### Pitfall 3: REQUIRED_SHARE Flow Interruption

**What goes wrong:** After `loginWithJWT()`, if status is `REQUIRED_SHARE`, the user cannot access `_UNSAFE_exportTssKey()` or any key operations. The current code throws an error here.
**Why it happens:** The TSS key is not reconstructable until enough factors are provided. The SDK is in a partial state.
**How to avoid:** The login flow MUST branch: if `REQUIRED_SHARE`, show the recovery/approval UI instead of proceeding to vault loading. Only after `inputFactorKey()` succeeds and status becomes `LOGGED_IN` should the normal flow continue.
**Warning signs:** "tKey shares are required" error, null vault keypair.

### Pitfall 4: Ephemeral Key Cleanup for Bulletin Board

**What goes wrong:** Approval requests with ephemeral keys persist after timeout, creating stale entries.
**Why it happens:** No automatic cleanup; the new device may navigate away or close.
**How to avoid:** 5-minute TTL on approval requests in the database. Backend cron or on-read expiry check.
**Warning signs:** Growing `device_approvals` table, stale requests shown to existing device users.

### Pitfall 5: Race Condition Between Approval and Recovery

**What goes wrong:** User starts approval flow on new device, then switches to recovery phrase mid-flow. Approval request stays pending on existing device.
**Why it happens:** Two parallel paths to satisfy REQUIRED_SHARE. The bulletin board request doesn't know the user recovered another way.
**How to avoid:** When `inputFactorKey()` succeeds (from any source), cancel any pending approval request. New device should DELETE or expire its request.
**Warning signs:** Phantom approval dialogs on existing devices.

### Pitfall 6: Desktop App Still Uses PnP Modal SDK

**What goes wrong:** Desktop auth (`apps/desktop/src/auth.ts`) still uses `@web3auth/modal` (PnP SDK), not MPC Core Kit. MFA factor management is a Core Kit feature.
**Why it happens:** Phase 12 only migrated the web app to Core Kit; the desktop app was not part of that scope.
**How to avoid:** Phase 12.4 should focus on the web app only. Desktop Core Kit migration is a separate phase. Document this as out-of-scope.
**Warning signs:** Desktop app cannot enable MFA or manage factors.

### Pitfall 7: Recovery Phrase Regeneration Invalidates Old Phrase

**What goes wrong:** User regenerates recovery phrase but doesn't update their backup. Old phrase becomes invalid.
**Why it happens:** `createFactor(RECOVERY)` creates a new factor, and the old recovery factor must be deleted. The old factor key no longer works.
**How to avoid:** Clear warning in UI before regeneration. Require re-display and re-confirmation of the new phrase.
**Warning signs:** User reports recovery phrase not working after regeneration.

## Code Examples

### Example 1: Complete MFA Enrollment Hook

```typescript
// Source: mpc-core-kit@3.5.0 source + Web3Auth examples
// File: apps/web/src/hooks/useMfa.ts

import { useCallback, useState } from 'react';
import {
  COREKIT_STATUS,
  keyToMnemonic,
  FactorKeyTypeShareDescription,
} from '@web3auth/mpc-core-kit';
import { useCoreKit } from '../lib/web3auth/core-kit-provider';

export function useMfa() {
  const { coreKit } = useCoreKit();
  const [isEnrolling, setIsEnrolling] = useState(false);

  const isMfaEnabled = useCallback((): boolean => {
    if (!coreKit || coreKit.status !== COREKIT_STATUS.LOGGED_IN) return false;
    try {
      const details = coreKit.getKeyDetails();
      // After enableMFA, totalFactors >= 2 (device + recovery)
      // Before enableMFA, totalFactors is 1 (hashed cloud key)
      return details.totalFactors >= 2;
    } catch {
      return false;
    }
  }, [coreKit]);

  const enableMfa = useCallback(async (): Promise<string> => {
    if (!coreKit) throw new Error('Core Kit not initialized');
    if (coreKit.status !== COREKIT_STATUS.LOGGED_IN) {
      throw new Error('Must be logged in to enable MFA');
    }

    setIsEnrolling(true);
    try {
      // Commit any pending changes first (CRITICAL for manualSync mode)
      await coreKit.commitChanges();

      // enableMFA creates device factor + recovery factor atomically
      const backupFactorKeyHex = await coreKit.enableMFA({});

      // Commit the MFA changes
      await coreKit.commitChanges();

      // Convert to 24-word mnemonic for user display
      return keyToMnemonic(backupFactorKeyHex);
    } finally {
      setIsEnrolling(false);
    }
  }, [coreKit]);

  return { isMfaEnabled, enableMfa, isEnrolling };
}
```

### Example 2: REQUIRED_SHARE Branching in Login Flow

```typescript
// Modification to apps/web/src/lib/web3auth/hooks.ts
// Replace the current REQUIRED_SHARE throw with proper handling

async function loginWithCoreKit(cipherboxJwt: string, userId: string): Promise<void> {
  if (!coreKit) throw new Error('Core Kit not initialized');

  await coreKit.loginWithJWT({
    verifier: 'cipherbox-identity',
    verifierId: userId,
    idToken: cipherboxJwt,
  });

  if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
    await coreKit.commitChanges();
    return; // Normal flow -- device factor found
  }

  if (coreKit.status === COREKIT_STATUS.REQUIRED_SHARE) {
    // MFA is enabled but this device doesn't have a factor.
    // Don't throw -- let the UI handle this state.
    // The CoreKitProvider already exposes isRequiredShare.
    return;
  }
}
```

### Example 3: Bulletin Board API Endpoints (NestJS)

```typescript
// Backend: apps/api/src/device-approval/device-approval.controller.ts

@Controller('device-approval')
@UseGuards(JwtAuthGuard) // All endpoints require authentication
export class DeviceApprovalController {
  // New device creates approval request
  // Note: new device IS authenticated (loginWithJWT succeeded, just needs factor)
  // But backend auth uses the CipherBox JWT, which doesn't require Core Kit LOGGED_IN
  @Post('request')
  async createRequest(@Body() dto: CreateApprovalDto, @Req() req): Promise<{ requestId: string }> {
    // Creates row with 5-minute expiry, status='pending'
    // Returns requestId for polling
  }

  // New device polls for approval status
  @Get(':requestId/status')
  async getStatus(@Param('requestId') id: string): Promise<ApprovalStatus> {
    // Returns: { status: 'pending'|'approved'|'denied'|'expired', encryptedFactorKey?: string }
  }

  // Existing device fetches pending requests for this user
  @Get('pending')
  async getPending(@Req() req): Promise<PendingApproval[]> {
    // Returns all non-expired pending requests for the user
    // Each includes: requestId, deviceName, deviceId, ephemeralPublicKey, createdAt, expiresAt
  }

  // Existing device approves or denies
  @Post(':requestId/respond')
  async respond(@Param('requestId') id: string, @Body() dto: RespondApprovalDto): Promise<void> {
    // action: 'approve' -> stores encryptedFactorKey, sets status='approved'
    // action: 'deny' -> sets status='denied'
  }

  // New device cancels its own request (cleanup)
  @Delete(':requestId')
  async cancel(@Param('requestId') id: string, @Req() req): Promise<void> {
    // Only the requesting device can cancel its own request
  }
}
```

### Example 4: DeviceApproval Entity

```typescript
// apps/api/src/device-approval/device-approval.entity.ts

@Entity('device_approvals')
export class DeviceApproval {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column()
  userId!: string; // FK to users table

  @Column()
  deviceId!: string; // SHA-256 of device Ed25519 pubkey

  @Column()
  deviceName!: string; // e.g., "Chrome on macOS"

  @Column({ type: 'text' })
  ephemeralPublicKey!: string; // hex, uncompressed secp256k1

  @Column({ default: 'pending' })
  status!: 'pending' | 'approved' | 'denied' | 'expired';

  @Column({ type: 'text', nullable: true })
  encryptedFactorKey!: string | null; // hex, ECIES ciphertext

  @CreateDateColumn()
  createdAt!: Date;

  @Column({ type: 'timestamp' })
  expiresAt!: Date; // createdAt + 5 minutes

  @Column({ nullable: true })
  respondedBy!: string | null; // deviceId of approving/denying device
}
```

### Example 5: ECIES Key Exchange for Cross-Device Approval

```typescript
// On existing device (approver):
import { wrapKey } from '@cipherbox/crypto';
import { hexToBytes, bytesToHex } from '@cipherbox/crypto';

async function approveDevice(
  coreKit: Web3AuthMPCCoreKit,
  requestId: string,
  ephemeralPublicKeyHex: string
): Promise<void> {
  // 1. Get the current factor key
  const { factorKey } = coreKit.getCurrentFactorKey();
  const factorKeyBytes = hexToBytes(factorKey.toString('hex').padStart(64, '0'));

  // 2. ECIES-encrypt the factor key with the new device's ephemeral public key
  const ephemeralPubKey = hexToBytes(ephemeralPublicKeyHex);
  const encrypted = await wrapKey(factorKeyBytes, ephemeralPubKey);

  // 3. Send to bulletin board
  await deviceApprovalApi.respond(requestId, {
    action: 'approve',
    encryptedFactorKey: bytesToHex(encrypted),
  });
}

// On new device (requester):
import { unwrapKey } from '@cipherbox/crypto';
import * as secp256k1 from '@noble/secp256k1';

async function receiveApproval(
  coreKit: Web3AuthMPCCoreKit,
  encryptedFactorKeyHex: string,
  ephemeralPrivateKey: Uint8Array
): Promise<void> {
  // 1. ECIES-decrypt the factor key
  const encrypted = hexToBytes(encryptedFactorKeyHex);
  const factorKeyBytes = await unwrapKey(encrypted, ephemeralPrivateKey);
  const factorKeyHex = bytesToHex(factorKeyBytes);

  // 2. Input the factor key to complete login
  const factorKey = new BN(factorKeyHex, 'hex');
  await coreKit.inputFactorKey(factorKey);

  // 3. Create device factor for this new device
  const newDeviceFactor = generateFactorKey();
  await coreKit.createFactor({
    shareType: TssShareType.DEVICE,
    factorKey: newDeviceFactor.private,
    shareDescription: FactorKeyTypeShareDescription.DeviceShare,
  });
  await coreKit.setDeviceFactor(newDeviceFactor.private);
  await coreKit.commitChanges();
}
```

## State of the Art

| Old Approach               | Current Approach               | When Changed            | Impact                       |
| -------------------------- | ------------------------------ | ----------------------- | ---------------------------- |
| PnP Modal SDK (custodial)  | MPC Core Kit (non-custodial)   | Phase 12 (2026-02)      | Complete key ownership shift |
| No MFA, single share       | 2/3 threshold with enableMFA   | Phase 12.4 (this phase) | User controls all factors    |
| Cloud-hosted hashed factor | Device + recovery factors only | After enableMFA()       | Fully non-custodial          |

**Important version note:** The installed version is `@web3auth/mpc-core-kit@3.5.0`. The source code analysis is based on this exact version. The Web3Auth docs site appears to be migrating to MetaMask branding (many URLs now 404), but the SDK API is stable and verified from the installed type declarations.

## Desktop App Impact

The desktop app (`apps/desktop/src/auth.ts`) still uses `@web3auth/modal` (PnP SDK), NOT MPC Core Kit. This means:

- **Desktop cannot participate in MFA** until migrated to Core Kit
- **Device approval from desktop is not possible** in this phase
- **Factor management on desktop is not available**

**Recommendation:** Phase 12.4 should scope to web app only. Desktop Core Kit migration should be a separate future phase. The desktop app will continue to work with its current PnP authentication but won't benefit from MFA. Add a note in the Settings UI: "MFA is available on web only. Desktop support coming soon."

## Authentication for New Device Approval Requests

**Key question:** How does a new device (in `REQUIRED_SHARE` state) authenticate with the CipherBox backend to create an approval request?

**Answer:** The new device IS authenticated at the backend level. The login flow is:

1. User authenticates via Google/Email/Wallet -> CipherBox backend issues JWT
2. Frontend calls `coreKit.loginWithJWT()` using this JWT
3. Core Kit returns `REQUIRED_SHARE` (needs factor)
4. But the CipherBox JWT was already used for `/auth/login` which issues access + refresh tokens
5. The new device HAS a valid access token -- it just can't export the TSS key yet

**However,** looking at the current flow in `useAuth.ts` (`completeBackendAuth`), backend auth happens AFTER Core Kit login, and vault loading requires the TSS key. For REQUIRED_SHARE, we need a modified flow:

1. Identity endpoint issues CipherBox JWT (this already works)
2. `loginWithJWT()` returns REQUIRED_SHARE
3. Need to call `/auth/login` with the CipherBox JWT but WITHOUT the real publicKey (since we can't export TSS key yet)
4. Backend creates a temporary session (maybe with a placeholder publicKey)
5. This temporary session is used for bulletin board API access
6. After factor input + LOGGED_IN, update the session with the real publicKey

**Alternative approach (simpler):** The new device can use the CipherBox identity JWT directly (it's already issued by our backend). Add a new guard or middleware that accepts the CipherBox identity JWT for device-approval endpoints only, without requiring full Core Kit login. This avoids the placeholder session pattern entirely.

## Open Questions

1. **Polling interval for pending approvals on existing device**
   - What we know: 5-minute TTL, CONTEXT.md says "bulletin board polling"
   - What's unclear: Should the existing device poll continuously, or only when Settings is open? If continuous, what interval?
   - Recommendation: Poll every 5s when the app is in foreground. Use a lightweight heartbeat endpoint. Show a notification badge on the Settings icon when a pending request exists. Could use a Zustand subscription to trigger polling.

2. **Factor key exposure in bulletin board**
   - What we know: Factor key is ECIES-encrypted with ephemeral key before transmission. Only the new device can decrypt.
   - What's unclear: Should we add additional authentication (e.g., 6-digit confirmation code shown on both devices)?
   - Recommendation: ECIES encryption is sufficient for v1. The ephemeral key exchange ensures only the requesting device can decrypt. The 5-minute TTL limits the attack window. A confirmation code adds UX friction without significant security gain given the encryption.

3. **MAX_FACTORS limit**
   - What we know: Core Kit source defines `MAX_FACTORS = 10`
   - What's unclear: Is this enforced per account or per share type? Can a user have 10 device factors?
   - Recommendation: Practically, users won't hit 10 factors. Document the limit in the Settings UI. Each device adds one device factor.

4. **Recovery phrase display format**
   - What we know: `keyToMnemonic()` returns a space-separated 24-word BIP39 mnemonic
   - What's unclear: Does it use English wordlist only? Is it standard BIP39 or custom?
   - Recommendation: The source imports from `@toruslabs/mpc-core-kit` helpers which use standard BIP39. Display as 4-column numbered grid per CONTEXT.md mockup.

5. **MFA enrollment prompt persistence**
   - What we know: CONTEXT.md says "shows once after first login, then only available in Settings"
   - What's unclear: Where to persist the "has seen prompt" flag
   - Recommendation: Store in localStorage keyed by user ID. Check on each login. Simple boolean flag.

## Sources

### Primary (HIGH confidence)

- `@web3auth/mpc-core-kit@3.5.0` type declarations in `node_modules` - All method signatures, interfaces, enums verified
- `mpc-core-kit/src/mpcCoreKit.ts` (GitHub master) - Full implementation of `enableMFA()`, `createFactor()`, `deleteFactor()`, `inputFactorKey()`, `getDeviceFactor()`, `setDeviceFactor()`, `getCurrentFactorKey()`
- `mpc-core-kit-examples` (GitHub) - Official usage patterns for MFA enrollment, recovery, factor management
- CipherBox codebase - `apps/web/src/lib/web3auth/` for current Core Kit integration state

### Secondary (MEDIUM confidence)

- [Web3Auth MPC Core Kit Usage Documentation](https://web3auth.io/docs/sdk/core-kit/mpc-core-kit/usage) - API descriptions (site partially migrated, some 404s)
- [Web3Auth MPC Architecture](https://web3auth.io/docs/infrastructure/mpc-architecture) - TSS share model description
- WebSearch-verified: TSS private key does NOT change after enableMFA (multiple sources confirm factor keys are wrappers, not the key itself)

### Tertiary (LOW confidence)

- Web3Auth docs site is migrating URLs (many paths return 404 as of 2026-02-15). API stability confirmed from installed package, not live docs.

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - All packages already installed, type declarations verified in node_modules
- Architecture (Core Kit MFA): HIGH - Implementation source code read directly from GitHub and verified against installed type declarations
- Architecture (Bulletin Board): MEDIUM - Standard polling pattern, no existing implementation to reference; design is derived from OAuth device flow and CONTEXT.md decisions
- Pitfalls: HIGH - Verified from Core Kit source code error handling paths and existing codebase patterns
- Cross-device crypto: HIGH - Reuses existing `@cipherbox/crypto` ECIES primitives already tested in the codebase

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (Core Kit API stable at v3.5.0; bulletin board is custom design)
