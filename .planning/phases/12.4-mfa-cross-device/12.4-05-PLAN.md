---
phase: 12.4-mfa-cross-device
plan: 05
type: execute
wave: 3
depends_on: ['12.4-01', '12.4-02', '12.4-03', '12.4-04']
files_modified:
  - apps/web/src/api/ (generated client)
  - apps/web/src/services/device-approval.service.ts
autonomous: true

must_haves:
  truths:
    - 'API client is regenerated and device-approval endpoints use the generated client'
    - 'Login flow for non-MFA users works exactly as before (no regression)'
    - 'MFA enrollment via Settings > Security completes end-to-end'
    - 'Cross-device approval transfers factor key successfully'
    - 'Recovery phrase restores access on a new device'
    - 'Keypair (tssPubKey) is identical before and after MFA enrollment'
  artifacts:
    - path: 'apps/web/src/api/'
      provides: 'Regenerated API client with device-approval endpoints'
    - path: 'apps/web/src/services/device-approval.service.ts'
      provides: 'Updated to use generated client instead of manual apiClient calls'
  key_links:
    - from: 'apps/web/src/services/device-approval.service.ts'
      to: 'apps/web/src/api/'
      via: 'generated API client import'
      pattern: 'import.*from.*api/'
---

<objective>
Regenerate the API client, replace manual fetch calls with the generated client, and perform end-to-end integration verification including programmatic keypair stability check.

Purpose: The API client must be regenerated after Plan 01 added new backend endpoints. Manual apiClient calls in the device-approval service should be replaced with type-safe generated calls. Final verification ensures all MFA flows work end-to-end without regressions. Keypair stability (MFA-04 requirement) must be verified programmatically, not just manually.

Output: Regenerated API client, updated device-approval service, verified integration, keypair stability confirmed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.4-mfa-cross-device/12.4-01-SUMMARY.md (bulletin board API)
@.planning/phases/12.4-mfa-cross-device/12.4-02-SUMMARY.md (MFA hooks, login flow, temp auth)
@.planning/phases/12.4-mfa-cross-device/12.4-03-SUMMARY.md (enrollment wizard, Security tab)
@.planning/phases/12.4-mfa-cross-device/12.4-04-SUMMARY.md (cross-device approval, recovery, AppShell mount)
@apps/web/src/services/device-approval.service.ts (manual apiClient calls to replace)
@apps/web/src/lib/api/ (existing generated API client pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate API client + update device-approval service</name>
  <files>
    apps/web/src/api/ (generated)
    apps/web/src/services/device-approval.service.ts
  </files>
  <action>
1. Run `pnpm api:generate` from the project root. This:
   - Generates the OpenAPI spec from the NestJS API (picks up new device-approval endpoints)
   - Creates the typed client for the web app
   - Runs lint fixes

2. Verify the generated client includes device-approval endpoints. Check the generated types for:
   - `CreateApprovalDto` type
   - `RespondApprovalDto` type
   - Functions for POST/GET/DELETE on `/device-approval/*`

3. Update `apps/web/src/services/device-approval.service.ts`:
   - Replace manual `apiClient.post`/`apiClient.get`/`apiClient.delete` calls with the generated client functions
   - Import from the generated API module (match pattern from existing services like `authApi`, `vaultApi`)
   - Ensure the same auth token handling is used (the generated client should handle this automatically via the configured axios instance)
   - Keep the same external API surface (function names and return types)

4. Run `pnpm --filter web build` to verify everything compiles with the new generated types.

5. Run `pnpm lint` to ensure no lint errors from the regenerated client.
   </action>
   <verify>
   `cd /Users/michael/Code/cipher-box && pnpm api:generate` succeeds. `pnpm --filter web build` succeeds. `pnpm lint` passes. The generated client includes device-approval types and functions.
   </verify>
   <done>API client is regenerated with device-approval endpoints. Manual apiClient calls are replaced with type-safe generated client calls. Build and lint pass.</done>
   </task>

<task type="auto">
  <name>Task 2: End-to-end integration verification + keypair stability check</name>
  <files>
  </files>
  <action>
**Integration verification checklist (pure verification -- no auth fix needed, already in Plan 02):**

1. **Non-MFA login (no regression):**
   - Start API and web: `pnpm --filter api dev` and `pnpm --filter web dev`
   - Login via Google or email as a non-MFA user
   - Verify: normal login flow, vault loads, file browser renders
   - Verify: MFA enrollment prompt appears after login (if not dismissed before)
   - Verify: no console errors related to MFA or REQUIRED_SHARE

2. **Programmatic keypair stability verification (MFA-04):**
   Before and after MFA enrollment, compare the TSS public key to confirm it does not change.

   Add a temporary verification script or use the browser console:
   - Before enabling MFA, capture `coreKit.getKeyDetails().tssPubKey` (the compressed TSS public key)
   - Store it as `preMfaPubKey`
   - Enable MFA via Settings > Security > wizard
   - After enrollment completes, capture `coreKit.getKeyDetails().tssPubKey` again as `postMfaPubKey`
   - Assert: `preMfaPubKey.x === postMfaPubKey.x && preMfaPubKey.y === postMfaPubKey.y`

   To verify this programmatically, add a brief check in `useMfa.enableMfa()`:

   ```typescript
   // In enableMfa(), before and after enableMFA():
   const preMfaTssPub = coreKit.getKeyDetails().tssPubKey;
   const backupFactorKeyHex = await coreKit.enableMFA({});
   await coreKit.commitChanges();
   const postMfaTssPub = coreKit.getKeyDetails().tssPubKey;
   if (preMfaTssPub && postMfaTssPub) {
     if (
       preMfaTssPub.x.toString('hex') !== postMfaTssPub.x.toString('hex') ||
       preMfaTssPub.y.toString('hex') !== postMfaTssPub.y.toString('hex')
     ) {
       console.error('[MFA] CRITICAL: TSS public key changed after enableMFA!');
       // This should never happen per RESEARCH.md, but log it defensively
     }
   }
   ```

   Add this assertion to the `enableMfa()` function in `useMfa.ts` as a permanent defensive check (not just a test). Log a warning but do NOT throw (enrollment already succeeded).

3. **Verify MFA enrollment flow:**
   - Navigate to Settings > Security tab
   - Click "Enable MFA"
   - Step through wizard: explain -> recovery phrase -> confirm -> done
   - Verify recovery phrase grid shows 24 words
   - Verify [x] checkbox works with keyboard
   - Verify enrollment completes

4. **Verify cross-device approval (if testable with two browser profiles):**
   - Login on one browser profile (existing device)
   - Clear Core Kit localStorage on another profile, login with same account (new device)
   - Verify: new device shows DeviceWaitingScreen
   - Verify: existing device shows DeviceApprovalModal
   - Approve -> verify: new device completes login

5. **Verify recovery phrase (if testable):**
   - Clear Core Kit localStorage to simulate new device
   - Login -> REQUIRED_SHARE -> click "Use recovery phrase"
   - Enter the 24 words -> verify login completes

6. **Clean up any TODO comments** left in Plans 01-04. Search for `TODO`, `FIXME`, `Phase 12.4` comments in new files and resolve them.

7. **Verify CSS styling consistency:**
   - Red warning boxes use `#EF4444`
   - Green accents use `#00D084`
   - Terminal-style buttons use `--` prefix
   - Monospace font for code-like elements
   - [x] checkboxes render correctly
         </action>
         <verify>
         `cd /Users/michael/Code/cipher-box && pnpm --filter api build && pnpm --filter web build` both succeed. `pnpm --filter api test` passes. `pnpm lint` passes. Start both services and manually test: non-MFA login works, Settings > Security tab loads, enrollment wizard renders. Check browser console for errors. Verify no `[MFA] CRITICAL: TSS public key changed` log message after enrollment.
         </verify>
         <done>All MFA flows work end-to-end. Non-MFA login has no regressions. API client is regenerated and used throughout. Keypair stability confirmed programmatically via tssPubKey comparison in enableMfa(). No TODO/FIXME comments remain. Build, test, and lint all pass.</done>
         </task>

</tasks>

<verification>
1. `pnpm api:generate` succeeds
2. `pnpm --filter api build && pnpm --filter web build` succeed
3. `pnpm --filter api test` passes (no regressions)
4. `pnpm lint` passes
5. Non-MFA user login flow is unchanged
6. MFA enrollment preserves keypair identity (tssPubKey comparison logged, no CRITICAL warning)
7. Cross-device approval works: new device -> existing device modal -> factor transfer -> login
8. Recovery phrase works: 24 words -> inputFactorKey -> device factor -> login
9. No console errors in browser during normal operation
</verification>

<success_criteria>

- Generated API client includes device-approval endpoints with correct types
- device-approval.service.ts uses generated client (not manual apiClient calls)
- Non-MFA login: works exactly as before Phase 12.4
- MFA enrollment: Settings > Security > wizard > recovery phrase displayed > MFA enabled > tssPubKey unchanged
- Cross-device: new device waits > existing device approves > factor transferred > login completes
- Recovery: new device enters phrase > factor restored > login completes
- Programmatic tssPubKey comparison added to enableMfa() as permanent defensive check
- No build, test, or lint errors
  </success_criteria>

<output>
After completion, create `.planning/phases/12.4-mfa-cross-device/12.4-05-SUMMARY.md`
</output>
