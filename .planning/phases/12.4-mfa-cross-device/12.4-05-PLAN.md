---
phase: 12.4-mfa-cross-device
plan: 05
type: execute
wave: 3
depends_on: ['12.4-03', '12.4-04']
files_modified:
  - apps/web/src/api/ (generated client)
  - apps/web/src/services/device-approval.service.ts
  - apps/web/src/hooks/useAuth.ts
  - apps/web/src/routes/Login.tsx
autonomous: true

must_haves:
  truths:
    - 'API client is regenerated and device-approval endpoints use the generated client'
    - 'Login flow for non-MFA users works exactly as before (no regression)'
    - 'MFA enrollment via Settings > Security completes end-to-end'
    - 'Cross-device approval transfers factor key successfully'
    - 'Recovery phrase restores access on a new device'
    - 'Keypair (publicKey) is identical before and after MFA enrollment'
  artifacts:
    - path: 'apps/web/src/api/'
      provides: 'Regenerated API client with device-approval endpoints'
    - path: 'apps/web/src/services/device-approval.service.ts'
      provides: 'Updated to use generated client instead of manual fetch'
  key_links:
    - from: 'apps/web/src/services/device-approval.service.ts'
      to: 'apps/web/src/api/'
      via: 'generated API client import'
      pattern: 'import.*from.*api/'
---

<objective>
Regenerate the API client, replace manual fetch calls with the generated client, and perform end-to-end integration verification.

Purpose: The API client must be regenerated after Plan 01 added new backend endpoints. Manual fetch calls in the device-approval service should be replaced with type-safe generated calls. Final verification ensures all MFA flows work end-to-end without regressions.

Output: Regenerated API client, updated device-approval service, verified integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.4-mfa-cross-device/12.4-01-SUMMARY.md (bulletin board API)
@.planning/phases/12.4-mfa-cross-device/12.4-02-SUMMARY.md (MFA hooks, login flow)
@.planning/phases/12.4-mfa-cross-device/12.4-03-SUMMARY.md (enrollment wizard, Security tab)
@.planning/phases/12.4-mfa-cross-device/12.4-04-SUMMARY.md (cross-device approval, recovery)
@apps/web/src/services/device-approval.service.ts (manual fetch calls to replace)
@apps/web/src/lib/api/ (existing generated API client pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate API client + update device-approval service</name>
  <files>
    apps/web/src/api/ (generated)
    apps/web/src/services/device-approval.service.ts
  </files>
  <action>
1. Run `pnpm api:generate` from the project root. This:
   - Generates the OpenAPI spec from the NestJS API (picks up new device-approval endpoints)
   - Creates the typed client for the web app
   - Runs lint fixes

2. Verify the generated client includes device-approval endpoints. Check the generated types for:
   - `CreateApprovalDto` type
   - `RespondApprovalDto` type
   - Functions for POST/GET/DELETE on `/device-approval/*`

3. Update `apps/web/src/services/device-approval.service.ts`:
   - Replace manual fetch/axios calls with the generated client functions
   - Import from the generated API module (match pattern from existing services like `authApi`, `vaultApi`)
   - Ensure the same auth token handling is used (the generated client should handle this automatically via the configured axios instance)
   - Keep the same external API surface (function names and return types)

4. Run `pnpm --filter web build` to verify everything compiles with the new generated types.

5. Run `pnpm lint` to ensure no lint errors from the regenerated client.
   </action>
   <verify>
   `cd /Users/michael/Code/cipher-box && pnpm api:generate` succeeds. `pnpm --filter web build` succeeds. `pnpm lint` passes. The generated client includes device-approval types and functions.
   </verify>
   <done>API client is regenerated with device-approval endpoints. Manual fetch calls are replaced with type-safe generated client calls. Build and lint pass.</done>
   </task>

<task type="auto">
  <name>Task 2: End-to-end integration verification + cleanup</name>
  <files>
    apps/web/src/hooks/useAuth.ts
    apps/web/src/routes/Login.tsx
  </files>
  <action>
**Integration verification checklist:**

1. **Non-MFA login (no regression):**
   - Start API and web: `pnpm --filter api dev` and `pnpm --filter web dev`
   - Login via Google or email as a non-MFA user
   - Verify: normal login flow, vault loads, file browser renders
   - Verify: MFA enrollment prompt appears after login (if not dismissed before)
   - Verify: no console errors related to MFA or REQUIRED_SHARE

2. **Verify keypair stability after MFA enrollment:**
   - Before enabling MFA, note the user's publicKey (from Core Kit `getKeyDetails().tssPubKey` or the auth store)
   - Enable MFA via Settings > Security > wizard
   - After enrollment, verify publicKey is UNCHANGED (critical MFA-04 requirement)
   - This should be true by design (RESEARCH confirms TSS key doesn't change) but must be verified

3. **Fix any integration issues found:**
   - If the MFA store isn't being reset on logout, ensure `useMfaStore.getState().reset()` is called in the useAuth logout function
   - If the DeviceApprovalModal isn't mounting, ensure it's placed in the right component tree location
   - If polling starts before authentication is complete, add proper guards
   - If localStorage prompt persistence key format doesn't match, standardize to `cipherbox_mfa_prompt_dismissed_{userId}`

4. **Ensure bulletin board auth works for REQUIRED_SHARE devices:**
   - The new device is in REQUIRED_SHARE state (Core Kit partial login) but still has a valid CipherBox access token from backend auth
   - WAIT: Check Plan 02 -- does `completeBackendAuth` get called before or after factor input?
   - If the new device doesn't have a backend access token yet (because completeBackendAuth needs publicKey from TSS export, which requires LOGGED_IN), then the bulletin board endpoints need a different auth mechanism
   - Solution per RESEARCH.md: The identity JWT (CipherBox JWT issued by identity controller) can be used directly. Add a guard or use the existing JWT for device-approval endpoints. The CipherBox JWT is available before Core Kit login.
   - If needed, modify the device-approval controller to accept the CipherBox identity JWT (not just the session access token). This may require a new guard or an optional auth path.
   - Alternatively, split the backend auth: call `/auth/login` with a placeholder publicKey when in REQUIRED_SHARE state to get an access token, then update with real publicKey after factor input. Check if the backend already handles placeholder publicKey (it does -- from Phase 12 learnings, the `pending-core-kit-{userId}` pattern).

   **Recommended approach:** Before Core Kit login, the frontend already has the CipherBox identity JWT (returned from the identity endpoint: Google/email/wallet verification). Use this JWT to authenticate with the device-approval endpoints. This requires:
   - The device-approval controller to accept the CipherBox identity JWT (verify against the same JWKS)
   - OR: call `/auth/login` with the CipherBox JWT before Core Kit login (with a placeholder publicKey), get an access token, then use that for bulletin board polling. After factor input + LOGGED_IN, call `/auth/login` again with the real publicKey to update it.

   The second approach (login with placeholder first) is simpler and follows the existing pattern. Modify the REQUIRED_SHARE flow in useAuth to:
   1. After Core Kit returns REQUIRED_SHARE, call `authApi.login({ idToken: cipherboxJwt, publicKey: 'pending', loginType: 'corekit' })` to get a temporary access token
   2. Use this access token for bulletin board API calls
   3. After factor input succeeds and Core Kit is LOGGED_IN, call `completeBackendAuth()` which will update with the real publicKey

   Implement this flow modification if needed based on testing.

5. **Clean up any TODO comments** left in Plans 01-04. Search for `TODO`, `FIXME`, `Phase 12.4` comments in new files and resolve them.

6. **Verify CSS styling consistency:**
   - Red warning boxes use `#EF4444`
   - Green accents use `#00D084`
   - Terminal-style buttons use `--` prefix
   - Monospace font for code-like elements
   - [x] checkboxes render correctly
         </action>
         <verify>
         `cd /Users/michael/Code/cipher-box && pnpm --filter api build && pnpm --filter web build` both succeed. `pnpm --filter api test` passes. `pnpm lint` passes. Start both services and manually test: non-MFA login works, Settings > Security tab loads, enrollment wizard renders. Check browser console for errors.
         </verify>
         <done>All MFA flows work end-to-end. Non-MFA login has no regressions. API client is regenerated and used throughout. Authentication for REQUIRED_SHARE devices is resolved. No TODO/FIXME comments remain. Build, test, and lint all pass.</done>
         </task>

</tasks>

<verification>
1. `pnpm api:generate` succeeds
2. `pnpm --filter api build && pnpm --filter web build` succeed
3. `pnpm --filter api test` passes (no regressions)
4. `pnpm lint` passes
5. Non-MFA user login flow is unchanged
6. MFA enrollment preserves keypair identity (publicKey unchanged)
7. Cross-device approval works: new device -> existing device modal -> factor transfer -> login
8. Recovery phrase works: 24 words -> inputFactorKey -> device factor -> login
9. No console errors in browser during normal operation
</verification>

<success_criteria>

- Generated API client includes device-approval endpoints with correct types
- device-approval.service.ts uses generated client (not manual fetch)
- Non-MFA login: works exactly as before Phase 12.4
- MFA enrollment: Settings > Security > wizard > recovery phrase displayed > MFA enabled > publicKey unchanged
- Cross-device: new device waits > existing device approves > factor transferred > login completes
- Recovery: new device enters phrase > factor restored > login completes
- No build, test, or lint errors
  </success_criteria>

<output>
After completion, create `.planning/phases/12.4-mfa-cross-device/12.4-05-SUMMARY.md`
</output>
