---
phase: 12.4-mfa-cross-device
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/device-approval/device-approval.entity.ts
  - apps/api/src/device-approval/device-approval.service.ts
  - apps/api/src/device-approval/device-approval.controller.ts
  - apps/api/src/device-approval/device-approval.module.ts
  - apps/api/src/device-approval/dto/create-approval.dto.ts
  - apps/api/src/device-approval/dto/respond-approval.dto.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - 'New device can create a 5-minute-TTL approval request via POST /device-approval/request'
    - 'Existing device can list pending approval requests via GET /device-approval/pending'
    - 'Existing device can approve or deny via POST /device-approval/:requestId/respond'
    - 'New device can poll status via GET /device-approval/:requestId/status'
    - 'Expired requests are filtered out on read (no stale data returned)'
  artifacts:
    - path: 'apps/api/src/device-approval/device-approval.entity.ts'
      provides: 'DeviceApproval TypeORM entity with UUID PK, userId, deviceId, deviceName, ephemeralPublicKey, status, encryptedFactorKey, expiresAt, respondedBy'
      contains: "@Entity('device_approvals')"
    - path: 'apps/api/src/device-approval/device-approval.service.ts'
      provides: 'CRUD operations for approval requests with TTL enforcement'
      exports: ['DeviceApprovalService']
    - path: 'apps/api/src/device-approval/device-approval.controller.ts'
      provides: 'REST endpoints for bulletin board pattern'
      exports: ['DeviceApprovalController']
    - path: 'apps/api/src/device-approval/device-approval.module.ts'
      provides: 'NestJS module wiring entity, service, controller'
      exports: ['DeviceApprovalModule']
  key_links:
    - from: 'apps/api/src/device-approval/device-approval.controller.ts'
      to: 'apps/api/src/device-approval/device-approval.service.ts'
      via: 'NestJS dependency injection'
      pattern: 'constructor.*DeviceApprovalService'
    - from: 'apps/api/src/app.module.ts'
      to: 'apps/api/src/device-approval/device-approval.module.ts'
      via: 'imports array'
      pattern: 'DeviceApprovalModule'
---

<objective>
Build the bulletin board REST API for cross-device factor transfer.

Purpose: New devices need a way to request approval from existing devices. This API provides the communication channel -- new device posts a request with an ephemeral public key, existing device encrypts a factor key with that public key and posts the response. All requests have a 5-minute TTL.

Output: A new `device-approval` NestJS module with entity, service, controller, and DTOs. All endpoints are JWT-authenticated.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.4-mfa-cross-device/12.4-RESEARCH.md (patterns 4, example 3, example 4)
@apps/api/src/auth/entities/user.entity.ts (for userId FK pattern)
@apps/api/src/auth/auth.module.ts (for module registration pattern)
@apps/api/src/app.module.ts (for top-level module imports)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DeviceApproval entity + DTOs</name>
  <files>
    apps/api/src/device-approval/device-approval.entity.ts
    apps/api/src/device-approval/dto/create-approval.dto.ts
    apps/api/src/device-approval/dto/respond-approval.dto.ts
  </files>
  <action>
Create the DeviceApproval TypeORM entity as specified in RESEARCH.md Example 4:
- Table name: `device_approvals`
- Columns: `id` (UUID PK), `userId` (string, not null), `deviceId` (string, not null), `deviceName` (string, not null), `ephemeralPublicKey` (text, not null -- hex uncompressed secp256k1), `status` (varchar default 'pending' -- values: pending/approved/denied/expired), `encryptedFactorKey` (text, nullable -- hex ECIES ciphertext), `createdAt` (CreateDateColumn), `expiresAt` (timestamp, not null), `respondedBy` (string, nullable -- deviceId of responder)
- Use snake_case column names with camelCase properties (per project convention): `@Column({ name: 'user_id' })`, `@Column({ name: 'device_id' })`, `@Column({ name: 'device_name' })`, `@Column({ name: 'ephemeral_public_key', type: 'text' })`, `@Column({ name: 'encrypted_factor_key', type: 'text', nullable: true })`, `@Column({ name: 'expires_at', type: 'timestamp' })`, `@Column({ name: 'responded_by', nullable: true })`

Create DTOs:

- `CreateApprovalDto`: `deviceId` (string, IsNotEmpty), `deviceName` (string, IsNotEmpty), `ephemeralPublicKey` (string, IsNotEmpty, IsHexadecimal)
- `RespondApprovalDto`: `action` (string literal 'approve' | 'deny', IsIn(['approve', 'deny'])), `encryptedFactorKey` (string, optional, ValidateIf action === 'approve' then IsNotEmpty + IsHexadecimal), `respondedByDeviceId` (string, IsNotEmpty)

Use class-validator decorators matching existing DTO patterns in the codebase. Do NOT add `userId` to CreateApprovalDto -- it comes from the JWT.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter api build` compiles without errors.
</verify>
<done>Entity and DTOs exist with proper TypeORM decorators and class-validator constraints.</done>
</task>

<task type="auto">
  <name>Task 2: DeviceApproval service, controller, and module</name>
  <files>
    apps/api/src/device-approval/device-approval.service.ts
    apps/api/src/device-approval/device-approval.controller.ts
    apps/api/src/device-approval/device-approval.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**Service** (`DeviceApprovalService`):
- Inject `@InjectRepository(DeviceApproval)` repository
- `createRequest(userId: string, dto: CreateApprovalDto)`: Creates a new row with `status='pending'`, `expiresAt = new Date(Date.now() + 5 * 60 * 1000)`. Returns `{ requestId: id }`.
- `getStatus(requestId: string, userId: string)`: Find by id + userId. If `expiresAt < now` and status is 'pending', update to 'expired'. Return `{ status, encryptedFactorKey? }`.
- `getPending(userId: string)`: Find all where `userId = userId` AND `status = 'pending'` AND `expiresAt > now`. Return array with `requestId, deviceId, deviceName, ephemeralPublicKey, createdAt, expiresAt`.
- `respond(requestId: string, userId: string, dto: RespondApprovalDto)`: Find by id + userId. Validate status is 'pending' and not expired. If approve, set `encryptedFactorKey` and `respondedBy`. Set status to dto.action value ('approved' or 'denied'). Throw NotFoundException if not found, BadRequestException if already responded or expired.
- `cancel(requestId: string, userId: string)`: Find by id + userId, delete if status is 'pending'. Throw NotFoundException otherwise.

**Controller** (`DeviceApprovalController`):

- All endpoints decorated with `@UseGuards(JwtAuthGuard)` at class level
- Extract userId from request: `req.user.userId` (matching existing JwtAuthGuard pattern)
- `POST /device-approval/request` -> `createRequest`
- `GET /device-approval/:requestId/status` -> `getStatus`
- `GET /device-approval/pending` -> `getPending`
- `POST /device-approval/:requestId/respond` -> `respond`
- `DELETE /device-approval/:requestId` -> `cancel`
- Add Swagger decorators (`@ApiTags('device-approval')`, `@ApiBearerAuth()`, `@ApiOperation`, `@ApiResponse`) matching existing controller patterns.

**Module** (`DeviceApprovalModule`):

- imports: `TypeOrmModule.forFeature([DeviceApproval])`
- controllers: `[DeviceApprovalController]`
- providers: `[DeviceApprovalService]`

**app.module.ts**: Add `DeviceApprovalModule` to imports array.

IMPORTANT: The JwtAuthGuard import path should match the existing pattern in the codebase (check `apps/api/src/auth/guards/`). The controller should use `@Request() req` and access `req.user.userId` as the authenticated user's ID.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter api build` compiles. Then run `pnpm --filter api test` to verify existing tests still pass (no regressions). Then start the API (`pnpm --filter api dev`) and verify the new endpoints appear in Swagger at `http://localhost:3000/api`.
</verify>
<done>All 5 bulletin board endpoints work: create request, poll status, list pending, respond (approve/deny), cancel. Expired requests are auto-filtered. Swagger docs show the new endpoints.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter api build` succeeds
2. `pnpm --filter api test` passes (no regressions)
3. Entity is registered in TypeORM (no migration errors on startup -- using synchronize in dev)
4. Swagger UI at `http://localhost:3000/api` shows device-approval endpoints with correct request/response schemas
</verification>

<success_criteria>

- DeviceApproval entity exists with all columns
- 5 REST endpoints are functional and JWT-protected
- Expired requests return 'expired' status on read
- Approve stores encryptedFactorKey, deny does not
- Cancel only works for pending requests owned by the caller
- No regressions in existing API tests
  </success_criteria>

<output>
After completion, create `.planning/phases/12.4-mfa-cross-device/12.4-01-SUMMARY.md`
</output>
