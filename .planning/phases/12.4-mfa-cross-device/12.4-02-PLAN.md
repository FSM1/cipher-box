---
phase: 12.4-mfa-cross-device
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/hooks/useMfa.ts
  - apps/web/src/stores/mfa.store.ts
  - apps/web/src/lib/web3auth/hooks.ts
  - apps/web/src/hooks/useAuth.ts
autonomous: true

must_haves:
  truths:
    - 'useMfa hook can check if MFA is enabled via getKeyDetails()'
    - 'useMfa hook can call enableMFA() and return 24-word mnemonic'
    - 'useMfa hook can list factors with their descriptions'
    - 'useMfa hook can delete a factor by its public key'
    - 'Login flow branches on REQUIRED_SHARE instead of throwing'
    - 'When REQUIRED_SHARE, login does not attempt vault loading or backend auth completion'
  artifacts:
    - path: 'apps/web/src/hooks/useMfa.ts'
      provides: 'React hook wrapping Core Kit MFA operations'
      exports: ['useMfa']
    - path: 'apps/web/src/stores/mfa.store.ts'
      provides: 'Zustand store for MFA UI state'
      exports: ['useMfaStore']
    - path: 'apps/web/src/lib/web3auth/hooks.ts'
      provides: 'Modified loginWithCoreKit that handles REQUIRED_SHARE without throwing'
      exports: ['useCoreKitAuth']
  key_links:
    - from: 'apps/web/src/hooks/useMfa.ts'
      to: 'apps/web/src/lib/web3auth/core-kit-provider.tsx'
      via: 'useCoreKit() hook'
      pattern: 'useCoreKit'
    - from: 'apps/web/src/lib/web3auth/hooks.ts'
      to: 'apps/web/src/lib/web3auth/core-kit-provider.tsx'
      via: 'COREKIT_STATUS.REQUIRED_SHARE check'
      pattern: 'REQUIRED_SHARE'
    - from: 'apps/web/src/hooks/useAuth.ts'
      to: 'apps/web/src/lib/web3auth/hooks.ts'
      via: 'isRequiredShare state used to skip vault loading'
      pattern: 'isRequiredShare'
---

<objective>
Create the MFA operations hook, MFA state store, and modify the login flow to handle REQUIRED_SHARE status.

Purpose: This is the core infrastructure for all MFA features. The `useMfa` hook wraps Core Kit SDK calls (enableMFA, inputFactorKey, createFactor, deleteFactor, getKeyDetails, keyToMnemonic, mnemonicToKey). The login flow modification replaces the current "throw on REQUIRED_SHARE" with proper state branching that allows recovery/approval UI to render.

Output: `useMfa.ts` hook, `mfa.store.ts` store, modified `hooks.ts` and `useAuth.ts` to handle REQUIRED_SHARE.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.4-mfa-cross-device/12.4-RESEARCH.md (patterns 1-3, 5-6, examples 1-2, pitfalls 1-3)
@apps/web/src/lib/web3auth/hooks.ts (current loginWithCoreKit with REQUIRED_SHARE throw)
@apps/web/src/lib/web3auth/core-kit-provider.tsx (CoreKitProvider with isRequiredShare)
@apps/web/src/lib/web3auth/core-kit.ts (getCoreKit, manualSync: true)
@apps/web/src/hooks/useAuth.ts (completeBackendAuth, initializeOrLoadVault)
@apps/web/src/stores/auth.store.ts (state shape pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: MFA store and useMfa hook</name>
  <files>
    apps/web/src/stores/mfa.store.ts
    apps/web/src/hooks/useMfa.ts
  </files>
  <action>
**MFA Store** (`mfa.store.ts`):
Create a Zustand store following the pattern in `auth.store.ts`:
- `isMfaEnabled: boolean` -- whether MFA is active for the current user
- `isEnrolling: boolean` -- true during enableMFA() call
- `factorCount: number` -- total factors from getKeyDetails()
- `threshold: number` -- threshold from getKeyDetails()
- `hasSeenPrompt: boolean` -- whether user has dismissed the enrollment prompt this session
- `setMfaEnabled(enabled: boolean)` action
- `setEnrolling(enrolling: boolean)` action
- `setFactorDetails(count: number, threshold: number)` action
- `dismissPrompt()` action -- sets hasSeenPrompt to true
- `reset()` action -- clears all state (called on logout)

**useMfa Hook** (`useMfa.ts`):
Import from `@web3auth/mpc-core-kit`: `COREKIT_STATUS`, `generateFactorKey`, `keyToMnemonic`, `mnemonicToKey`, `TssShareType`, `FactorKeyTypeShareDescription`.
Import `BN` from `bn.js`.
Import `useCoreKit` from core-kit-provider.
Import `useMfaStore`.

Implement:

1. `checkMfaStatus()`: Call `coreKit.getKeyDetails()`. Returns `{ isMfaEnabled: boolean, totalFactors: number, threshold: number }`. MFA is enabled when `totalFactors >= 2`. Update store with results. Guard: only works when `coreKit.status === COREKIT_STATUS.LOGGED_IN`.

2. `enableMfa()`: Returns `Promise<string>` (the 24-word mnemonic).
   - Guard: coreKit must be LOGGED_IN, MFA must not already be enabled
   - Set store isEnrolling = true
   - Call `await coreKit.commitChanges()` FIRST (critical for manualSync mode -- see RESEARCH.md Pitfall 1)
   - Call `const backupFactorKeyHex = await coreKit.enableMFA({})`
   - Call `await coreKit.commitChanges()` again
   - Convert: `const mnemonic = keyToMnemonic(backupFactorKeyHex)`
   - Update store: isMfaEnabled=true, factorCount via getKeyDetails()
   - Set isEnrolling = false in finally block
   - Return mnemonic

3. `inputFactorKey(factorKeyHex: string)`: For recovery and cross-device approval.
   - `const factorKey = new BN(factorKeyHex, 'hex')`
   - `await coreKit.inputFactorKey(factorKey)`
   - After success, status should be LOGGED_IN

4. `recoverWithMnemonic(mnemonic: string)`:
   - `const factorKeyHex = mnemonicToKey(mnemonic.trim().toLowerCase())`
   - Call `inputFactorKey(factorKeyHex)`
   - Then create a device factor for the new device:

     ```typescript
     const newDeviceFactor = generateFactorKey();
     await coreKit.createFactor({
       shareType: TssShareType.DEVICE,
       factorKey: newDeviceFactor.private,
       shareDescription: FactorKeyTypeShareDescription.DeviceShare,
     });
     await coreKit.setDeviceFactor(newDeviceFactor.private);
     await coreKit.commitChanges();
     ```

5. `getFactors()`: Returns array of `{ factorPubHex: string, description: string, type: string }`.
   - Call `coreKit.getKeyDetails()` -> `shareDescriptions` is a `Record<string, string[]>`.
   - Each key is a factor public key hex, each value is an array of JSON strings describing the factor.
   - Parse each description JSON to extract `module` (e.g., 'deviceShare', 'seedPhrase') and any `additionalMetadata`.

6. `deleteFactor(factorPubHex: string)`:
   - Import `Point` from `@tkey/common-types` and `factorKeyCurve` from `@web3auth/mpc-core-kit`
   - `const factorPub = Point.fromSEC1(factorKeyCurve, factorPubHex)`
   - `await coreKit.deleteFactor(factorPub)`
   - `await coreKit.commitChanges()`
   - Refresh factor list via getFactors()

7. `getCurrentFactorKey()`: Returns `{ factorKey: BN, factorPubHex: string }`.
   - `const result = coreKit.getCurrentFactorKey()`
   - Return `{ factorKey: result.factorKey, factorPubHex: result.factorKey... }` -- the actual return from getCurrentFactorKey() is `{ factorKey: BN }`. Derive the public key from factor key using secp256k1.

8. `regenerateRecoveryPhrase()`: Returns `Promise<string>` (new mnemonic).
   - Get existing factors, find the one with module='seedPhrase'
   - Delete old recovery factor via deleteFactor()
   - Generate new: `const newRecovery = generateFactorKey()`
   - `await coreKit.createFactor({ shareType: TssShareType.RECOVERY, factorKey: newRecovery.private, shareDescription: FactorKeyTypeShareDescription.SeedPhrase })`
   - `await coreKit.commitChanges()`
   - Return `keyToMnemonic(newRecovery.private.toString('hex'))`

Return all functions plus store state via useMfaStore selectors.

IMPORTANT: All BN <-> hex conversions must be consistent. Use `new BN(hex, 'hex')` for string-to-BN and `bn.toString('hex').padStart(64, '0')` for BN-to-string (zero-pad to 32 bytes). See RESEARCH.md Pitfall 2.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles without type errors. Manually verify the imports resolve correctly: `@web3auth/mpc-core-kit` exports `generateFactorKey`, `keyToMnemonic`, `mnemonicToKey`, `TssShareType`, `FactorKeyTypeShareDescription`, `factorKeyCurve`.
</verify>
<done>useMfa hook exports all 8 MFA operations. mfa.store.ts tracks enrollment state. All Core Kit SDK calls are properly wrapped with commitChanges() and BN conversion.</done>
</task>

<task type="auto">
  <name>Task 2: Login flow REQUIRED_SHARE branching</name>
  <files>
    apps/web/src/lib/web3auth/hooks.ts
    apps/web/src/hooks/useAuth.ts
  </files>
  <action>
**hooks.ts** -- Modify `loginWithCoreKit()`:
Replace the current REQUIRED_SHARE handling (lines 31-37) that throws an error. Instead:

```typescript
if (coreKit.status === COREKIT_STATUS.REQUIRED_SHARE) {
  // MFA enabled but this device lacks a factor.
  // Return without throwing -- CoreKitProvider exposes isRequiredShare.
  // The caller (useAuth) will check this state and NOT proceed to
  // backend auth or vault loading.
  return;
}
```

Also export a new function from useCoreKitAuth:

- `isRequiredShare`: boolean from useCoreKit() context (already exposed by CoreKitProvider)

Add to the return object: `isRequiredShare`.

**useAuth.ts** -- Modify login flows (loginWithGoogle, loginWithEmail, loginWithWallet):
After each `coreKitLogin*()` call and before `completeBackendAuth()`, check for REQUIRED_SHARE:

```typescript
// After: await coreKitLoginGoogle(googleIdToken);
// Check if MFA challenge is needed
const { isRequiredShare } = useCoreKit(); // Not inside useAuth -- need alternative
```

ACTUALLY: The useCoreKit() hook won't reflect the updated status synchronously because React state updates are async. Instead, check `coreKit.status` directly. The better approach:

Modify `loginWithCoreKit` in hooks.ts to return a result indicating the status:

```typescript
async function loginWithCoreKit(
  cipherboxJwt: string,
  userId: string
): Promise<'logged_in' | 'required_share'> {
  // ... existing loginWithJWT call ...
  if (coreKit.status === COREKIT_STATUS.LOGGED_IN) {
    await coreKit.commitChanges();
    return 'logged_in';
  }
  if (coreKit.status === COREKIT_STATUS.REQUIRED_SHARE) {
    return 'required_share';
  }
  throw new Error(`Unexpected Core Kit status: ${coreKit.status}`);
}
```

Then each login function (loginWithGoogle, loginWithEmailOtp, loginWithWallet) returns this result.

In **useAuth.ts**, each login method checks the returned status:

```typescript
const loginWithGoogle = useCallback(async (googleIdToken: string): Promise<void> => {
  // ...
  const { cipherboxJwt, email } = await coreKitLoginGoogle(googleIdToken);

  // Check if this returns 'required_share'
  // If so, store the cipherboxJwt and auth method for later (after factor input)
  // and DON'T call completeBackendAuth or navigate

  // ... handle both paths ...
}, [...]);
```

For the REQUIRED_SHARE path in useAuth.ts:

1. Store `pendingCipherboxJwt` and `pendingAuthMethod` in local state (useState)
2. Do NOT call `completeBackendAuth()`
3. Do NOT call `navigate('/files')`
4. The component tree will see `isRequiredShare === true` from CoreKitProvider and render the recovery/approval UI (built in Plans 03/04)

Add a new function `completeRequiredShare()` to useAuth that:

1. Is called AFTER `inputFactorKey()` succeeds (from recovery or cross-device approval)
2. Uses the stored `pendingCipherboxJwt` and `pendingAuthMethod`
3. Calls `completeBackendAuth(pendingAuthMethod, pendingCipherboxJwt)`
4. Navigates to `/files`

Also add to useAuth's return: `isRequiredShare` (from useCoreKit()), `completeRequiredShare`, and `pendingAuthMethod` (so UI knows which method was used).

For the session restoration effect (the `useEffect` in useAuth.ts that handles coreKitLoggedIn): The isRequiredShare case needs handling here too. If Core Kit init results in REQUIRED_SHARE (e.g., user clears localStorage device share), the session restore should NOT proceed. Add a check:

```typescript
if (coreKitLoggedIn && !isAuthenticated && !isLoggingIn && !restoringRef.current) {
  // existing restore logic
}
// Add: no restore attempt when isRequiredShare is true
```

But actually -- Core Kit `init()` that finds a stored device share will either return LOGGED_IN or NOT_INITIALIZED. REQUIRED_SHARE only happens after `loginWithJWT()` when the device share is missing. So the session restore effect doesn't need REQUIRED_SHARE handling -- it only triggers when `coreKitLoggedIn` (status === LOGGED_IN). This is correct already.

Also add `useMfaStore.getState().reset()` to the logout function alongside the other store resets.

IMPORTANT: Import `useMfaStore` at the top of useAuth.ts. The mfa.store.ts file will be created by Task 1.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles. Verify that the login flow still works for non-MFA users by checking that `loginWithCoreKit` returns 'logged_in' and the existing completeBackendAuth path executes normally. No E2E test regressions: `pnpm --filter web test` (if unit tests exist). The REQUIRED_SHARE error message is gone from hooks.ts.
</verify>
<done>Login flow branches on REQUIRED_SHARE without throwing. Non-MFA login is unaffected. useAuth exposes isRequiredShare, pendingAuthMethod, and completeRequiredShare() for downstream UI components.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter web build` succeeds
2. All existing imports in the web app resolve
3. The throw on REQUIRED_SHARE in hooks.ts is replaced with a return value
4. useAuth returns isRequiredShare, completeRequiredShare, pendingAuthMethod
5. Non-MFA login flow (Google/email/wallet) still works unchanged
6. MFA store resets on logout
</verification>

<success_criteria>

- useMfa hook provides enableMfa, recoverWithMnemonic, inputFactorKey, getFactors, deleteFactor, getCurrentFactorKey, regenerateRecoveryPhrase, checkMfaStatus
- mfa.store.ts tracks isMfaEnabled, isEnrolling, factorCount, threshold, hasSeenPrompt
- loginWithCoreKit returns 'logged_in' | 'required_share' instead of throwing
- useAuth stores pending JWT for post-factor-input completion
- completeRequiredShare() resumes the login flow after factor input
  </success_criteria>

<output>
After completion, create `.planning/phases/12.4-mfa-cross-device/12.4-02-SUMMARY.md`
</output>
