---
phase: 12.4-mfa-cross-device
plan: 04
type: execute
wave: 2
depends_on: ['12.4-01', '12.4-02']
files_modified:
  - apps/web/src/services/device-approval.service.ts
  - apps/web/src/hooks/useDeviceApproval.ts
  - apps/web/src/components/mfa/DeviceWaitingScreen.tsx
  - apps/web/src/components/mfa/RecoveryInput.tsx
  - apps/web/src/components/mfa/DeviceApprovalModal.tsx
  - apps/web/src/components/mfa/MfaEnrollmentPrompt.tsx
  - apps/web/src/routes/Login.tsx
  - apps/web/src/components/layout/AppShell.tsx
autonomous: true

must_haves:
  truths:
    - 'New device in REQUIRED_SHARE state sees a waiting screen with spinner and countdown'
    - "New device can fall back to 'Use recovery phrase' from the waiting screen"
    - 'Existing device sees a modal with device name, --approve, and --deny buttons'
    - 'After approval, new device receives encrypted factor key and completes login'
    - 'After recovery phrase input, new device completes login and creates device factor'
    - 'Post-login dismissable MFA enrollment prompt shows once for non-MFA users'
  artifacts:
    - path: 'apps/web/src/services/device-approval.service.ts'
      provides: 'API client for bulletin board endpoints'
      exports: ['deviceApprovalApi']
    - path: 'apps/web/src/hooks/useDeviceApproval.ts'
      provides: 'Hook managing approval request lifecycle and polling'
      exports: ['useDeviceApproval']
    - path: 'apps/web/src/components/mfa/DeviceApprovalModal.tsx'
      provides: 'Approval dialog on existing device'
      min_lines: 50
    - path: 'apps/web/src/components/mfa/DeviceWaitingScreen.tsx'
      provides: 'Full-screen waiting state on new device'
      min_lines: 60
    - path: 'apps/web/src/components/mfa/RecoveryInput.tsx'
      provides: '24-word recovery phrase input form'
      min_lines: 40
    - path: 'apps/web/src/components/mfa/MfaEnrollmentPrompt.tsx'
      provides: 'Dismissable post-login MFA enrollment nudge'
      min_lines: 30
  key_links:
    - from: 'apps/web/src/hooks/useDeviceApproval.ts'
      to: 'apps/web/src/services/device-approval.service.ts'
      via: 'API calls for create/poll/respond'
      pattern: 'deviceApprovalApi'
    - from: 'apps/web/src/components/mfa/DeviceWaitingScreen.tsx'
      to: 'apps/web/src/hooks/useDeviceApproval.ts'
      via: 'polling for approval status'
      pattern: 'useDeviceApproval'
    - from: 'apps/web/src/components/mfa/DeviceApprovalModal.tsx'
      to: 'apps/web/src/hooks/useDeviceApproval.ts'
      via: 'respond to approval request'
      pattern: 'approveRequest|denyRequest'
    - from: 'apps/web/src/routes/Login.tsx'
      to: 'apps/web/src/components/mfa/DeviceWaitingScreen.tsx'
      via: 'rendered when isRequiredShare is true'
      pattern: 'isRequiredShare.*DeviceWaitingScreen'
    - from: 'apps/web/src/components/layout/AppShell.tsx'
      to: 'apps/web/src/components/mfa/DeviceApprovalModal.tsx'
      via: 'mounted in AppShell when authenticated + MFA enabled + pending requests'
      pattern: 'DeviceApprovalModal'
    - from: 'apps/web/src/services/device-approval.service.ts'
      to: 'apps/web/src/lib/api/client.ts'
      via: 'apiClient axios instance with auth interceptor'
      pattern: 'apiClient'
---

<objective>
Build the cross-device approval flow (both requesting and approving sides), recovery phrase input, and post-login MFA enrollment prompt.

Purpose: When a user logs in on a new device with MFA enabled, they need either another device to approve or a recovery phrase. The existing device polls for pending requests and shows an approval modal. After MFA enrollment, non-MFA users get a one-time dismissable prompt to set up MFA.

Output: device-approval API client, useDeviceApproval hook, DeviceWaitingScreen, DeviceApprovalModal, RecoveryInput, MfaEnrollmentPrompt, Login.tsx modifications, and AppShell.tsx modal mount.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.4-mfa-cross-device/12.4-RESEARCH.md (pattern 4, example 5, pitfalls 4-5)
@.planning/phases/12.4-mfa-cross-device/12.4-CONTEXT.md (design direction, mockup Frame Bxate)
@.planning/phases/12.4-mfa-cross-device/12.4-01-SUMMARY.md (bulletin board API endpoints)
@.planning/phases/12.4-mfa-cross-device/12.4-02-SUMMARY.md (useMfa hook, REQUIRED_SHARE flow, completeRequiredShare, temp auth)
@apps/web/src/routes/Login.tsx (current login page)
@apps/web/src/hooks/useAuth.ts (isRequiredShare, completeRequiredShare, pendingAuthMethod)
@apps/web/src/lib/device/identity.ts (getOrCreateDeviceIdentity for deviceId)
@apps/web/src/lib/api/client.ts (apiClient axios instance with auth interceptor -- reads token from auth store)
@apps/web/src/components/layout/AppShell.tsx (layout wrapper for authenticated pages -- mount DeviceApprovalModal here)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Device approval API client + useDeviceApproval hook</name>
  <files>
    apps/web/src/services/device-approval.service.ts
    apps/web/src/hooks/useDeviceApproval.ts
  </files>
  <action>
**device-approval.service.ts** -- API client:
Create a service object `deviceApprovalApi` using the `apiClient` axios instance from `apps/web/src/lib/api/client.ts`. This is the same pattern used by `authApi` in `apps/web/src/lib/api/auth.ts` and `vaultApi` in `apps/web/src/lib/api/vault.ts`. The `apiClient` has a request interceptor that automatically attaches the Bearer token from `useAuthStore.getState().accessToken`, so all requests will be authenticated.

```typescript
import { apiClient } from '../lib/api/client';
```

Methods:

- `createRequest(dto: { deviceId: string, deviceName: string, ephemeralPublicKey: string }): Promise<{ requestId: string }>`
  - `apiClient.post('/device-approval/request', dto)`
- `getStatus(requestId: string): Promise<{ status: string, encryptedFactorKey?: string }>`
  - `apiClient.get(`/device-approval/${requestId}/status`)`
- `getPending(): Promise<Array<{ requestId: string, deviceId: string, deviceName: string, ephemeralPublicKey: string, createdAt: string, expiresAt: string }>>`
  - `apiClient.get('/device-approval/pending')`
- `respond(requestId: string, dto: { action: 'approve' | 'deny', encryptedFactorKey?: string, respondedByDeviceId: string }): Promise<void>`
  - `apiClient.post(`/device-approval/${requestId}/respond`, dto)`
- `cancel(requestId: string): Promise<void>`
  - `apiClient.delete(`/device-approval/${requestId}`)`

NOTE: After Plan 05 runs `pnpm api:generate`, these will be replaced by the generated client. For now, use `apiClient` calls which are type-safe at the transport level and automatically authenticated.

**useDeviceApproval** hook:
Manages the full lifecycle for BOTH sides of the approval flow.

**New device side (requester):**

- `requestApproval()`:
  1. Generate ephemeral secp256k1 keypair: `const ephemeralPrivKey = secp256k1.utils.randomPrivateKey()`, `const ephemeralPubKey = secp256k1.getPublicKey(ephemeralPrivKey, false)` (uncompressed)
  2. Store `ephemeralPrivKey` in local state (useState, NOT localStorage -- ephemeral!)
  3. Get device identity: `getOrCreateDeviceIdentity()` for deviceId
  4. Get device info: `detectDeviceInfo()` for deviceName
  5. POST to bulletin board: `deviceApprovalApi.createRequest({ deviceId, deviceName, ephemeralPublicKey: bytesToHex(ephemeralPubKey) })`
  6. Store `requestId` in state
  7. Start polling `getStatus(requestId)` every 3 seconds (use setInterval, clear on unmount)

- When poll returns `status === 'approved'`:
  1. Stop polling
  2. ECIES-decrypt: `const factorKeyBytes = await unwrapKey(hexToBytes(encryptedFactorKey), ephemeralPrivKey)` using `unwrapKey` from `@cipherbox/crypto`
  3. Convert: `const factorKeyHex = bytesToHex(factorKeyBytes)`
  4. Call `useMfa().inputFactorKey(factorKeyHex)` to complete Core Kit login
  5. Create device factor for this new device (same pattern as recoverWithMnemonic in useMfa):

     ```typescript
     const newDeviceFactor = generateFactorKey();
     await coreKit.createFactor({
       shareType: DEVICE,
       factorKey: newDeviceFactor.private,
       shareDescription: DeviceShare,
     });
     await coreKit.setDeviceFactor(newDeviceFactor.private);
     await coreKit.commitChanges();
     ```

  6. Call `completeRequiredShare()` from useAuth to finish login flow
  7. Zero-fill ephemeralPrivKey

- When poll returns `status === 'denied'` or `status === 'expired'`:
  1. Stop polling
  2. Show appropriate message
  3. Zero-fill ephemeralPrivKey

- `cancelRequest()`: DELETE the pending request, stop polling, zero-fill ephemeralPrivKey

**Existing device side (approver):**

- `pollPendingRequests()`: Call `deviceApprovalApi.getPending()` every 5 seconds
  - Only poll when app is in foreground (use `useVisibility()` hook from existing codebase)
  - Store pending requests in state
  - When a new request appears, surface it to the UI

- `approveRequest(requestId: string, ephemeralPublicKeyHex: string)`:
  1. Get current factor key from Core Kit: `coreKit.getCurrentFactorKey()`
  2. Convert factor key to bytes: `hexToBytes(factorKey.toString('hex').padStart(64, '0'))`
  3. ECIES-encrypt with the requester's ephemeral public key: `await wrapKey(factorKeyBytes, hexToBytes(ephemeralPublicKeyHex))`
  4. POST: `deviceApprovalApi.respond(requestId, { action: 'approve', encryptedFactorKey: bytesToHex(encrypted), respondedByDeviceId: currentDeviceId })`
  5. Remove from pending list

- `denyRequest(requestId: string)`:
  1. POST: `deviceApprovalApi.respond(requestId, { action: 'deny', respondedByDeviceId: currentDeviceId })`
  2. Remove from pending list

Return: `{ requestApproval, cancelRequest, approveRequest, denyRequest, pendingRequests, approvalStatus, isPolling, pollPendingRequests }`.

IMPORTANT per RESEARCH.md Pitfall 5: When `inputFactorKey()` succeeds from ANY source (recovery or approval), cancel any pending approval request. Call `cancelRequest()` in the recovery input flow too.

Import `wrapKey`, `unwrapKey` from `@cipherbox/crypto`. Import `* as secp256k1` from `@noble/secp256k1`. Import `bytesToHex`, `hexToBytes` from `@cipherbox/crypto`. Import `generateFactorKey`, `TssShareType`, `FactorKeyTypeShareDescription` from `@web3auth/mpc-core-kit`.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles. All crypto imports resolve. The hook can be instantiated without errors (no missing deps).
</verify>
<done>deviceApprovalApi has 5 methods using apiClient (with automatic auth headers). useDeviceApproval handles both requester (create, poll, receive) and approver (poll pending, approve, deny) sides with proper ECIES key exchange and ephemeral key cleanup.</done>
</task>

<task type="auto">
  <name>Task 2a: New device UI -- DeviceWaitingScreen, RecoveryInput, Login.tsx integration</name>
  <files>
    apps/web/src/components/mfa/DeviceWaitingScreen.tsx
    apps/web/src/components/mfa/RecoveryInput.tsx
    apps/web/src/routes/Login.tsx
  </files>
  <action>
**DeviceWaitingScreen** (`DeviceWaitingScreen.tsx`):
Full-screen component shown when `isRequiredShare === true`.
Props: `onRecoveryFallback: () => void`, `onApprovalComplete: () => void`.
Uses `useDeviceApproval()` hook.

Layout (matching CONTEXT.md):

- Centered card on dark background
- "Waiting for device approval..." heading
- Spinner animation (CSS, no external library)
- Countdown timer showing time remaining (5 minutes from request creation)
  - Timer in red (#EF4444) when < 3 minutes remaining (per CONTEXT.md)
- Device request status text (e.g., "Request sent to your other devices")
- "Use recovery phrase instead" link/button calling `onRecoveryFallback`
- When `approvalStatus === 'approved'`: auto-complete flow via `onApprovalComplete`
- When `approvalStatus === 'denied'`: show "Request was denied" message with retry option
- When `approvalStatus === 'expired'`: show "Request expired" with retry option and recovery fallback

On mount: auto-call `requestApproval()` to create the bulletin board request.
On unmount: call `cancelRequest()` to clean up.

**RecoveryInput** (`RecoveryInput.tsx`):
Props: `onRecoveryComplete: () => void`, `onBack: () => void`.
Uses `useMfa()` hook for `recoverWithMnemonic()`.
Uses `useDeviceApproval()` hook for `cancelRequest()` (to cancel any pending approval when recovering via phrase).

Layout:

- Heading: "Enter your recovery phrase"
- Single textarea accepting space-separated words: monospace, placeholder "Enter your 24-word recovery phrase..."
  - Auto-trim and lowercase on submit
- `--recover` button (green) and `--back` button
- Error message area for invalid phrase
- Loading state during recovery

On successful recovery:

1. Cancel any pending approval request via `useDeviceApproval().cancelRequest()` (RESEARCH.md Pitfall 5)
2. Call `onRecoveryComplete()`

**Login.tsx** -- REQUIRED_SHARE integration:
Current Login.tsx renders the Google/email/wallet login forms. Add handling for REQUIRED_SHARE state:

1. Import `useAuth` and check `isRequiredShare`
2. When `isRequiredShare === true`, instead of the login form, render:
   - `DeviceWaitingScreen` with recovery fallback
   - Or `RecoveryInput` if user clicks "Use recovery phrase"
   - Use local state to toggle between waiting and recovery views

3. When approval or recovery completes, call `completeRequiredShare()` from useAuth.

The state machine for Login.tsx:

- `idle` -> normal login form
- `required_share` -> DeviceWaitingScreen (or RecoveryInput)
- `login_complete` -> navigate to /files

Check `isRequiredShare` from `useAuth()` return value (added in Plan 02). Also need `completeRequiredShare` and `pendingAuthMethod` from useAuth.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles. Navigate to Login page -- for non-MFA users, normal login flow works. For MFA users on new device (test by clearing Core Kit localStorage for that user), the REQUIRED_SHARE state triggers and shows DeviceWaitingScreen. Recovery phrase input field accepts 24 words.
</verify>
<done>New device flow: REQUIRED_SHARE detected -> DeviceWaitingScreen renders with countdown + spinner -> "Use recovery phrase" fallback available -> RecoveryInput accepts 24 words -> login completes. Login.tsx properly switches between login form and MFA challenge views.</done>
</task>

<task type="auto">
  <name>Task 2b: Existing device UI -- DeviceApprovalModal, MfaEnrollmentPrompt, AppShell mount + polling</name>
  <files>
    apps/web/src/components/mfa/DeviceApprovalModal.tsx
    apps/web/src/components/mfa/MfaEnrollmentPrompt.tsx
    apps/web/src/components/layout/AppShell.tsx
  </files>
  <action>
**DeviceApprovalModal** (`DeviceApprovalModal.tsx`):
Modal overlay shown on existing (already logged-in) device when pending approval requests exist.
Uses `useDeviceApproval()` hook.

Layout (matching Pencil mockup Frame Bxate):

- Backdrop: `rgb(0 0 0 / 80%)` overlay dimming the file browser (use modern color syntax per web CLAUDE.md)
- Modal card with `#00D084` (green) border
- Heading: "Device Approval Request"
- Device details: name, request time, expiry countdown
- Red warning: "Only approve if YOU are trying to log in on another device"
- Two buttons: `--deny` (red outline `#EF4444`) and `--approve` (green filled `#00D084`)
- Clicking `--approve` calls `approveRequest()` with the requestId and ephemeralPublicKey
- Clicking `--deny` calls `denyRequest()`
- Modal closes after response
- If multiple pending requests, show them one at a time (queue)

**MfaEnrollmentPrompt** (`MfaEnrollmentPrompt.tsx`):
Dismissable banner/toast shown after first login when MFA is not enabled.
Uses `useMfa()` for `checkMfaStatus()` and `useMfaStore` for `hasSeenPrompt` / `dismissPrompt()`.

Layout:

- Compact banner at top of file browser (not blocking, not modal)
- Text: "Secure your account with MFA" + brief description
- `--setup-mfa` button linking to Settings > Security tab
- `--dismiss` button that calls `dismissPrompt()` and hides the banner
- Only shows if: MFA not enabled AND hasSeenPrompt is false AND user just logged in
- Persistence: `hasSeenPrompt` in mfa.store (memory-only -- shows again after browser refresh). For cross-session persistence, also store a flag in `localStorage` keyed by user ID: `cipherbox_mfa_prompt_dismissed_{userId}`. Check both: store OR localStorage flag.

**AppShell.tsx** -- Mount DeviceApprovalModal and MfaEnrollmentPrompt:

The DeviceApprovalModal and MfaEnrollmentPrompt must be mounted inside `AppShell` (at `apps/web/src/components/layout/AppShell.tsx`), which wraps all authenticated pages (FilesPage, SettingsPage). This is the correct mount point because:

1. AppShell is always rendered when the user is authenticated
2. The modal needs to appear regardless of which page the user is on
3. It follows the existing pattern (AppShell already has MatrixBackground, AppHeader, etc.)

Add to AppShell's JSX, after `<AppFooter />` and before the closing `</div>`:

```tsx
import { DeviceApprovalModal } from '../mfa/DeviceApprovalModal';
import { MfaEnrollmentPrompt } from '../mfa/MfaEnrollmentPrompt';

// Inside the return, after AppFooter:
<DeviceApprovalModal />
<MfaEnrollmentPrompt />
```

DeviceApprovalModal internally should:

- Use `useAuth()` to check `isAuthenticated`
- Use `useMfa()` to check if MFA is enabled for this user
- Use `useDeviceApproval().pollPendingRequests()` to start polling
- Only render the modal overlay when there are `pendingRequests.length > 0`
- Only start polling when `isAuthenticated && isMfaEnabled` (both must be true)
- Guard: do NOT render or poll when the user is in REQUIRED_SHARE state themselves (they're the requester, not the approver)

MfaEnrollmentPrompt internally should:

- Use `useAuth()` to check `isAuthenticated`
- Use `useMfa().checkMfaStatus()` on mount to determine if MFA is enabled
- Only render when `isAuthenticated && !isMfaEnabled && !hasSeenPrompt`
  </action>
  <verify>
  `cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles. Log in on existing device -- no approval modal appears (no pending requests). MFA enrollment prompt appears if MFA is not enabled and hasn't been dismissed. Verify AppShell renders both new components without breaking existing layout.
  </verify>
  <done>Existing device flow: DeviceApprovalModal mounted in AppShell, polls for pending requests when authenticated + MFA enabled, shows approval dialog with --approve/--deny. MfaEnrollmentPrompt mounted in AppShell, shows once for non-MFA users, dismissable. Both components are properly gated by auth + MFA state.</done>
  </task>

</tasks>

<verification>
1. `pnpm --filter web build` succeeds
2. DeviceWaitingScreen renders with spinner, countdown, and recovery fallback
3. RecoveryInput accepts 24 words and triggers recovery flow
4. DeviceApprovalModal appears on existing device with approve/deny (mounted in AppShell)
5. ECIES key exchange works: approve -> encrypted factor key -> decrypt -> inputFactorKey -> LOGGED_IN
6. Pending approval request is cancelled when recovery phrase is used instead
7. Ephemeral private keys are zero-filled after use
8. MfaEnrollmentPrompt shows once and is dismissable (mounted in AppShell)
9. Login.tsx properly renders REQUIRED_SHARE state
10. deviceApprovalApi uses apiClient from lib/api/client.ts (automatic auth headers)
</verification>

<success_criteria>

- New device flow: login -> REQUIRED_SHARE -> DeviceWaitingScreen -> (approval or recovery) -> LOGGED_IN -> vault loaded
- Existing device flow: pending request detected -> DeviceApprovalModal -> approve/deny -> factor encrypted/response sent
- Recovery flow: 24-word input -> mnemonicToKey -> inputFactorKey -> device factor created -> LOGGED_IN
- MFA enrollment prompt: shows once per session for non-MFA users, dismissable, links to Settings > Security
- DeviceApprovalModal mounted in AppShell (visible on all authenticated pages)
- MfaEnrollmentPrompt mounted in AppShell (visible on all authenticated pages)
- All API calls use apiClient with automatic Bearer token from auth store
- All terminal aesthetic UI: --approve/--deny/--recover/--back/--dismiss button labels
  </success_criteria>

<output>
After completion, create `.planning/phases/12.4-mfa-cross-device/12.4-04-SUMMARY.md`
</output>
