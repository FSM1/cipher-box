---
phase: 12.4-mfa-cross-device
plan: 04
type: execute
wave: 2
depends_on: ['12.4-01', '12.4-02']
files_modified:
  - apps/web/src/services/device-approval.service.ts
  - apps/web/src/hooks/useDeviceApproval.ts
  - apps/web/src/components/mfa/DeviceApprovalModal.tsx
  - apps/web/src/components/mfa/DeviceWaitingScreen.tsx
  - apps/web/src/components/mfa/MfaEnrollmentPrompt.tsx
  - apps/web/src/components/mfa/RecoveryInput.tsx
  - apps/web/src/routes/Login.tsx
autonomous: true

must_haves:
  truths:
    - 'New device in REQUIRED_SHARE state sees a waiting screen with spinner and countdown'
    - "New device can fall back to 'Use recovery phrase' from the waiting screen"
    - 'Existing device sees a modal with device name, --approve, and --deny buttons'
    - 'After approval, new device receives encrypted factor key and completes login'
    - 'After recovery phrase input, new device completes login and creates device factor'
    - 'Post-login dismissable MFA enrollment prompt shows once for non-MFA users'
  artifacts:
    - path: 'apps/web/src/services/device-approval.service.ts'
      provides: 'API client for bulletin board endpoints'
      exports: ['deviceApprovalApi']
    - path: 'apps/web/src/hooks/useDeviceApproval.ts'
      provides: 'Hook managing approval request lifecycle and polling'
      exports: ['useDeviceApproval']
    - path: 'apps/web/src/components/mfa/DeviceApprovalModal.tsx'
      provides: 'Approval dialog on existing device'
      min_lines: 50
    - path: 'apps/web/src/components/mfa/DeviceWaitingScreen.tsx'
      provides: 'Full-screen waiting state on new device'
      min_lines: 60
    - path: 'apps/web/src/components/mfa/RecoveryInput.tsx'
      provides: '24-word recovery phrase input form'
      min_lines: 40
    - path: 'apps/web/src/components/mfa/MfaEnrollmentPrompt.tsx'
      provides: 'Dismissable post-login MFA enrollment nudge'
      min_lines: 30
  key_links:
    - from: 'apps/web/src/hooks/useDeviceApproval.ts'
      to: 'apps/web/src/services/device-approval.service.ts'
      via: 'API calls for create/poll/respond'
      pattern: 'deviceApprovalApi'
    - from: 'apps/web/src/components/mfa/DeviceWaitingScreen.tsx'
      to: 'apps/web/src/hooks/useDeviceApproval.ts'
      via: 'polling for approval status'
      pattern: 'useDeviceApproval'
    - from: 'apps/web/src/components/mfa/DeviceApprovalModal.tsx'
      to: 'apps/web/src/hooks/useDeviceApproval.ts'
      via: 'respond to approval request'
      pattern: 'approveRequest|denyRequest'
    - from: 'apps/web/src/routes/Login.tsx'
      to: 'apps/web/src/components/mfa/DeviceWaitingScreen.tsx'
      via: 'rendered when isRequiredShare is true'
      pattern: 'isRequiredShare.*DeviceWaitingScreen'
---

<objective>
Build the cross-device approval flow (both requesting and approving sides), recovery phrase input, and post-login MFA enrollment prompt.

Purpose: When a user logs in on a new device with MFA enabled, they need either another device to approve or a recovery phrase. The existing device polls for pending requests and shows an approval modal. After MFA enrollment, non-MFA users get a one-time dismissable prompt to set up MFA.

Output: device-approval API client, useDeviceApproval hook, DeviceWaitingScreen, DeviceApprovalModal, RecoveryInput, MfaEnrollmentPrompt, and Login.tsx modifications for REQUIRED_SHARE rendering.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.4-mfa-cross-device/12.4-RESEARCH.md (pattern 4, example 5, pitfalls 4-5)
@.planning/phases/12.4-mfa-cross-device/12.4-CONTEXT.md (design direction, mockup Frame Bxate)
@.planning/phases/12.4-mfa-cross-device/12.4-01-SUMMARY.md (bulletin board API endpoints)
@.planning/phases/12.4-mfa-cross-device/12.4-02-SUMMARY.md (useMfa hook, REQUIRED_SHARE flow, completeRequiredShare)
@apps/web/src/routes/Login.tsx (current login page)
@apps/web/src/hooks/useAuth.ts (isRequiredShare, completeRequiredShare, pendingAuthMethod)
@apps/web/src/lib/device/identity.ts (getOrCreateDeviceIdentity for deviceId)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Device approval API client + useDeviceApproval hook</name>
  <files>
    apps/web/src/services/device-approval.service.ts
    apps/web/src/hooks/useDeviceApproval.ts
  </files>
  <action>
**device-approval.service.ts** -- API client:
Create a service object `deviceApprovalApi` with methods calling the bulletin board API (Plan 01).

Use the existing API client pattern from `apps/web/src/lib/api/` -- look at how authApi and vaultApi are structured (likely using the generated Orval client or a manual fetch wrapper with auth headers).

Methods:

- `createRequest(dto: { deviceId: string, deviceName: string, ephemeralPublicKey: string }): Promise<{ requestId: string }>`
- `getStatus(requestId: string): Promise<{ status: string, encryptedFactorKey?: string }>`
- `getPending(): Promise<Array<{ requestId: string, deviceId: string, deviceName: string, ephemeralPublicKey: string, createdAt: string, expiresAt: string }>>`
- `respond(requestId: string, dto: { action: 'approve' | 'deny', encryptedFactorKey?: string, respondedByDeviceId: string }): Promise<void>`
- `cancel(requestId: string): Promise<void>`

Use the authenticated HTTP client (with access token in header). The actual implementation depends on whether the project uses Orval-generated clients or manual fetch -- check `apps/web/src/lib/api/` for the pattern and follow it.

NOTE: After Plan 05 runs `pnpm api:generate`, these will be replaced by the generated client. For now, use manual fetch calls with the correct base URL and auth headers. Import the auth store to get the access token, or use the same axios/fetch instance that authApi uses.

**useDeviceApproval** hook:
Manages the full lifecycle for BOTH sides of the approval flow.

**New device side (requester):**

- `requestApproval()`:
  1. Generate ephemeral secp256k1 keypair: `const ephemeralPrivKey = secp256k1.utils.randomPrivateKey()`, `const ephemeralPubKey = secp256k1.getPublicKey(ephemeralPrivKey, false)` (uncompressed)
  2. Store `ephemeralPrivKey` in local state (useState, NOT localStorage -- ephemeral!)
  3. Get device identity: `getOrCreateDeviceIdentity()` for deviceId
  4. Get device info: `detectDeviceInfo()` for deviceName
  5. POST to bulletin board: `deviceApprovalApi.createRequest({ deviceId, deviceName, ephemeralPublicKey: bytesToHex(ephemeralPubKey) })`
  6. Store `requestId` in state
  7. Start polling `getStatus(requestId)` every 3 seconds (use setInterval, clear on unmount)

- When poll returns `status === 'approved'`:
  1. Stop polling
  2. ECIES-decrypt: `const factorKeyBytes = await unwrapKey(hexToBytes(encryptedFactorKey), ephemeralPrivKey)` using `unwrapKey` from `@cipherbox/crypto`
  3. Convert: `const factorKeyHex = bytesToHex(factorKeyBytes)`
  4. Call `useMfa().inputFactorKey(factorKeyHex)` to complete Core Kit login
  5. Create device factor for this new device (same pattern as recoverWithMnemonic in useMfa):

     ```typescript
     const newDeviceFactor = generateFactorKey();
     await coreKit.createFactor({
       shareType: DEVICE,
       factorKey: newDeviceFactor.private,
       shareDescription: DeviceShare,
     });
     await coreKit.setDeviceFactor(newDeviceFactor.private);
     await coreKit.commitChanges();
     ```

  6. Call `completeRequiredShare()` from useAuth to finish login flow
  7. Zero-fill ephemeralPrivKey

- When poll returns `status === 'denied'` or `status === 'expired'`:
  1. Stop polling
  2. Show appropriate message
  3. Zero-fill ephemeralPrivKey

- `cancelRequest()`: DELETE the pending request, stop polling, zero-fill ephemeralPrivKey

**Existing device side (approver):**

- `pollPendingRequests()`: Call `deviceApprovalApi.getPending()` every 5 seconds
  - Only poll when app is in foreground (use `useVisibility()` hook from existing codebase)
  - Store pending requests in state
  - When a new request appears, surface it to the UI

- `approveRequest(requestId: string, ephemeralPublicKeyHex: string)`:
  1. Get current factor key from Core Kit: `coreKit.getCurrentFactorKey()`
  2. Convert factor key to bytes: `hexToBytes(factorKey.toString('hex').padStart(64, '0'))`
  3. ECIES-encrypt with the requester's ephemeral public key: `await wrapKey(factorKeyBytes, hexToBytes(ephemeralPublicKeyHex))`
  4. POST: `deviceApprovalApi.respond(requestId, { action: 'approve', encryptedFactorKey: bytesToHex(encrypted), respondedByDeviceId: currentDeviceId })`
  5. Remove from pending list

- `denyRequest(requestId: string)`:
  1. POST: `deviceApprovalApi.respond(requestId, { action: 'deny', respondedByDeviceId: currentDeviceId })`
  2. Remove from pending list

Return: `{ requestApproval, cancelRequest, approveRequest, denyRequest, pendingRequests, approvalStatus, isPolling, pollPendingRequests }`.

IMPORTANT per RESEARCH.md Pitfall 5: When `inputFactorKey()` succeeds from ANY source (recovery or approval), cancel any pending approval request. Call `cancelRequest()` in the recovery input flow too.

Import `wrapKey`, `unwrapKey` from `@cipherbox/crypto`. Import `* as secp256k1` from `@noble/secp256k1`. Import `bytesToHex`, `hexToBytes` from `@cipherbox/crypto`. Import `generateFactorKey`, `TssShareType`, `FactorKeyTypeShareDescription` from `@web3auth/mpc-core-kit`.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles. All crypto imports resolve. The hook can be instantiated without errors (no missing deps).
</verify>
<done>deviceApprovalApi has 5 methods matching the bulletin board API. useDeviceApproval handles both requester (create, poll, receive) and approver (poll pending, approve, deny) sides with proper ECIES key exchange and ephemeral key cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Cross-device UI components + Login.tsx integration</name>
  <files>
    apps/web/src/components/mfa/DeviceApprovalModal.tsx
    apps/web/src/components/mfa/DeviceWaitingScreen.tsx
    apps/web/src/components/mfa/RecoveryInput.tsx
    apps/web/src/components/mfa/MfaEnrollmentPrompt.tsx
    apps/web/src/routes/Login.tsx
  </files>
  <action>
**DeviceWaitingScreen** (`DeviceWaitingScreen.tsx`):
Full-screen component shown when `isRequiredShare === true`.
Props: `onRecoveryFallback: () => void`, `onApprovalComplete: () => void`.
Uses `useDeviceApproval()` hook.

Layout (matching CONTEXT.md):

- Centered card on dark background
- "Waiting for device approval..." heading
- Spinner animation (CSS, no external library)
- Countdown timer showing time remaining (5 minutes from request creation)
  - Timer in red (#EF4444) when < 3 minutes remaining (per CONTEXT.md)
- Device request status text (e.g., "Request sent to your other devices")
- "Use recovery phrase instead" link/button calling `onRecoveryFallback`
- When `approvalStatus === 'approved'`: auto-complete flow via `onApprovalComplete`
- When `approvalStatus === 'denied'`: show "Request was denied" message with retry option
- When `approvalStatus === 'expired'`: show "Request expired" with retry option and recovery fallback

On mount: auto-call `requestApproval()` to create the bulletin board request.
On unmount: call `cancelRequest()` to clean up.

**RecoveryInput** (`RecoveryInput.tsx`):
Props: `onRecoveryComplete: () => void`, `onBack: () => void`.
Uses `useMfa()` hook for `recoverWithMnemonic()`.

Layout:

- Heading: "Enter your recovery phrase"
- 24 input fields in a 4-column grid (or a single textarea accepting space-separated words)
  - Prefer single textarea for simplicity: monospace, placeholder "Enter your 24-word recovery phrase..."
  - Auto-trim and lowercase on submit
- `--recover` button (green) and `--back` button
- Error message area for invalid phrase
- Loading state during recovery

On successful recovery: call `onRecoveryComplete()`.

IMPORTANT: After successful recovery via `recoverWithMnemonic()`, also cancel any pending approval request (RESEARCH.md Pitfall 5). The DeviceWaitingScreen should pass its cancel function down, or RecoveryInput should have access to `useDeviceApproval().cancelRequest()`.

**DeviceApprovalModal** (`DeviceApprovalModal.tsx`):
Modal overlay shown on existing (already logged-in) device when pending approval requests exist.
Uses `useDeviceApproval()` hook.

Layout (matching Pencil mockup Frame Bxate):

- Backdrop: `#000000CC` overlay dimming the file browser
- Modal card with `#00D084` (green) border
- Heading: "Device Approval Request"
- Device details: name, request time, expiry countdown
- Red warning: "Only approve if YOU are trying to log in on another device"
- Two buttons: `--deny` (red outline `#EF4444`) and `--approve` (green filled `#00D084`)
- Clicking `--approve` calls `approveRequest()` with the requestId and ephemeralPublicKey
- Clicking `--deny` calls `denyRequest()`
- Modal closes after response
- If multiple pending requests, show them one at a time (queue)

Mount this modal at the app layout level (not just Settings). It should appear whenever the user has a pending approval request, regardless of which page they're on. Best location: in the FilesPage or main app layout component. Check where the existing modal pattern is mounted.

**MfaEnrollmentPrompt** (`MfaEnrollmentPrompt.tsx`):
Dismissable banner/toast shown after first login when MFA is not enabled.
Uses `useMfa()` for `checkMfaStatus()` and `useMfaStore` for `hasSeenPrompt` / `dismissPrompt()`.

Layout:

- Compact banner at top of file browser (not blocking, not modal)
- Text: "Secure your account with MFA" + brief description
- `--setup-mfa` button linking to Settings > Security tab
- `--dismiss` button that calls `dismissPrompt()` and hides the banner
- Only shows if: MFA not enabled AND hasSeenPrompt is false AND user just logged in
- Persistence: `hasSeenPrompt` in mfa.store (memory-only -- shows again after browser refresh). For cross-session persistence, also store a flag in `localStorage` keyed by user ID: `mfa_prompt_dismissed_{userId}`. Check both: store OR localStorage flag.

**Login.tsx** -- REQUIRED_SHARE integration:
Current Login.tsx renders the Google/email/wallet login forms. Add handling for REQUIRED_SHARE state:

1. Import `useAuth` and check `isRequiredShare`
2. When `isRequiredShare === true`, instead of the login form, render:
   - `DeviceWaitingScreen` with recovery fallback
   - Or `RecoveryInput` if user clicks "Use recovery phrase"
   - Use local state to toggle between waiting and recovery views

3. When approval or recovery completes, call `completeRequiredShare()` from useAuth.

The state machine for Login.tsx:

- `idle` -> normal login form
- `required_share` -> DeviceWaitingScreen (or RecoveryInput)
- `login_complete` -> navigate to /files

Check `isRequiredShare` from `useAuth()` return value (added in Plan 02). Also need `completeRequiredShare` and `pendingAuthMethod` from useAuth.

Mount `DeviceApprovalModal` -- find the appropriate place in the component tree where it's always rendered when the user is logged in. Likely in `SettingsPage.tsx` or `FilesPage.tsx`, or the main App router. The modal uses `useDeviceApproval().pendingRequests` and only renders when there are pending requests AND the user is fully logged in (not in REQUIRED_SHARE state themselves).

Add the approval polling start to the auth flow. In `useAuth.ts` or in a new hook that's mounted in the App component, start polling for pending approval requests when the user is logged in with MFA enabled. Use `useDeviceApproval().pollPendingRequests()`. This could be done via a `useEffect` in the main layout that runs when `isAuthenticated && isMfaEnabled`.
</action>
<verify>
`cd /Users/michael/Code/cipher-box && pnpm --filter web build` compiles. Navigate to Login page -- for non-MFA users, normal login flow works. For MFA users on new device (test by clearing Core Kit localStorage for that user), the REQUIRED_SHARE state triggers and shows DeviceWaitingScreen. Recovery phrase input field accepts 24 words. MFA enrollment prompt appears after first login for non-MFA users.
</verify>
<done>Cross-device approval flow works end-to-end: new device creates request and waits, existing device sees modal and can approve/deny, factor key is transferred via ECIES, login completes. Recovery phrase input is available as fallback. MFA enrollment prompt nudges non-MFA users once.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter web build` succeeds
2. DeviceWaitingScreen renders with spinner, countdown, and recovery fallback
3. RecoveryInput accepts 24 words and triggers recovery flow
4. DeviceApprovalModal appears on existing device with approve/deny
5. ECIES key exchange works: approve -> encrypted factor key -> decrypt -> inputFactorKey -> LOGGED_IN
6. Pending approval request is cancelled when recovery phrase is used instead
7. Ephemeral private keys are zero-filled after use
8. MfaEnrollmentPrompt shows once and is dismissable
9. Login.tsx properly renders REQUIRED_SHARE state
</verification>

<success_criteria>

- New device flow: login -> REQUIRED_SHARE -> DeviceWaitingScreen -> (approval or recovery) -> LOGGED_IN -> vault loaded
- Existing device flow: pending request detected -> DeviceApprovalModal -> approve/deny -> factor encrypted/response sent
- Recovery flow: 24-word input -> mnemonicToKey -> inputFactorKey -> device factor created -> LOGGED_IN
- MFA enrollment prompt: shows once per session for non-MFA users, dismissable, links to Settings > Security
- All terminal aesthetic UI: --approve/--deny/--recover/--back/--dismiss button labels
  </success_criteria>

<output>
After completion, create `.planning/phases/12.4-mfa-cross-device/12.4-04-SUMMARY.md`
</output>
