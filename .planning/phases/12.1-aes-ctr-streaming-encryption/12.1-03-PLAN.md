---
phase: 12.1-aes-ctr-streaming-encryption
plan: 03
type: execute
wave: 2
depends_on: ['12.1-01']
files_modified:
  - apps/web/src/workers/decrypt-sw.ts
  - apps/web/src/lib/sw-registration.ts
  - apps/web/src/main.tsx
  - apps/web/vite.config.ts
autonomous: true

must_haves:
  truths:
    - 'Service Worker intercepts fetch requests to /decrypt-stream/* URLs'
    - 'SW decrypts CTR-encrypted content using registered file key + IV'
    - 'SW returns proper 206 Partial Content with Content-Range for Range requests'
    - 'SW returns full 200 response with Accept-Ranges: bytes when no Range header'
    - 'Main thread can register decryption contexts and auth tokens via postMessage'
    - 'SW is registered on app startup and claims clients immediately'
  artifacts:
    - path: 'apps/web/src/workers/decrypt-sw.ts'
      provides: 'Service Worker for transparent decrypt proxy'
      min_lines: 100
    - path: 'apps/web/src/lib/sw-registration.ts'
      provides: 'SW registration and communication helpers'
      exports: ['registerDecryptSW', 'sendToSW', 'isSwActive', 'waitForSW']
    - path: 'apps/web/src/main.tsx'
      provides: 'SW registration on app boot'
      contains: 'registerDecryptSW'
  key_links:
    - from: 'apps/web/src/workers/decrypt-sw.ts'
      to: 'crypto.subtle'
      via: 'AES-CTR decrypt in SW context'
      pattern: 'AES-CTR'
    - from: 'apps/web/src/lib/sw-registration.ts'
      to: 'apps/web/src/workers/decrypt-sw.ts'
      via: 'navigator.serviceWorker.register'
      pattern: 'register.*decrypt-sw'
    - from: 'apps/web/src/main.tsx'
      to: 'apps/web/src/lib/sw-registration.ts'
      via: 'import and call registerDecryptSW'
      pattern: 'registerDecryptSW'
---

<objective>
Create the Service Worker that transparently decrypts CTR-encrypted media files for in-browser playback.

Purpose: The SW intercepts fetch requests from `<video>` and `<audio>` elements for `/decrypt-stream/*` URLs, fetches the encrypted content from the API, decrypts it with AES-CTR, caches the decrypted result, and returns proper HTTP responses (200/206). This makes encryption completely invisible to the media elements.

Output: decrypt-sw.ts (Service Worker), sw-registration.ts (lifecycle helpers), updated main.tsx (registration), updated Vite config (SW build).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-RESEARCH.md

# Prior plan for CTR decrypt functions

@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-01-SUMMARY.md

# Existing app bootstrap

@apps/web/src/main.tsx
@apps/web/vite.config.ts
@apps/web/src/lib/api/ipfs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Service Worker for decrypt proxy</name>
  <files>
    apps/web/src/workers/decrypt-sw.ts
  </files>
  <action>
    Create `apps/web/src/workers/decrypt-sw.ts`. This file will be compiled by Vite and served as a standalone SW script.

    **Top-level declarations:**

    ```typescript
    declare const self: ServiceWorkerGlobalScope;
    ```

    **Stream Registry** (Map of active decrypt contexts):
    ```typescript
    type StreamContext = {
      fileKey: string;       // hex-encoded AES-256 key
      iv: string;            // hex-encoded 16-byte CTR IV
      cid: string;           // IPFS CID of encrypted content
      totalSize: number;     // Original file size in bytes
      mimeType: string;      // MIME type for response
    };
    const streamRegistry = new Map<string, StreamContext>();
    ```

    **Auth token storage:**
    ```typescript
    let authToken: string | null = null;
    let apiBaseUrl: string = '';
    ```

    **Decrypted file cache** (in-memory cache of full encrypted files for seeking):
    ```typescript
    const encryptedCache = new Map<string, Uint8Array>();
    ```

    **Message handler** (main thread -> SW communication):
    Handle these message types via `self.addEventListener('message', ...)`:
    - `type: 'register-stream'`: Store StreamContext in registry keyed by `data.fileMetaIpnsName`
    - `type: 'unregister-stream'`: Remove from registry and encryptedCache
    - `type: 'update-token'`: Update `authToken` with `data.token`
    - `type: 'set-api-base'`: Set `apiBaseUrl` with `data.url`

    **Install handler**: `self.addEventListener('install', () => self.skipWaiting())`

    **Activate handler**: `self.addEventListener('activate', (event) => event.waitUntil(self.clients.claim()))`

    **Fetch handler** (`self.addEventListener('fetch', ...)`):
    1. Parse URL: only intercept if pathname starts with `/decrypt-stream/`
    2. Extract `ipnsName` from pathname: `url.pathname.split('/decrypt-stream/')[1]`
    3. Look up StreamContext in registry. If not found, return `new Response('Not found', { status: 404 })`
    4. Call `event.respondWith(handleDecryptStream(event.request, ctx, ipnsName))`
    5. For all other URLs: do nothing (fall through to network)

    **handleDecryptStream(request, ctx, cacheKey):**
    1. Check if encrypted data is already cached in `encryptedCache`
    2. If not cached: fetch from `${apiBaseUrl}/ipfs/${ctx.cid}` with `Authorization: Bearer ${authToken}` header
       - On 401: post message to all clients requesting token refresh, return 401 response
       - On success: store `new Uint8Array(await response.arrayBuffer())` in `encryptedCache.set(cacheKey, data)`
    3. Parse `Range` header from request: `request.headers.get('Range')`
    4. If Range header present: parse `bytes=start-end` format
       - If missing end: use `ctx.totalSize - 1`
    5. If no Range header: use full range `[0, ctx.totalSize - 1]`
    6. **Decrypt the range:**
       - Use inline CTR range-decrypt logic (cannot import from @cipherbox/crypto in SW context):
         a. `hexToBytes()` helper to convert key and IV from hex
         b. Compute `startBlock = Math.floor(start / 16)`
         c. Build counter: copy first 8 bytes of IV, set bytes 8-15 to `baseCounter + BigInt(startBlock)` using DataView
         d. Read `baseCounter` from IV bytes 8-15 via `DataView.getBigUint64(8, false)`
         e. Import key: `crypto.subtle.importKey('raw', keyBytes, { name: 'AES-CTR' }, false, ['decrypt'])`
         f. Compute block-aligned range: `blockAlignedStart = startBlock * 16`, `blockAlignedEnd = Math.min((Math.floor(end / 16) + 1) * 16, encrypted.length)`
         g. Slice encrypted data to block-aligned range
         h. Decrypt: `crypto.subtle.decrypt({ name: 'AES-CTR', counter, length: 64 }, cryptoKey, slice)`
         i. Extract exact bytes: `offsetInFirstBlock = start - blockAlignedStart`, slice result
    7. **Build response:**
       - If Range was requested: status 206, headers: Content-Type, Content-Length, Content-Range (`bytes start-end/totalSize`), Accept-Ranges: bytes
       - If no Range: status 200, headers: Content-Type, Content-Length, Accept-Ranges: bytes
    8. Return `new Response(decrypted, { status, headers })`

    **hexToBytes helper** (inline in SW, cannot import from packages):
    ```typescript
    function hexToBytes(hex: string): Uint8Array {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
      }
      return bytes;
    }
    ```

    **Important notes:**
    - The SW cannot import from @cipherbox/crypto (it runs in a separate context without module bundling). All crypto helpers must be inlined.
    - Use `crypto.subtle` directly (available in ServiceWorkerGlobalScope).
    - The SW caches the full encrypted file in memory on first request, then decrypts ranges from cache for seeking. This works because files are max 100MB.
    - Do NOT use `.buffer` on Uint8Array for any Blob/Response construction.

  </action>
  <verify>
    File compiles without TypeScript errors when built as a standalone worker.
    `pnpm --filter web build` succeeds (Vite builds the SW file).
  </verify>
  <done>
    Service Worker intercepts /decrypt-stream/* URLs, fetches encrypted content from API, decrypts CTR ranges, returns proper 200/206 responses.
    Encrypted file cache enables instant seeking after initial load.
    Auth token management via postMessage.
    Stream contexts registered/unregistered via postMessage.
  </done>
</task>

<task type="auto">
  <name>Task 2: SW registration, Vite config, and app bootstrap</name>
  <files>
    apps/web/src/lib/sw-registration.ts
    apps/web/src/main.tsx
    apps/web/vite.config.ts
  </files>
  <action>
    **Create `sw-registration.ts`** with these exports:

    1. **`registerDecryptSW(): Promise<ServiceWorkerRegistration | null>`**
       - Check `'serviceWorker' in navigator` -- return null if not supported
       - Register `/decrypt-sw.js` with `{ scope: '/' }`
       - `await navigator.serviceWorker.ready`
       - Return registration
       - Catch and log errors, return null

    2. **`sendToSW(message: unknown): void`**
       - `navigator.serviceWorker.controller?.postMessage(message)`

    3. **`isSwActive(): boolean`**
       - `return !!navigator.serviceWorker.controller`

    4. **`waitForSW(): Promise<void>`**
       - If `navigator.serviceWorker.controller` exists, resolve immediately
       - Otherwise, listen for `controllerchange` event and resolve when fired
       - Timeout after 5 seconds (resolve anyway -- fallback to blob URL approach)

    5. **`updateSwToken(token: string): void`**
       - `sendToSW({ type: 'update-token', token })`

    6. **`setSwApiBase(url: string): void`**
       - `sendToSW({ type: 'set-api-base', url })`

    7. **`registerStream(params: { fileMetaIpnsName: string; fileKey: string; iv: string; cid: string; totalSize: number; mimeType: string }): void`**
       - `sendToSW({ type: 'register-stream', ...params })`

    8. **`unregisterStream(fileMetaIpnsName: string): void`**
       - `sendToSW({ type: 'unregister-stream', fileMetaIpnsName })`

    **Update Vite config** (`apps/web/vite.config.ts`):
    The SW file needs to be built as a standalone script. Two approaches:
    - **Option A (preferred):** Use Vite's built-in worker support. Create a build step that compiles `src/workers/decrypt-sw.ts` to `public/decrypt-sw.js` via a Vite plugin or a manual build script.
    - **Option B (simpler):** Use `vite-plugin-static-copy` or configure Vite's `build.rollupOptions` to emit the SW as a separate entry.

    The simplest approach: Add a custom Vite plugin that uses `build.rollupOptions.input` to include the SW as an additional entry, or use Vite's `worker` configuration. Alternatively, if the SW is simple enough, place it as a plain JS file at `apps/web/public/decrypt-sw.js` with the TypeScript compiled manually.

    **Recommended approach:** Use Vite's `build.lib` entry point pattern OR simply add the SW file path to Vite's build inputs. Check the existing vite.config.ts structure and add the SW as an additional entry point. The key requirement is that `decrypt-sw.js` is served at the root URL path `/decrypt-sw.js`.

    If the existing Vite config is simple, the easiest path is:
    - Keep `decrypt-sw.ts` as the source
    - Add a Vite plugin that builds it separately (e.g., using `vite-plugin-pwa`'s `injectManifest` mode, or a simpler custom plugin)
    - OR: write a small build script that uses `esbuild` to compile `decrypt-sw.ts` to `public/decrypt-sw.js` and add it to the `build` script

    Actually, the simplest working approach: write the SW as TypeScript in `src/workers/decrypt-sw.ts` and configure Vite to compile it to the `public` directory during build. Or use the `worker` URL pattern with `new URL('./workers/decrypt-sw.ts', import.meta.url)` and `{ type: 'classic' }` in the registration. Check Vite docs for the recommended pattern.

    After investigation, the most reliable approach for a Service Worker in Vite:
    - In `sw-registration.ts`, register using a URL that resolves via Vite:
      ```typescript
      const swUrl = import.meta.env.DEV
        ? '/src/workers/decrypt-sw.ts'  // Vite dev server serves TS directly
        : '/decrypt-sw.js';  // Built output
      ```
    - For production build: add decrypt-sw.ts as a separate Rollup input in vite.config.ts:
      ```typescript
      build: {
        rollupOptions: {
          input: {
            main: resolve(__dirname, 'index.html'),
            'decrypt-sw': resolve(__dirname, 'src/workers/decrypt-sw.ts'),
          },
          output: {
            entryFileNames: (chunkInfo) => {
              if (chunkInfo.name === 'decrypt-sw') return 'decrypt-sw.js';
              return 'assets/[name]-[hash].js';
            },
          },
        },
      }
      ```

    Investigate the existing vite.config.ts and choose the approach that fits best. The critical requirement: `/decrypt-sw.js` is accessible at the root of the served app in both dev and production.

    **Update main.tsx:**
    - Import `registerDecryptSW, setSwApiBase, updateSwToken` from '../lib/sw-registration'
    - After the existing imports but before `createRoot`, add:
      ```typescript
      // Register Service Worker for streaming media decryption
      registerDecryptSW().then(() => {
        const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:3000';
        setSwApiBase(apiUrl);
      });
      ```
    - Also set up token sync: subscribe to auth store token changes and forward to SW.
      Import `useAuthStore` and add a subscriber:
      ```typescript
      // Keep SW auth token in sync
      useAuthStore.subscribe(
        (state) => state.accessToken,
        (token) => {
          if (token) updateSwToken(token);
        }
      );
      ```
      NOTE: Zustand's `subscribe` with selector requires the `subscribeWithSelector` middleware. Check if the auth store already uses it. If not, use the simpler pattern:
      ```typescript
      useAuthStore.subscribe((state) => {
        if (state.accessToken) updateSwToken(state.accessToken);
      });
      ```
      Place this AFTER `registerDecryptSW()` completes.

    **Important:** The SW registration must not block app rendering. Use `.then()` not `await` at the top level.

  </action>
  <verify>
    `pnpm --filter web build` succeeds.
    `pnpm --filter web dev` starts and `/decrypt-sw.js` (or equivalent) is accessible at the root.
    No console errors on app load related to SW registration.
    `navigator.serviceWorker.controller` is non-null after first page load + refresh.
  </verify>
  <done>
    Service Worker is compiled and served at /decrypt-sw.js.
    SW is registered on app startup via registerDecryptSW().
    API base URL is sent to SW on init.
    Auth token is synced to SW whenever it changes.
    Helper functions exported for registering/unregistering decrypt streams.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` succeeds
- `pnpm --filter web dev` starts without SW errors
- After page load + refresh, `navigator.serviceWorker.controller` is non-null
- Fetching `/decrypt-stream/test` returns 404 (no registered stream, but SW intercepts)
- `pnpm lint` passes
</verification>

<success_criteria>

- SW intercepts /decrypt-stream/\* URLs and returns 404 for unregistered streams
- SW install uses skipWaiting(), activate uses clients.claim()
- Main thread to SW communication works (register-stream, update-token, set-api-base)
- SW compiles and loads in both dev and production builds
- No errors in console on app startup related to SW
  </success_criteria>

<output>
After completion, create `.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-03-SUMMARY.md`
</output>
