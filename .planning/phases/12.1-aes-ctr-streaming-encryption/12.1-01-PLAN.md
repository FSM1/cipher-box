---
phase: 12.1-aes-ctr-streaming-encryption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/constants.ts
  - packages/crypto/src/aes/encrypt-ctr.ts
  - packages/crypto/src/aes/decrypt-ctr.ts
  - packages/crypto/src/aes/index.ts
  - packages/crypto/src/utils/random.ts
  - packages/crypto/src/utils/index.ts
  - packages/crypto/src/index.ts
  - packages/crypto/src/__tests__/aes-ctr.test.ts
autonomous: true

must_haves:
  truths:
    - 'AES-256-CTR encrypt and decrypt produce identical plaintext round-trip'
    - 'Random-access CTR decryption at arbitrary byte offset produces correct output'
    - 'CTR IV is 16 bytes with 8-byte random nonce + 8-byte zero counter'
    - 'Counter length is 64 bits, supporting files up to 2^64 * 16 bytes'
  artifacts:
    - path: 'packages/crypto/src/aes/encrypt-ctr.ts'
      provides: 'AES-256-CTR full-buffer encryption'
      exports: ['encryptAesCtr']
    - path: 'packages/crypto/src/aes/decrypt-ctr.ts'
      provides: 'AES-256-CTR full-buffer and range decryption'
      exports: ['decryptAesCtr', 'decryptAesCtrRange']
    - path: 'packages/crypto/src/constants.ts'
      provides: 'CTR constants'
      contains: 'AES_CTR_IV_SIZE'
    - path: 'packages/crypto/src/__tests__/aes-ctr.test.ts'
      provides: 'CTR encryption test suite'
      min_lines: 50
  key_links:
    - from: 'packages/crypto/src/aes/encrypt-ctr.ts'
      to: 'crypto.subtle'
      via: 'Web Crypto AES-CTR algorithm'
      pattern: 'AES-CTR.*counter.*length.*64'
    - from: 'packages/crypto/src/aes/decrypt-ctr.ts'
      to: 'crypto.subtle'
      via: 'Web Crypto AES-CTR with computed counter offset'
      pattern: 'setBigUint64'
---

<objective>
Add AES-256-CTR encryption and decryption primitives to the @cipherbox/crypto package.

Purpose: CTR mode enables random-access decryption (any byte range without processing preceding bytes), which is required for Service Worker streaming media playback. GCM does not support this because it requires processing the entire ciphertext for authentication tag verification.

Output: encryptAesCtr(), decryptAesCtr(), decryptAesCtrRange() functions, CTR constants, generateCtrIv(), and test suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-RESEARCH.md

# Existing crypto package patterns to follow

@packages/crypto/src/aes/encrypt.ts
@packages/crypto/src/aes/decrypt.ts
@packages/crypto/src/constants.ts
@packages/crypto/src/utils/random.ts
@packages/crypto/src/aes/index.ts
@packages/crypto/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: CTR constants and IV generation</name>
  <files>
    packages/crypto/src/constants.ts
    packages/crypto/src/utils/random.ts
    packages/crypto/src/utils/index.ts
  </files>
  <action>
    Add CTR-specific constants to constants.ts:
    - `AES_CTR_IV_SIZE = 16` (full 16-byte counter block)
    - `AES_CTR_NONCE_SIZE = 8` (random nonce portion)
    - `AES_CTR_LENGTH = 64` (counter bits for Web Crypto AesCtrParams.length)
    - `AES_CTR_ALGORITHM = 'AES-CTR'` (algorithm name for Web Crypto)

    Add `generateCtrIv()` to random.ts:
    - Returns a 16-byte Uint8Array
    - First 8 bytes: cryptographically random nonce via `crypto.getRandomValues()`
    - Last 8 bytes: zero (initial counter starts at 0)
    - Use the existing `generateRandomBytes()` pattern but with CTR_NONCE_SIZE for the random part
    - Add JSDoc explaining the 8/8 nonce/counter split and why counter starts at 0

    Export `generateCtrIv` from utils/index.ts.

    Do NOT modify the existing `generateIv()` function -- it remains GCM-specific (12 bytes).

  </action>
  <verify>
    `pnpm --filter @cipherbox/crypto build` succeeds.
    New constants are importable: `import { AES_CTR_IV_SIZE, AES_CTR_LENGTH } from '@cipherbox/crypto'`.
  </verify>
  <done>
    CTR constants (AES_CTR_IV_SIZE=16, AES_CTR_NONCE_SIZE=8, AES_CTR_LENGTH=64, AES_CTR_ALGORITHM) exist in constants.ts.
    generateCtrIv() returns a 16-byte array with random first 8 bytes and zero last 8 bytes.
    All exports wired through index.ts barrel files.
  </done>
</task>

<task type="auto">
  <name>Task 2: CTR encrypt, decrypt, and range-decrypt functions</name>
  <files>
    packages/crypto/src/aes/encrypt-ctr.ts
    packages/crypto/src/aes/decrypt-ctr.ts
    packages/crypto/src/aes/index.ts
    packages/crypto/src/index.ts
  </files>
  <action>
    Create `encrypt-ctr.ts` following the pattern of encrypt.ts:
    - `encryptAesCtr(plaintext: Uint8Array, key: Uint8Array, iv: Uint8Array): Promise<Uint8Array>`
    - Validate key length === AES_KEY_SIZE (32)
    - Validate iv length === AES_CTR_IV_SIZE (16)
    - Import key with `{ name: AES_CTR_ALGORITHM }` and usage `['encrypt']`
    - Encrypt with `{ name: AES_CTR_ALGORITHM, counter: iv, length: AES_CTR_LENGTH }`
    - Return `new Uint8Array(ciphertext)` -- note: CTR output is same size as input (no auth tag)
    - Throw CryptoError with generic messages on failure (same pattern as GCM)
    - Copy input buffers to avoid SharedArrayBuffer issues (same pattern as GCM)

    Create `decrypt-ctr.ts`:
    - `decryptAesCtr(ciphertext: Uint8Array, key: Uint8Array, iv: Uint8Array): Promise<Uint8Array>`
      Full-buffer decrypt. Same validation and pattern as encrypt but with `['decrypt']` usage.

    - `decryptAesCtrRange(ciphertext: Uint8Array, key: Uint8Array, iv: Uint8Array, startByte: number, endByte: number): Promise<Uint8Array>`
      Random-access range decrypt. This is the critical function for Service Worker streaming:
      1. Compute `startBlock = Math.floor(startByte / 16)` and `endBlock = Math.floor(endByte / 16)`
      2. Compute block-aligned byte range: `blockAlignedStart = startBlock * 16`, `blockAlignedEnd = (endBlock + 1) * 16`
      3. Build counter for starting block: copy first 8 bytes of iv (nonce), then set bytes 8-15 to `baseCounter + BigInt(startBlock)` using `DataView.setBigUint64(8, value, false)` (big-endian)
      4. Read `baseCounter` from iv using `new DataView(new Uint8Array(iv).buffer).getBigUint64(8, false)`
      5. Slice ciphertext to `[blockAlignedStart, Math.min(blockAlignedEnd, ciphertext.length)]`
      6. Decrypt the sliced block-aligned range with computed counter
      7. Extract exact requested bytes: `offsetInFirstBlock = startByte - blockAlignedStart`, return `subarray(offsetInFirstBlock, offsetInFirstBlock + (endByte - startByte + 1))`
      8. Handle edge case: endByte >= ciphertext.length (clamp to actual data)
      9. Validate startByte <= endByte, both >= 0

    Update aes/index.ts to export: `encryptAesCtr` from './encrypt-ctr' and `decryptAesCtr, decryptAesCtrRange` from './decrypt-ctr'.

    Update the root index.ts to export the new functions and CTR constants:
    - Add `encryptAesCtr, decryptAesCtr, decryptAesCtrRange` to the AES exports
    - Add `AES_CTR_IV_SIZE, AES_CTR_NONCE_SIZE, AES_CTR_LENGTH, AES_CTR_ALGORITHM` to the constants exports
    - Add `generateCtrIv` to the utils exports

  </action>
  <verify>
    `pnpm --filter @cipherbox/crypto build` succeeds.
    `import { encryptAesCtr, decryptAesCtr, decryptAesCtrRange, generateCtrIv } from '@cipherbox/crypto'` resolves.
  </verify>
  <done>
    encryptAesCtr() encrypts data using AES-256-CTR with Web Crypto API.
    decryptAesCtr() decrypts full CTR ciphertext.
    decryptAesCtrRange() decrypts an arbitrary byte range using computed counter offset.
    All functions exported from @cipherbox/crypto package.
  </done>
</task>

<task type="auto">
  <name>Task 3: CTR encryption test suite</name>
  <files>
    packages/crypto/src/__tests__/aes-ctr.test.ts
  </files>
  <action>
    Create a test file following the existing test patterns in packages/crypto/src/__tests__/.

    Test cases:
    1. **Round-trip**: encrypt then decrypt produces original plaintext for various sizes (empty, 1 byte, 15 bytes, 16 bytes, 17 bytes, 1MB)
    2. **CTR output size**: encrypted size === plaintext size (no auth tag, unlike GCM which adds 16 bytes)
    3. **Range decrypt**: encrypt a known buffer (e.g., 256 bytes of sequential values 0-255), then decryptAesCtrRange at various offsets:
       - Range [0, 15] (first block)
       - Range [16, 31] (second block)
       - Range [10, 25] (spanning two blocks, not block-aligned)
       - Range [0, 255] (entire file)
       - Range [240, 255] (last block)
       - Range [100, 100] (single byte)
       - Each must produce the same bytes as the corresponding plaintext slice
    4. **Different key produces different ciphertext**: same plaintext + IV with different key produces different output
    5. **Different nonce produces different ciphertext**: same plaintext + key with different IV produces different output
    6. **Invalid key size rejects**: key of wrong size throws CryptoError
    7. **Invalid IV size rejects**: IV of wrong size throws CryptoError
    8. **generateCtrIv format**: returns 16 bytes, last 8 bytes are all zero, first 8 bytes are not all zero (probabilistic -- run 10 times, at least one should have non-zero first byte)
    9. **Large file range**: create a 1MB buffer, encrypt, then decryptAesCtrRange for a range in the middle (offset 500000-500999). Must match plaintext[500000..500999].

    Use `generateFileKey()` for test keys and `generateCtrIv()` for test IVs.
    Import CryptoError for error assertions.
    Use `vitest` (describe/it/expect) -- check existing test files for the test runner pattern used.

  </action>
  <verify>
    `pnpm --filter @cipherbox/crypto test` passes all CTR tests.
  </verify>
  <done>
    Test suite covers round-trip, output size, range decrypt at various offsets, key/IV uniqueness, input validation, generateCtrIv format, and large-file range decrypt.
    All tests pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @cipherbox/crypto build` succeeds
- `pnpm --filter @cipherbox/crypto test` passes all new CTR tests
- `pnpm lint` passes (or at least no new lint errors)
- New exports are importable from `@cipherbox/crypto`
</verification>

<success_criteria>

- AES-256-CTR encrypt/decrypt round-trips correctly for all sizes
- Range decrypt produces correct bytes at arbitrary offsets (block-aligned and unaligned)
- Counter arithmetic uses BigInt for 64-bit counter space
- All functions follow existing CryptoError pattern
- generateCtrIv() produces 16-byte IV with 8/8 nonce/counter split
- Full test suite passes
  </success_criteria>

<output>
After completion, create `.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-01-SUMMARY.md`
</output>
