---
phase: 12.1-aes-ctr-streaming-encryption
plan: 04
type: execute
wave: 3
depends_on: ['12.1-01', '12.1-02', '12.1-03']
files_modified:
  - apps/web/src/services/download.service.ts
  - apps/web/src/hooks/useFilePreview.ts
  - apps/web/src/hooks/useStreamingPreview.ts
  - apps/web/src/components/file-browser/VideoPlayerDialog.tsx
  - apps/web/src/components/file-browser/AudioPlayerDialog.tsx
  - apps/web/src/styles/video-player-dialog.css
  - apps/web/src/styles/audio-player-dialog.css
autonomous: true

must_haves:
  truths:
    - 'CTR-encrypted media files play in-browser without downloading the entire file first'
    - 'Video player shows decrypt/loading progress while SW fetches and caches encrypted content'
    - 'Audio player shows decrypt/loading progress while SW fetches and caches encrypted content'
    - 'GCM files continue to use the existing blob URL preview path with no behavior change'
    - 'User can seek within a CTR-encrypted video and playback resumes from the seek position'
    - 'Player UI shows CipherBox decrypt progress bar during initial load'
  artifacts:
    - path: 'apps/web/src/hooks/useStreamingPreview.ts'
      provides: 'Hook for SW-based streaming media preview'
      exports: ['useStreamingPreview']
    - path: 'apps/web/src/services/download.service.ts'
      provides: 'Mode-aware download supporting CTR'
      exports: ['downloadFile']
    - path: 'apps/web/src/components/file-browser/VideoPlayerDialog.tsx'
      provides: 'Video player with streaming decrypt support'
      min_lines: 100
    - path: 'apps/web/src/components/file-browser/AudioPlayerDialog.tsx'
      provides: 'Audio player with streaming decrypt support'
      min_lines: 100
  key_links:
    - from: 'apps/web/src/hooks/useStreamingPreview.ts'
      to: 'apps/web/src/lib/sw-registration.ts'
      via: 'registerStream + isSwActive'
      pattern: 'registerStream|isSwActive'
    - from: 'apps/web/src/hooks/useStreamingPreview.ts'
      to: 'apps/web/src/services/file-metadata.service.ts'
      via: 'resolveFileMetadata to get CID and file key'
      pattern: 'resolveFileMetadata'
    - from: 'apps/web/src/components/file-browser/VideoPlayerDialog.tsx'
      to: 'apps/web/src/hooks/useStreamingPreview.ts'
      via: 'useStreamingPreview hook'
      pattern: 'useStreamingPreview'
---

<objective>
Wire the Service Worker into the media preview pipeline so CTR-encrypted files stream through the SW for playback, with decrypt progress UI in the video and audio player dialogs.

Purpose: This is the integration layer that connects the crypto primitives (Plan 01), upload pipeline (Plan 02), and Service Worker (Plan 03) into a working end-to-end streaming media experience. The user sees their encrypted video/audio start playing while the SW fetches and caches the encrypted content, with a CipherBox-branded decrypt progress indicator.

Output: useStreamingPreview hook (SW-based media preview), mode-aware download service, updated VideoPlayerDialog and AudioPlayerDialog with decrypt progress bar and buffering states.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-RESEARCH.md

# Prior plan outputs

@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-01-SUMMARY.md
@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-02-SUMMARY.md
@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-03-SUMMARY.md

# Existing components to modify

@apps/web/src/hooks/useFilePreview.ts
@apps/web/src/services/download.service.ts
@apps/web/src/components/file-browser/VideoPlayerDialog.tsx
@apps/web/src/components/file-browser/AudioPlayerDialog.tsx
@apps/web/src/services/file-metadata.service.ts
@apps/web/src/lib/sw-registration.ts
@apps/web/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mode-aware download service and streaming preview hook</name>
  <files>
    apps/web/src/services/download.service.ts
    apps/web/src/hooks/useStreamingPreview.ts
  </files>
  <action>
    **Update download.service.ts:**
    Add CTR decryption support to `downloadFile()`:
    - Import `decryptAesCtr` from `@cipherbox/crypto`
    - Check `metadata.encryptionMode` (add to FileMetadata type or accept as parameter)
    - If 'CTR': use `decryptAesCtr(ciphertext, fileKey, iv)` instead of `decryptAesGcm`
    - Note: the IV for CTR is 16 bytes (not 12), so `hexToBytes(metadata.iv)` will produce the correct length
    - Also import `AES_CTR_IV_SIZE` to validate if needed
    - Add `encryptionMode?: 'GCM' | 'CTR'` to the local `FileMetadata` type (Pick type)

    Update `downloadFileFromIpns()`:
    - After resolving file metadata from IPNS, check `fileMeta.encryptionMode`
    - Pass it through to `downloadFile()` so the correct decrypt algorithm is used
    - The `resolveFileMetadata` return type already includes `encryptionMode` from Phase 12.6

    **Create `useStreamingPreview.ts` hook:**

    This hook handles the SW-based streaming preview flow for CTR-encrypted media files. It provides a `/decrypt-stream/*` URL that `<video>` and `<audio>` elements can use as their `src`.

    ```typescript
    type UseStreamingPreviewOptions = {
      open: boolean;
      item: FilePointer | null;
      mimeType: string;
      folderKey: Uint8Array | null;
    };

    type UseStreamingPreviewReturn = {
      loading: boolean;          // True during initial metadata resolution
      error: string | null;
      streamUrl: string | null;  // /decrypt-stream/{ipnsName} URL for media src
      decryptProgress: number;   // 0-100, tracks SW encrypted file fetch progress
      isSwReady: boolean;        // Whether SW is active and can handle requests
      handleDownload: () => void;
      cleanup: () => void;       // Unregister stream on close
    };
    ```

    **Hook logic:**
    1. On `open=true` with a valid item:
       a. Check `isSwActive()` -- if SW not active, set `isSwReady = false` (fallback to useFilePreview blob URL approach)
       b. Resolve file metadata from IPNS: `resolveFileMetadata(item.fileMetaIpnsName, folderKey)`
       c. Check `fileMeta.encryptionMode` -- if 'GCM' or undefined, this hook should NOT be used (caller should use useFilePreview instead). Set error or return a signal.
       d. Unwrap the file key: `unwrapKey(hexToBytes(fileMeta.fileKeyEncrypted), auth.vaultKeypair.privateKey)`
       e. Register stream with SW:
          ```typescript
          registerStream({
            fileMetaIpnsName: item.fileMetaIpnsName,
            fileKey: bytesToHex(fileKey),
            iv: fileMeta.fileIv,
            cid: fileMeta.cid,
            totalSize: fileMeta.size,
            mimeType: mimeType,
          });
          ```
       f. Clear the unwrapped file key from memory: `clearBytes(fileKey)`
       g. Set `streamUrl = '/decrypt-stream/' + item.fileMetaIpnsName`
       h. Set `loading = false`

    2. **Decrypt progress tracking:**
       Listen for messages from the SW via `navigator.serviceWorker.addEventListener('message', ...)`:
       - Message type `'fetch-progress'`: update `decryptProgress` with `data.loaded / data.total * 100`
       - Message type `'fetch-complete'`: set `decryptProgress = 100`
       - Message type `'fetch-error'`: set error state
       (This requires adding progress postMessage calls to the SW in decrypt-sw.ts -- add them to the fetch logic: as encrypted data streams in, post progress to the client that registered the stream.)

       **Update decrypt-sw.ts** to post progress messages during encrypted file fetch:
       When fetching from API, use `response.body.getReader()` to stream and track progress:
       ```typescript
       const reader = response.body.getReader();
       const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);
       const chunks: Uint8Array[] = [];
       let loaded = 0;
       while (true) {
         const { done, value } = await reader.read();
         if (done) break;
         chunks.push(value);
         loaded += value.length;
         // Post progress to all clients
         const clients = await self.clients.matchAll();
         for (const client of clients) {
           client.postMessage({ type: 'fetch-progress', fileMetaIpnsName: cacheKey, loaded, total: contentLength || ctx.totalSize });
         }
       }
       // Combine chunks and cache
       ```
       After caching: post `{ type: 'fetch-complete', fileMetaIpnsName: cacheKey }`.
       On error: post `{ type: 'fetch-error', fileMetaIpnsName: cacheKey, error: message }`.

    3. On `open=false` (dialog closing):
       - `unregisterStream(item.fileMetaIpnsName)` to clean up SW cache
       - Reset all state

    4. **handleDownload:** Download the full decrypted file using `downloadFileFromIpns()` (the existing non-streaming path).

    5. **Fallback behavior:** If `isSwActive()` returns false (first page load before SW activates), the caller should fall back to `useFilePreview` (blob URL approach). The hook returns `isSwReady = false` in this case.

    Import from: `@cipherbox/crypto` (unwrapKey, hexToBytes, bytesToHex, clearBytes), `../lib/sw-registration` (registerStream, unregisterStream, isSwActive), `../services/file-metadata.service` (resolveFileMetadata), `../stores/auth.store`.

  </action>
  <verify>
    `pnpm --filter web build` succeeds with no TypeScript errors.
    useStreamingPreview hook exports correctly.
    download.service.ts handles both CTR and GCM modes.
  </verify>
  <done>
    downloadFile() uses correct decryption algorithm based on encryptionMode.
    useStreamingPreview resolves file metadata, registers stream with SW, provides /decrypt-stream/* URL.
    Decrypt progress tracked via SW postMessage.
    Fallback to blob URL when SW not active.
    Stream cleanup on dialog close.
  </done>
</task>

<task type="auto">
  <name>Task 2: VideoPlayerDialog with streaming decrypt support</name>
  <files>
    apps/web/src/components/file-browser/VideoPlayerDialog.tsx
    apps/web/src/styles/video-player-dialog.css
  </files>
  <action>
    Update VideoPlayerDialog to support CTR streaming via the SW:

    1. **Import useStreamingPreview** alongside useFilePreview.

    2. **Determine preview mode based on file metadata:**
       The dialog needs to know if the file is CTR-encrypted to choose between streaming (SW) and blob URL (existing) preview. Since FilePointer doesn't contain encryptionMode, resolve it at the hook level.

       Add logic to detect media files by MIME type and use `useStreamingPreview` for those that might be CTR:
       ```typescript
       const isStreamingCandidate = item ? STREAMING_MIME_TYPES.has(getVideoMime(item.name)) : false;
       ```

       Use a two-phase approach:
       a. Try `useStreamingPreview` first for streaming MIME types
       b. If `!isSwReady` from useStreamingPreview, fall back to `useFilePreview` (blob URL)

       Implementation:
       ```typescript
       const streaming = useStreamingPreview({
         open: open && isStreamingCandidate,
         item,
         mimeType,
         folderKey,
       });

       const blobPreview = useFilePreview({
         open: open && (!isStreamingCandidate || !streaming.isSwReady),
         item,
         mimeType,
         folderKey,
       });

       // Use streaming if available, else blob
       const isStreaming = isStreamingCandidate && streaming.isSwReady && !streaming.error;
       const videoSrc = isStreaming ? streaming.streamUrl : blobPreview.objectUrl;
       const isLoading = isStreaming ? streaming.loading : blobPreview.loading;
       const previewError = isStreaming ? streaming.error : blobPreview.error;
       const onDownload = isStreaming ? streaming.handleDownload : blobPreview.handleDownload;
       ```

    3. **Add decrypt progress bar during loading:**
       When `isStreaming && streaming.decryptProgress < 100`, show a progress bar instead of just "decrypting...":
       ```tsx
       {isLoading || (isStreaming && streaming.decryptProgress < 100 && streaming.decryptProgress > 0) ? (
         <div className="video-preview-loading">
           <div className="video-decrypt-label">decrypting...</div>
           <div className="video-decrypt-progress-track">
             <div
               className="video-decrypt-progress-fill"
               style={{ width: `${streaming.decryptProgress}%` }}
             />
           </div>
           <div className="video-decrypt-percent">{Math.round(streaming.decryptProgress)}%</div>
         </div>
       ) : ...
       ```
       For non-streaming (GCM blob URL), keep the existing "decrypting..." text.

    4. **Set video src:**
       Use `videoSrc` (either `/decrypt-stream/*` URL or blob URL):
       ```tsx
       <video ref={videoRef} src={videoSrc || undefined} ... />
       ```

    5. **Add CipherBox branding badge** on the video screen:
       A small "CIPHERBOX DECRYPT" or lock icon badge in the corner when streaming is active. Use CSS.

    6. **Cleanup on close:**
       In the close handler, call `streaming.cleanup()` to unregister the stream.

    7. **Handle the case where streaming.error is a "not CTR" signal:**
       If the file turns out to be GCM (useStreamingPreview sets an error or returns a signal), automatically use the blob preview fallback. This should already work with the `isStreaming` conditional above.

    **CSS updates** in video-player-dialog.css:
    - `.video-decrypt-progress-track`: Full-width bar container, dark background, 4px height, margin
    - `.video-decrypt-progress-fill`: Green fill (`#00D084`), height 100%, transition width 0.3s
    - `.video-decrypt-percent`: Monospace text below progress bar, green color
    - `.video-decrypt-label`: "decrypting..." text, terminal aesthetic
    - `.video-cipher-badge`: Small badge for "ENCRYPTED" indicator, positioned absolute top-right of video screen

    Follow the terminal/hacker aesthetic of the existing CipherBox UI (monospace fonts, green-on-dark).
    Follow `apps/web/CLAUDE.md` guidelines: modern CSS color functions (no rgba()), wrap `//` text in braces, try/catch on `.play()`, debounce single-click when double-click exists.

  </action>
  <verify>
    `pnpm --filter web build` succeeds.
    VideoPlayerDialog renders without errors.
    CSS classes for decrypt progress are defined.
  </verify>
  <done>
    VideoPlayerDialog uses SW streaming for CTR media files with decrypt progress bar.
    Falls back to blob URL for GCM files or when SW not active.
    Progress shows percentage during encrypted content fetch.
    CipherBox branding badge on streaming video.
    Cleanup on dialog close unregisters SW stream.
  </done>
</task>

<task type="auto">
  <name>Task 3: AudioPlayerDialog with streaming decrypt support</name>
  <files>
    apps/web/src/components/file-browser/AudioPlayerDialog.tsx
    apps/web/src/styles/audio-player-dialog.css
  </files>
  <action>
    Apply the same streaming preview pattern as VideoPlayerDialog:

    1. **Import useStreamingPreview** alongside useFilePreview.

    2. **Determine streaming candidacy** by MIME type:
       ```typescript
       const STREAMING_AUDIO_MIMES = new Set(['audio/mpeg', 'audio/mp4', 'audio/webm', 'audio/ogg', 'audio/aac']);
       const isStreamingCandidate = item ? STREAMING_AUDIO_MIMES.has(getAudioMime(item.name)) : false;
       ```

    3. **Use useStreamingPreview for CTR, useFilePreview for GCM:**
       Same dual-hook pattern as VideoPlayerDialog.

    4. **Audio element src:**
       For the streaming case, use the SW URL: `new Audio(streaming.streamUrl)`
       For the blob URL case: `new Audio(blobPreview.objectUrl)` (existing behavior)

       The current AudioPlayerDialog creates `new Audio(objectUrl)` in a useEffect. Update this:
       - Determine the audio source URL based on isStreaming
       - If streaming: `const audioSrc = streaming.streamUrl`
       - If blob: `const audioSrc = blobPreview.objectUrl`
       - Create Audio element with `audioSrc`
       - Note: `new Audio('/decrypt-stream/...')` will make a fetch that the SW intercepts

    5. **Add decrypt progress bar:**
       Show progress in the visualization area when loading a streaming file:
       ```tsx
       {(isLoading || (isStreaming && streaming.decryptProgress < 100 && streaming.decryptProgress > 0)) ? (
         <div className="audio-decrypt-loading">
           <div className="audio-decrypt-label">decrypting...</div>
           <div className="audio-decrypt-progress-track">
             <div className="audio-decrypt-progress-fill" style={{ width: `${streaming.decryptProgress}%` }} />
           </div>
           <div className="audio-decrypt-percent">{Math.round(streaming.decryptProgress)}%</div>
         </div>
       ) : ...
       ```

    6. **Cleanup on close:** Call `streaming.cleanup()` in the close handler.

    7. **Web Audio API compatibility:**
       The existing AudioPlayerDialog uses `createMediaElementSource()` for visualization. This should work fine with the SW-proxied audio since the Audio element treats the SW URL as a normal HTTP source. No changes needed to the Web Audio API setup.

    **CSS updates** in audio-player-dialog.css:
    - `.audio-decrypt-loading`: Centered container in viz area
    - `.audio-decrypt-progress-track`: Same pattern as video (full-width dark bar)
    - `.audio-decrypt-progress-fill`: Green fill, animated
    - `.audio-decrypt-percent`: Monospace percentage text
    - `.audio-decrypt-label`: Terminal-style "decrypting..." label

    Follow the same CipherBox terminal aesthetic. Match the green color scheme (`#00D084`).
    Follow `apps/web/CLAUDE.md` guidelines.

  </action>
  <verify>
    `pnpm --filter web build` succeeds.
    AudioPlayerDialog renders without errors.
    CSS classes for decrypt progress are defined.
  </verify>
  <done>
    AudioPlayerDialog uses SW streaming for CTR audio files with decrypt progress bar.
    Falls back to blob URL for GCM files or when SW not active.
    Web Audio API visualization continues working with SW-proxied audio.
    Progress shows percentage during encrypted content fetch.
    Cleanup on dialog close.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` succeeds
- `pnpm lint` passes
- CTR-encrypted video file: opens player, shows decrypt progress, starts playing via SW
- CTR-encrypted audio file: opens player, shows decrypt progress, starts playing via SW
- GCM-encrypted media file: falls back to blob URL preview (existing behavior)
- Video seeking works after initial load (SW caches encrypted data)
- Dialog close unregisters the stream from SW
- If SW not active (first page load), falls back to blob URL download+decrypt
</verification>

<success_criteria>

- CTR media plays in-browser without full file download
- Decrypt progress bar shows real progress during SW encrypted content fetch
- GCM files continue working with existing blob URL approach
- Seeking works within CTR-encrypted video
- No memory leaks (streams unregistered on close)
- Falls back gracefully when SW not ready
  </success_criteria>

<output>
After completion, create `.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-04-SUMMARY.md`
</output>
