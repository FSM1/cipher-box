# Phase 12.1: AES-CTR Streaming Encryption - Research

**Researched:** 2026-02-17
**Domain:** Client-side AES-CTR encryption, Service Worker media decryption proxy, streaming upload pipeline
**Confidence:** HIGH (core crypto/SW patterns) / MEDIUM (IPFS byte-range) / HIGH (codebase integration)

## Summary

This phase adds AES-256-CTR encryption for media files, enabling streaming decryption for in-browser playback without downloading entire files first. The current codebase uses AES-256-GCM exclusively (via `@cipherbox/crypto` package and Web Crypto API), with a well-structured upload/download pipeline that loads entire files into memory.

The architecture has three major components: (1) a Service Worker that intercepts `<video>/<audio>` element fetch requests and decrypts CTR-encrypted content on-the-fly, transparently returning decrypted responses; (2) CTR encryption in the `@cipherbox/crypto` package using Web Crypto API's native `AES-CTR` algorithm with manual counter management for random-access support; (3) a streaming upload pipeline using `ReadableStream` + `TransformStream` to encrypt files chunk-by-chunk without loading them entirely into memory.

**Primary recommendation:** Use the Service Worker transparent decrypt proxy pattern. The SW intercepts range requests from `<video>/<audio>` elements, fetches the encrypted content from the API, decrypts the relevant byte range using AES-CTR with computed counter offsets, and returns a `206 Partial Content` response. This is completely invisible to the media elements -- they just see a normal video source URL. For upload, use `TransformStream` to pipe file data through AES-CTR encryption chunk-by-chunk before uploading to the API.

## Standard Stack

### Core

| Library                                | Version  | Purpose                                    | Why Standard                                                                       |
| -------------------------------------- | -------- | ------------------------------------------ | ---------------------------------------------------------------------------------- |
| Web Crypto API (`crypto.subtle`)       | Built-in | AES-256-CTR encrypt/decrypt                | Native browser API, hardware-accelerated, already used for GCM                     |
| Service Worker API                     | Built-in | Transparent media request interception     | Browser-native proxy, no dependencies, intercepts all fetch from media elements    |
| WHATWG Streams API (`TransformStream`) | Built-in | Chunk-by-chunk streaming encryption/upload | Browser-native streaming, zero dependencies, perfect for bounded-memory processing |
| Vite (existing)                        | 7.3.0    | Build tooling for SW file                  | Already in project                                                                 |

### Supporting

| Library                  | Version | Purpose                                 | When to Use                                                       |
| ------------------------ | ------- | --------------------------------------- | ----------------------------------------------------------------- |
| `vite-plugin-pwa`        | latest  | Service Worker build & dev registration | Handles SW compilation to `type: 'classic'`, dev mode hot reload  |
| `workbox-range-requests` | latest  | Range request handling from cache       | Only if caching decrypted segments -- may not be needed initially |

### Alternatives Considered

| Instead of           | Could Use                                                | Tradeoff                                                                                            |
| -------------------- | -------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| Service Worker proxy | MediaSource API + manual feeding                         | MSE requires explicit chunk management, not transparent to media elements; SW approach is invisible |
| Service Worker proxy | Blob URL from full decrypt (current approach)            | Current approach works but requires full file download+decrypt before playback starts               |
| `vite-plugin-pwa`    | Manual SW file with `navigator.serviceWorker.register()` | Simpler for our use case; avoids extra dependency; recommended if SW is simple enough               |

**Installation:**

```bash
# No new dependencies needed for core functionality -- all browser-native APIs
# Optional: if vite-plugin-pwa is desired for SW build pipeline
pnpm --filter web add -D vite-plugin-pwa
```

**Recommendation on vite-plugin-pwa:** For CipherBox's use case, a manually registered service worker placed at `apps/web/public/sw.js` (or compiled from TypeScript) is simpler. The SW is small and focused. Avoid the full PWA plugin unless hot-reloading the SW during development proves painful. Register manually:

```typescript
// In app bootstrap (e.g., main.tsx)
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js', { scope: '/' });
}
```

## Architecture Patterns

### Recommended Project Structure

```text
packages/crypto/src/
├── aes/
│   ├── encrypt.ts          # Existing GCM encrypt
│   ├── decrypt.ts          # Existing GCM decrypt
│   ├── encrypt-ctr.ts      # NEW: AES-256-CTR encrypt (single chunk)
│   ├── decrypt-ctr.ts      # NEW: AES-256-CTR decrypt (single chunk, with offset)
│   └── index.ts            # Updated exports
├── constants.ts             # Add CTR constants

apps/web/
├── public/
│   └── decrypt-sw.js       # Service Worker (or compiled from TS)
├── src/
│   ├── services/
│   │   ├── file-crypto.service.ts      # Updated: mode-aware encrypt
│   │   ├── streaming-crypto.service.ts # NEW: TransformStream encrypt/decrypt
│   │   ├── upload.service.ts           # Updated: streaming upload for CTR
│   │   └── download.service.ts         # Updated: mode-aware download
│   ├── workers/
│   │   └── decrypt-sw.ts              # SW source (if using TS compilation)
│   ├── lib/
│   │   └── sw-registration.ts         # NEW: SW lifecycle management
│   └── hooks/
│       └── useFilePreview.ts          # Updated: SW-based streaming for media
```

### Pattern 1: Service Worker Transparent Decrypt Proxy

**What:** The Service Worker intercepts fetch requests made by `<video>` and `<audio>` elements for a special URL scheme (e.g., `/decrypt-stream/<ipnsName>`), fetches the encrypted file from the CipherBox API, decrypts with AES-CTR, and returns the decrypted bytes as the response.

**When to use:** Always, for CTR-encrypted media playback.

**How it works:**

```text
1. App sets video.src = "/decrypt-stream/{fileMetaIpnsName}?folderKeyId={id}"
2. <video> element issues HTTP request (potentially with Range header)
3. Service Worker intercepts the fetch event
4. SW looks up the file metadata (cached from main thread via postMessage)
5. SW fetches encrypted content from /ipfs/{cid} (with Range if byte-range supported)
6. SW decrypts the relevant portion using AES-CTR with computed counter offset
7. SW returns Response with decrypted bytes (status 206 if Range request)
8. <video> element plays seamlessly -- completely unaware of encryption
```

**Key communication pattern -- main thread to SW:**

```typescript
// Main thread: send decryption context to SW before setting video src
navigator.serviceWorker.controller?.postMessage({
  type: 'register-stream',
  fileMetaIpnsName: 'k51qzi...',
  fileKey: hexEncodedFileKey, // Decrypted file key (hex)
  iv: hexEncodedIv, // 16-byte CTR IV (hex)
  cid: 'bafy...', // IPFS CID
  totalSize: 52428800, // Original file size in bytes
  mimeType: 'video/mp4',
});

// Then set the video source
videoRef.current.src = '/decrypt-stream/k51qzi...';
```

**Service Worker fetch handler:**

```typescript
// decrypt-sw.js
const streamRegistry = new Map(); // fileMetaIpnsName -> decryption context

self.addEventListener('message', (event) => {
  if (event.data.type === 'register-stream') {
    streamRegistry.set(event.data.fileMetaIpnsName, {
      fileKey: event.data.fileKey,
      iv: event.data.iv,
      cid: event.data.cid,
      totalSize: event.data.totalSize,
      mimeType: event.data.mimeType,
    });
  }
});

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // Only intercept our decrypt-stream URLs
  if (!url.pathname.startsWith('/decrypt-stream/')) return;

  const ipnsName = url.pathname.split('/decrypt-stream/')[1];
  const ctx = streamRegistry.get(ipnsName);
  if (!ctx) return; // Fall through to network (will 404)

  event.respondWith(handleDecryptStream(event.request, ctx));
});

async function handleDecryptStream(request, ctx) {
  const rangeHeader = request.headers.get('Range');
  let start = 0;
  let end = ctx.totalSize - 1;

  if (rangeHeader) {
    const match = rangeHeader.match(/bytes=(\d+)-(\d*)/);
    if (match) {
      start = parseInt(match[1], 10);
      end = match[2] ? parseInt(match[2], 10) : ctx.totalSize - 1;
    }
  }

  // Fetch encrypted content (full file or byte range if gateway supports it)
  const apiUrl = `${API_BASE}/ipfs/${ctx.cid}`;
  const encryptedResponse = await fetch(apiUrl, {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  const encryptedData = new Uint8Array(await encryptedResponse.arrayBuffer());

  // Decrypt with AES-CTR at the correct offset
  const decrypted = await decryptCtrRange(encryptedData, ctx.fileKey, ctx.iv, start, end);

  // Return appropriate response
  const headers = {
    'Content-Type': ctx.mimeType,
    'Content-Length': String(decrypted.byteLength),
    'Accept-Ranges': 'bytes',
  };

  if (rangeHeader) {
    headers['Content-Range'] = `bytes ${start}-${end}/${ctx.totalSize}`;
    return new Response(decrypted, { status: 206, headers });
  }

  return new Response(decrypted, { status: 200, headers });
}
```

### Pattern 2: AES-CTR Random-Access Decryption

**What:** AES-CTR allows decrypting any arbitrary byte range without processing preceding bytes. The counter value for any block can be computed directly from the file offset.

**When to use:** For byte-range decryption in the Service Worker, and for any random-access read pattern.

**How it works:**

```text
Given: file encrypted with AES-256-CTR(fileKey, IV)
IV = 16 bytes: [8-byte nonce | 8-byte initial counter (usually 0)]
AES block size = 16 bytes

To decrypt bytes [start, end]:
  1. blockOffset = floor(start / 16)
  2. Compute counter for that block: initialCounter + blockOffset
  3. Set IV's counter portion to this value
  4. byteOffsetInBlock = start % 16
  5. Decrypt from blockOffset * 16 to ceil((end + 1) / 16) * 16
  6. Slice result to [byteOffsetInBlock, byteOffsetInBlock + (end - start + 1)]
```

**Example:**

```typescript
async function decryptCtrRange(
  encryptedData: Uint8Array,
  fileKeyHex: string,
  ivHex: string,
  startByte: number,
  endByte: number
): Promise<Uint8Array> {
  const fileKey = hexToBytes(fileKeyHex);
  const baseIv = hexToBytes(ivHex); // 16 bytes

  // Compute block-aligned range
  const blockSize = 16;
  const startBlock = Math.floor(startByte / blockSize);
  const endBlock = Math.floor(endByte / blockSize);
  const blockAlignedStart = startBlock * blockSize;
  const blockAlignedEnd = (endBlock + 1) * blockSize;

  // Build counter for starting block
  const counter = new Uint8Array(16);
  counter.set(baseIv.subarray(0, 8), 0); // 8-byte nonce
  // Add startBlock to the 8-byte counter portion (big-endian)
  const counterView = new DataView(counter.buffer);
  const baseCounter = new DataView(baseIv.buffer).getBigUint64(8, false);
  counterView.setBigUint64(8, baseCounter + BigInt(startBlock), false);

  // Import key
  const cryptoKey = await crypto.subtle.importKey('raw', fileKey, { name: 'AES-CTR' }, false, [
    'decrypt',
  ]);

  // Decrypt the block-aligned range
  const slicedEncrypted = encryptedData.subarray(blockAlignedStart, blockAlignedEnd);
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-CTR', counter, length: 64 },
    cryptoKey,
    slicedEncrypted
  );

  // Extract the exact requested range
  const offsetInFirstBlock = startByte - blockAlignedStart;
  const requestedLength = endByte - startByte + 1;
  return new Uint8Array(decrypted).subarray(
    offsetInFirstBlock,
    offsetInFirstBlock + requestedLength
  );
}
```

### Pattern 3: Streaming Upload with TransformStream

**What:** Encrypt media files chunk-by-chunk using AES-CTR through a `TransformStream`, uploading each encrypted chunk as it becomes available. Bounded memory usage.

**When to use:** For CTR-mode file uploads (media files above size threshold).

**Example:**

```typescript
async function streamingCtrEncrypt(
  file: File,
  fileKey: Uint8Array,
  iv: Uint8Array, // 16 bytes
  chunkSize: number = 1024 * 1024 // 1MB chunks
): Promise<ReadableStream<Uint8Array>> {
  const cryptoKey = await crypto.subtle.importKey('raw', fileKey, { name: 'AES-CTR' }, false, [
    'encrypt',
  ]);

  let offset = 0;

  return new ReadableStream({
    async pull(controller) {
      if (offset >= file.size) {
        controller.close();
        return;
      }

      const end = Math.min(offset + chunkSize, file.size);
      const chunk = new Uint8Array(await file.slice(offset, end).arrayBuffer());

      // Compute counter for this offset
      const blockOffset = Math.floor(offset / 16);
      const counter = new Uint8Array(16);
      counter.set(iv.subarray(0, 8), 0);
      const view = new DataView(counter.buffer);
      const baseCounter = new DataView(iv.buffer).getBigUint64(8, false);
      view.setBigUint64(8, baseCounter + BigInt(blockOffset), false);

      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-CTR', counter, length: 64 },
        cryptoKey,
        chunk
      );

      controller.enqueue(new Uint8Array(encrypted));
      offset = end;
    },
  });
}
```

### Anti-Patterns to Avoid

- **Never reuse a nonce+key combination for CTR:** Nonce reuse with CTR is catastrophic -- XOR of two ciphertexts reveals XOR of two plaintexts. Each file MUST get a unique random nonce.
- **Never use GCM for streaming decryption:** GCM only authenticates at the very end; releasing plaintext before auth tag verification is a security violation.
- **Never pass the file key in the URL query string:** Query strings are visible to the server, logged, and cached. Use `postMessage` from main thread to Service Worker instead.
- **Never use `.buffer` on Uint8Array for Blob construction:** Per `apps/web/CLAUDE.md`, `.buffer` may include extra bytes beyond the view. Always pass the typed array directly.
- **Never block on full file load for CTR files:** The whole point of CTR is streaming -- loading the entire file defeats the purpose.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem                             | Don't Build                           | Use Instead                                                          | Why                                                                                      |
| ----------------------------------- | ------------------------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| Range header parsing in SW          | Custom regex parser                   | Standard `Range` header parsing (or `workbox-range-requests`)        | Edge cases with multi-range, open-ended ranges, malformed headers                        |
| AES-CTR encrypt/decrypt             | Custom block cipher implementation    | `crypto.subtle.encrypt/decrypt` with `AES-CTR` algorithm             | Hardware accelerated, audited, handles counter increment internally within a single call |
| Service Worker lifecycle management | Manual install/activate/update logic  | Browser-native SW lifecycle with `skipWaiting()` + `clients.claim()` | Complex edge cases with version updates, stale workers                                   |
| Counter arithmetic (overflow)       | Manual byte-by-byte counter increment | `DataView.setBigUint64()` for 64-bit counter math                    | BigInt handles the full 64-bit counter space correctly                                   |
| MIME type detection                 | Custom extension mapping              | Extend existing `VIDEO_MIME`/`AUDIO_MIME` maps already in codebase   | Already working, just needs CTR-awareness added                                          |

**Key insight:** Web Crypto API handles all the hard AES-CTR math internally. You only need to compute the starting counter value for a given byte offset -- the API auto-increments the counter across blocks within a single `encrypt()/decrypt()` call. Don't try to manually XOR keystream blocks.

## Common Pitfalls

### Pitfall 1: Service Worker First-Load Problem

**What goes wrong:** The Service Worker doesn't intercept requests on the page's first load (before it's registered and activated).
**Why it happens:** SW lifecycle requires registration -> installation -> activation before it can intercept fetches.
**How to avoid:** (a) Register the SW as early as possible in `main.tsx`. (b) For the very first session, fall back to the current blob-URL approach (download+decrypt entire file). (c) Use `clients.claim()` in the SW's `activate` event to take control immediately. (d) Check `navigator.serviceWorker.controller` before attempting SW-based playback.
**Warning signs:** Video playback fails on first app visit, works after refresh.

### Pitfall 2: Safari Range Request Behavior

**What goes wrong:** Safari historically had issues with Service Workers and Range requests -- silently dropping the `Range` header.
**Why it happens:** Browser implementation differences in SW fetch event handling.
**How to avoid:** (a) Check for `Range` header presence. (b) If missing but expected, fetch full file and slice in SW. (c) Modern Safari (2023+) has fixed this. Test explicitly.
**Warning signs:** Video seeking fails only in Safari, plays but can't seek.

### Pitfall 3: CTR Nonce Reuse

**What goes wrong:** Encrypting two files with the same nonce and key exposes the XOR of their plaintexts.
**Why it happens:** Using a deterministic nonce (e.g., derived from filename) instead of random.
**How to avoid:** Always generate a cryptographically random 8-byte nonce per file using `crypto.getRandomValues()`. Store the full 16-byte IV (nonce + initial counter) in file metadata. The existing `generateIv()` pattern from `@cipherbox/crypto` can be adapted (currently generates 12 bytes for GCM; CTR needs 16 bytes with 8 nonce + 8 counter).
**Warning signs:** No visible warning -- this is a silent security vulnerability.

### Pitfall 4: Counter Length Miscalculation

**What goes wrong:** Setting `length` too small causes counter overflow/wrap for large files, leading to nonce reuse within a single file.
**Why it happens:** `AesCtrParams.length` specifies how many bits of the 16-byte counter block are used for the counter. With 32 bits, max file size = 2^32 _16 bytes = 64 GB. With 64 bits (recommended), max = 2^64_ 16 bytes = effectively unlimited.
**How to avoid:** Always use `length: 64` (8 bytes = 64 bits for counter). With 100MB max file size, even 32 bits is sufficient (100MB / 16 = 6.25M blocks, well under 2^32), but 64 bits provides generous headroom for future BYO-IPFS larger uploads.
**Warning signs:** Decryption produces garbage data for files beyond a certain size.

### Pitfall 5: Auth Token in Service Worker

**What goes wrong:** The Service Worker needs an auth token to fetch encrypted content from the API, but tokens expire.
**Why it happens:** SW runs in a separate context from the main thread; it can't access React stores.
**How to avoid:** (a) Send the current auth token to the SW via `postMessage` whenever it changes. (b) Have the SW request a fresh token from the main thread via `postMessage` if a fetch returns 401. (c) Consider having the main thread fetch the encrypted data and pass it to the SW for decryption only (simpler, but adds IPC overhead).
**Warning signs:** Video playback works initially but breaks after 15 minutes (token expiry).

### Pitfall 6: Memory Pressure from Large Encrypted Files

**What goes wrong:** Even with streaming decryption, if the entire encrypted file must be fetched before any decryption starts (no IPFS byte-range support), memory usage spikes to file size.
**Why it happens:** IPFS gateways may not support byte-range requests, or CipherBox's API proxy doesn't pass Range headers through.
**How to avoid:** (a) Phase 1: Accept full-file fetch + streaming decrypt as a baseline. (b) Phase 2 (optimization): Add byte-range support to the API's IPFS proxy endpoint. (c) The 100MB file limit keeps this manageable for now.
**Warning signs:** Browser tab crashes on large file playback, especially on mobile.

### Pitfall 7: Encrypted File Size Equals Plaintext Size (CTR)

**What goes wrong:** Developers assume encrypted CTR output is larger than input (like GCM with its 16-byte auth tag).
**Why it happens:** AES-CTR produces ciphertext of exactly the same size as plaintext (XOR-based stream cipher). No auth tag.
**How to avoid:** Store `size` in metadata as the original file size. For CTR files, `size` == encrypted size (unlike GCM where encrypted = size + 16). Account for this in progress bars and Content-Length calculations.
**Warning signs:** Off-by-16-bytes errors in range calculations, progress bars exceeding 100%.

## Code Examples

### AES-CTR Encryption via Web Crypto API

```typescript
// Source: MDN Web Docs - AesCtrParams
// https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams

// CTR IV structure: 8 bytes nonce + 8 bytes counter
const AES_CTR_IV_SIZE = 16; // Full counter block
const AES_CTR_NONCE_SIZE = 8; // Nonce portion
const AES_CTR_LENGTH = 64; // Counter bits (NIST recommended)

function generateCtrIv(): Uint8Array {
  const iv = new Uint8Array(AES_CTR_IV_SIZE);
  // Random nonce in first 8 bytes
  crypto.getRandomValues(iv.subarray(0, AES_CTR_NONCE_SIZE));
  // Counter starts at 0 (last 8 bytes already zero)
  return iv;
}

async function encryptAesCtr(
  plaintext: Uint8Array,
  key: Uint8Array,
  iv: Uint8Array
): Promise<Uint8Array> {
  const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'AES-CTR' }, false, [
    'encrypt',
  ]);
  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-CTR', counter: iv, length: AES_CTR_LENGTH },
    cryptoKey,
    plaintext
  );
  return new Uint8Array(ciphertext);
}

async function decryptAesCtr(
  ciphertext: Uint8Array,
  key: Uint8Array,
  iv: Uint8Array
): Promise<Uint8Array> {
  const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'AES-CTR' }, false, [
    'decrypt',
  ]);
  const plaintext = await crypto.subtle.decrypt(
    { name: 'AES-CTR', counter: iv, length: AES_CTR_LENGTH },
    cryptoKey,
    ciphertext
  );
  return new Uint8Array(plaintext);
}
```

### Service Worker Registration and Communication

```typescript
// Source: MDN - Service Worker API
// https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API

// sw-registration.ts
export async function registerDecryptSW(): Promise<ServiceWorkerRegistration | null> {
  if (!('serviceWorker' in navigator)) {
    console.warn('Service Workers not supported');
    return null;
  }

  try {
    const registration = await navigator.serviceWorker.register('/decrypt-sw.js', {
      scope: '/',
    });

    // Wait for the SW to be ready
    await navigator.serviceWorker.ready;
    return registration;
  } catch (err) {
    console.error('SW registration failed:', err);
    return null;
  }
}

export function sendToSW(message: unknown): void {
  navigator.serviceWorker.controller?.postMessage(message);
}

export function isSwActive(): boolean {
  return !!navigator.serviceWorker.controller;
}
```

### Mode-Aware Encryption Selection

```typescript
// Based on DATA_FLOWS.md Section 9.1

const STREAMING_MIME_TYPES = new Set([
  'video/mp4',
  'video/webm',
  'audio/mpeg',
  'audio/mp4',
  'audio/webm',
  'audio/ogg',
  'audio/aac',
]);

const CTR_SIZE_THRESHOLD = 256 * 1024; // 256KB -- small clips stay GCM

function selectEncryptionMode(file: File): 'GCM' | 'CTR' {
  if (STREAMING_MIME_TYPES.has(file.type) && file.size > CTR_SIZE_THRESHOLD) {
    return 'CTR';
  }
  return 'GCM';
}
```

### Range Response Construction in Service Worker

```typescript
// Source: web.dev - Handle range requests in a service worker
// https://web.dev/sw-range-requests/
// Source: surma.dev - Video, Range Requests & WHATWG Streams
// https://surma.dev/things/range-requests/

function createRangeResponse(
  data: Uint8Array,
  rangeHeader: string | null,
  totalSize: number,
  mimeType: string
): Response {
  if (!rangeHeader) {
    return new Response(data, {
      status: 200,
      headers: {
        'Content-Type': mimeType,
        'Content-Length': String(data.byteLength),
        'Accept-Ranges': 'bytes',
      },
    });
  }

  const match = rangeHeader.match(/bytes=(\d+)-(\d*)/);
  const start = match ? parseInt(match[1], 10) : 0;
  const end = match && match[2] ? parseInt(match[2], 10) : totalSize - 1;

  return new Response(data, {
    status: 206,
    headers: {
      'Content-Type': mimeType,
      'Content-Length': String(data.byteLength),
      'Content-Range': `bytes ${start}-${end}/${totalSize}`,
      'Accept-Ranges': 'bytes',
    },
  });
}
```

## State of the Art

| Old Approach                        | Current Approach                         | When Changed                  | Impact                                       |
| ----------------------------------- | ---------------------------------------- | ----------------------------- | -------------------------------------------- |
| Full file download + GCM decrypt    | Streaming CTR decrypt via Service Worker | 2024-2025 pattern emerging    | Enables media playback without full download |
| MediaSource API manual feeding      | Service Worker transparent proxy         | 2024+ (Mux blog Dec 2025)     | Simpler, invisible to media elements         |
| Custom stream cipher                | Web Crypto API AES-CTR                   | Always available              | No custom crypto needed                      |
| Single encrypt/upload/decrypt model | TransformStream pipeline                 | 2023+ (broad browser support) | Bounded memory, streaming I/O                |

**Web Crypto Streams proposal (EncryptionStream/DecryptionStream):** Formal proposal exists at WinterTC55 to add native streaming to Web Crypto, but NOT yet implemented in any browser. The manual `TransformStream` + `crypto.subtle.encrypt()` chunk-by-chunk approach is the current standard workaround and will work identically once the proposal ships.

**Deprecated/outdated:**

- `createObjectURL(MediaSource)` pattern is deprecated in some contexts; prefer `srcObject` where available, but for our SW proxy pattern, the video `src` attribute pointing to our custom URL scheme is the correct approach.

## Detailed Design Decisions

### CTR Nonce/Counter Management Strategy

Recommendation: Per-file random nonce + zero initial counter, 8/8 split.

```text
IV (16 bytes): [random_nonce (8 bytes) | counter (8 bytes, starts at 0)]
AesCtrParams.length = 64 (counter portion = 64 bits)
```

**Rationale:**

- NIST SP800-38A recommends counter = half the block (64 bits for AES-128-bit blocks)
- 8-byte random nonce provides 2^64 possible nonces -- collision probability negligible for CipherBox's scale
- 8-byte (64-bit) counter supports files up to 2^64 \* 16 bytes -- effectively unlimited, well beyond 100MB limit
- Counter starts at 0 for simplicity -- random-access offset calculation is just `blockIndex = byteOffset / 16`
- The nonce is generated via `crypto.getRandomValues()` and stored in file metadata alongside the counter initial value

**Storage in metadata:** The full 16-byte IV is stored as `fileIv` (hex-encoded) in the `FileMetadata` record, same as GCM. The `encryptionMode: 'CTR'` field distinguishes how to interpret it (12-byte IV for GCM, 16-byte IV for CTR).

### Chunk Size for Streaming Upload

Recommendation: 1MB chunks.

Rationale:

- 1MB balances memory usage (100 chunks for a 100MB file) against per-chunk overhead
- Each `crypto.subtle.encrypt()` call has some fixed overhead; too-small chunks (e.g., 16KB) increase call count 60x
- 1MB aligns well with typical network MTU and upload buffer sizes
- For seeking, the minimum granularity is 16 bytes (one AES block), not the upload chunk size. Chunk size only affects upload memory, not seek resolution.
- Counter advancement between chunks: chunk_blocks = chunkSize / 16 = 65536 blocks per 1MB chunk

### CTR vs GCM Size Threshold

Recommendation: 256KB minimum for CTR.

Media files below 256KB (short audio clips, thumbnails with media MIME types) should stay GCM because:

- They're small enough to download+decrypt instantly
- GCM provides authenticated encryption (integrity built-in)
- Service Worker overhead for tiny files is disproportionate
- 256KB is roughly 2-3 seconds of MP3 at 128kbps

### Seeking Strategy

Recommendation: Progressive fetch with future byte-range optimization.

**Phase 1 (this implementation):** Fetch the full encrypted file once, cache it in the Service Worker's memory (or IndexedDB for larger files), decrypt byte ranges from the cached ciphertext on demand. This works because:

- 100MB max file limit is manageable in memory
- IPFS byte-range support from Pinata is undocumented and uncertain
- CipherBox's API proxy (`/ipfs/:cid`) currently returns the full file with no Range header support
- Seeking is instant once the file is cached (random-access CTR decryption)

**Phase 2 (future optimization):** Add HTTP Range header passthrough to the API's IPFS proxy endpoint, enabling true byte-range fetching from Pinata. This would reduce initial load time from "download 100MB" to "download first few MB + fetch on seek."

**The API change needed for Phase 2:**

```typescript
// Current: always returns full file
async getFile(cid: string): Promise<Buffer> { ... }

// Future: supports Range header passthrough
async getFileRange(cid: string, start?: number, end?: number): Promise<Buffer> {
  const headers: Record<string, string> = {};
  if (start !== undefined) {
    headers['Range'] = `bytes=${start}-${end ?? ''}`;
  }
  const response = await fetch(`${this.gatewayBaseUrl}/ipfs/${cid}`, { headers });
  // ... handle 206 vs 200
}
```

### Service Worker Auth Token Strategy

Recommendation: Main thread fetches encrypted data, passes to SW for decrypt-only.

Two architectures were considered:

**Option A: SW fetches from API directly** (requires auth token management)

- SW needs auth token via `postMessage`
- Token refresh requires round-trip to main thread
- More complex but reduces IPC overhead for large files

**Option B: Main thread fetches, SW decrypts** (simpler auth, more IPC)

- Main thread fetches encrypted bytes (already has auth token)
- Passes encrypted data to SW via `postMessage` or shared cache
- SW only handles decryption and range response construction

**Recommendation: Option A (SW fetches directly)** because:

- Avoids transferring large encrypted blobs over `postMessage`
- `postMessage` has structured clone overhead
- Token can be sent once and refreshed on 401
- The SW is already a trusted first-party script

But provide a fallback to Option B for the first-load scenario (before SW is active).

## Open Questions

Things that couldn't be fully resolved:

1. **Pinata Dedicated Gateway byte-range support**
   - What we know: IPFS spec says gateways SHOULD support Range requests. Pinata has `?stream=true` for video. Their gateway has a CDN layer.
   - What's unclear: Whether Pinata actually returns 206 with Content-Range for arbitrary byte-range requests on raw encrypted blobs (not video files). The `?stream=true` parameter may only work for recognized video formats, which our encrypted blobs are not.
   - Recommendation: Test directly with `curl -I -H "Range: bytes=0-1023" https://gateway.pinata.cloud/ipfs/<CID>`. Design the architecture to work without byte-range support (full fetch + cached decrypt), and add it as an optimization later if supported.

2. **Service Worker crypto.subtle availability**
   - What we know: Service Workers have access to `crypto.subtle` in all modern browsers (it's in the ServiceWorkerGlobalScope). The SW runs on a separate thread, so crypto operations won't block the main thread.
   - What's unclear: Performance characteristics of `crypto.subtle` in SW context vs main thread. Should be identical (same underlying implementation) but not verified.
   - Recommendation: Benchmark during implementation. If slow, consider using `transferable` objects to minimize copy overhead.

3. **Maximum cached file size in Service Worker memory**
   - What we know: 100MB is the current file size limit. Caching a full 100MB encrypted file in SW memory should work on modern devices.
   - What's unclear: Memory pressure on mobile browsers, browser-specific SW memory limits.
   - Recommendation: For files over ~20MB, consider using Cache API or IndexedDB instead of in-memory Map. Start with in-memory for simplicity, add persistence if needed.

4. **Service Worker update strategy**
   - What we know: When the SW file changes, the browser will detect it and install the new version. Active streams could be interrupted.
   - What's unclear: Exact behavior when a stream is in progress and the SW updates.
   - Recommendation: Use `skipWaiting()` in install event and `clients.claim()` in activate event. Active streams may need to be re-established after SW update.

## Sources

### Primary (HIGH confidence)

- [MDN: AesCtrParams](https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams) - CTR counter/nonce specification, updated Dec 2025
- [MDN: SubtleCrypto.encrypt()](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt) - AES-CTR usage with Web Crypto, updated Dec 2025
- [MDN: Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) - SW lifecycle, fetch interception, Nov 2025
- [IPFS Path Gateway Specification](https://specs.ipfs.tech/http-gateways/path-gateway/) - Range request support (SHOULD, not MUST)
- [CipherBox TECHNICAL_ARCHITECTURE.md](../../00-Preliminary-R&D/Documentation/TECHNICAL_ARCHITECTURE.md) - CTR roadmap, security basis, encryption mode field spec
- [CipherBox DATA_FLOWS.md](../../00-Preliminary-R&D/Documentation/DATA_FLOWS.md) - CTR upload/download sequences, mode selection logic

### Secondary (MEDIUM confidence)

- [surma.dev: Video, Range Requests & WHATWG Streams](https://surma.dev/things/range-requests/) - Detailed SW + video + Range handling patterns
- [web.dev: Handle range requests in a service worker](https://web.dev/sw-range-requests/) - SW Range request best practices
- [Justin Ribeiro: SW Video Files and 206](https://justinribeiro.com/chronicle/2026/02/04/service-worker-video-files-and-the-206-partial-response) - Production SW + video patterns, Feb 2026
- [Mux Blog: Service Workers for Media](https://www.mux.com/blog/service-workers-are-underrated) - SW as media proxy pattern, Dec 2025
- [WinterTC55 Web Crypto Streams Proposal](https://github.com/WinterTC55/proposal-webcrypto-streams/blob/main/explainer.md) - Future native streaming crypto (not yet implemented)
- [wiktor-k/sw-crypto](https://github.com/wiktor-k/sw-crypto) - Reference implementation of SW decrypt proxy
- [Pinata: Video Streaming on Dedicated Gateway](https://knowledge.pinata.cloud/en/articles/6297322-how-to-enable-video-streaming-on-a-dedicated-gateway) - `?stream=true` parameter
- [Vite PWA Plugin: SW without PWA](https://vite-pwa-org.netlify.app/guide/service-worker-without-pwa-capabilities) - SW-only Vite integration

### Tertiary (LOW confidence)

- NIST SP800-38A counter mode recommendations (referenced by MDN, not directly fetched)
- Pinata byte-range support for raw files (undocumented; gateway SHOULD support per IPFS spec)

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - All browser-native APIs, well-documented, verified via MDN
- Architecture (SW proxy pattern): HIGH - Multiple authoritative sources confirm the pattern (Mux, surma.dev, MDN)
- Architecture (CTR crypto design): HIGH - NIST standard, Web Crypto API specification, straightforward math
- Architecture (streaming upload): HIGH - TransformStream + crypto.subtle pattern well-documented
- Pitfalls: HIGH - Common SW + video issues extensively documented (Safari range bug, first-load, token management)
- IPFS byte-range: MEDIUM - Spec says SHOULD support, Pinata docs don't confirm for raw blobs

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable -- core Web APIs unlikely to change)
