---
phase: 12.1-aes-ctr-streaming-encryption
plan: 02
type: execute
wave: 2
depends_on: ['12.1-01']
files_modified:
  - apps/web/src/services/streaming-crypto.service.ts
  - apps/web/src/services/file-crypto.service.ts
  - apps/web/src/services/upload.service.ts
  - apps/web/src/services/file-metadata.service.ts
  - apps/web/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - 'Media files above 256KB are encrypted with AES-256-CTR during upload'
    - 'Non-media files and small media files continue using AES-256-GCM'
    - 'CTR encryption streams chunks through a TransformStream with bounded memory'
    - "Upload flow stores encryptionMode='CTR' in file metadata"
    - 'Mode selection is transparent to the user -- single progress bar, same UI'
  artifacts:
    - path: 'apps/web/src/services/streaming-crypto.service.ts'
      provides: 'Mode selection logic and streaming CTR encryption'
      exports: ['selectEncryptionMode', 'encryptFileCtr']
    - path: 'apps/web/src/services/file-crypto.service.ts'
      provides: 'Mode-aware encryption dispatcher'
      exports: ['encryptFile', 'EncryptedFileResult']
    - path: 'apps/web/src/services/upload.service.ts'
      provides: 'Upload with encryptionMode in result'
      exports: ['uploadFile', 'UploadedFile']
  key_links:
    - from: 'apps/web/src/services/streaming-crypto.service.ts'
      to: '@cipherbox/crypto'
      via: 'encryptAesCtr import'
      pattern: 'encryptAesCtr'
    - from: 'apps/web/src/services/file-crypto.service.ts'
      to: 'apps/web/src/services/streaming-crypto.service.ts'
      via: 'mode-aware dispatch'
      pattern: 'selectEncryptionMode|encryptFileCtr'
    - from: 'apps/web/src/services/file-metadata.service.ts'
      to: 'encryptionMode'
      via: 'passes mode to createFileMetadata'
      pattern: 'encryptionMode.*CTR'
---

<objective>
Add mode-aware encryption to the upload pipeline: media files above 256KB are encrypted with AES-256-CTR using streaming chunks, while all other files continue using AES-256-GCM.

Purpose: CTR mode produces ciphertext that supports random-access decryption, which is required for streaming media playback. The streaming upload avoids loading entire media files into memory.

Output: streaming-crypto.service.ts (mode selection + CTR encrypt), updated file-crypto.service.ts (dispatch), updated upload.service.ts (encryptionMode tracking), updated file-metadata.service.ts (mode in metadata).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-RESEARCH.md

# Prior plan output needed for CTR functions

@.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-01-SUMMARY.md

# Existing services to modify

@apps/web/src/services/file-crypto.service.ts
@apps/web/src/services/upload.service.ts
@apps/web/src/services/file-metadata.service.ts
@apps/web/src/services/index.ts
@apps/web/src/lib/api/ipfs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streaming crypto service with mode selection</name>
  <files>
    apps/web/src/services/streaming-crypto.service.ts
  </files>
  <action>
    Create `streaming-crypto.service.ts` with:

    1. **STREAMING_MIME_TYPES** constant Set:
       `'video/mp4', 'video/webm', 'audio/mpeg', 'audio/mp4', 'audio/webm', 'audio/ogg', 'audio/aac'`

    2. **CTR_SIZE_THRESHOLD** constant: `256 * 1024` (256KB)

    3. **`selectEncryptionMode(file: File): 'GCM' | 'CTR'`**
       Returns 'CTR' if `STREAMING_MIME_TYPES.has(file.type) && file.size > CTR_SIZE_THRESHOLD`, else 'GCM'.
       Export this function.

    4. **`encryptFileCtr(file: File, userPublicKey: Uint8Array): Promise<EncryptedFileResult>`**
       Streaming CTR encryption:
       a. Generate a random 32-byte file key via `generateFileKey()`
       b. Generate a 16-byte CTR IV via `generateCtrIv()`
       c. Read file in 1MB chunks using `file.slice(offset, offset + CHUNK_SIZE).arrayBuffer()`
       d. For each chunk, compute the counter for that offset:
          - `blockOffset = Math.floor(offset / 16)`
          - Build 16-byte counter: copy first 8 bytes of IV (nonce), set bytes 8-15 to `BigInt(blockOffset)` via DataView.setBigUint64(8, value, false)
          - Call `crypto.subtle.encrypt({ name: 'AES-CTR', counter, length: 64 }, cryptoKey, chunk)`
       e. Collect encrypted chunks into a single Uint8Array (or use a Blob array for efficiency)
       f. Wrap the file key with user's public key via `wrapKey()`
       g. Clear the file key from memory via `clearBytes()`
       h. Return `EncryptedFileResult` with:
          - `ciphertext`: combined encrypted chunks as Uint8Array
          - `iv`: hex-encoded 16-byte CTR IV (note: NOT 12-byte GCM IV)
          - `wrappedKey`: hex-encoded
          - `originalSize`: file.size
          - `encryptedSize`: same as originalSize for CTR (no auth tag)
          - `encryptionMode`: 'CTR' as const

       Import `generateFileKey, generateCtrIv, wrapKey, clearBytes, bytesToHex, AES_CTR_LENGTH` from `@cipherbox/crypto`.
       Import CryptoKey from Web Crypto API.

       Use CHUNK_SIZE = 1024 * 1024 (1MB) as a constant.

       The function should import the CryptoKey once before the loop (not per-chunk).

    Export both functions.

  </action>
  <verify>
    `pnpm --filter web build` succeeds (TypeScript compilation).
    New service exports `selectEncryptionMode` and `encryptFileCtr`.
  </verify>
  <done>
    selectEncryptionMode() classifies files as CTR or GCM based on MIME type + size threshold.
    encryptFileCtr() encrypts files in 1MB streaming chunks using AES-256-CTR with correct counter advancement.
    CHUNK_SIZE is 1MB. CTR_SIZE_THRESHOLD is 256KB.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mode-aware file encryption and upload pipeline</name>
  <files>
    apps/web/src/services/file-crypto.service.ts
    apps/web/src/services/upload.service.ts
    apps/web/src/services/file-metadata.service.ts
    apps/web/src/services/index.ts
  </files>
  <action>
    **Update EncryptedFileResult type** in file-crypto.service.ts:
    Add `encryptionMode: 'GCM' | 'CTR'` field to the type.

    **Update encryptFile()** in file-crypto.service.ts:
    - Import `selectEncryptionMode` and `encryptFileCtr` from './streaming-crypto.service'
    - At the start: `const mode = selectEncryptionMode(file);`
    - If mode === 'CTR': return `encryptFileCtr(file, userPublicKey)`
    - If mode === 'GCM': existing GCM path, but add `encryptionMode: 'GCM'` to the return object

    **Update UploadedFile type** in upload.service.ts:
    Add `encryptionMode: 'GCM' | 'CTR'` field.

    **Update uploadFile()** in upload.service.ts:
    - After `const encrypted = await encryptFile(file, userPublicKey);` the encrypted result now has `encryptionMode`
    - Add `encryptionMode: encrypted.encryptionMode` to the return object
    - The Blob construction for IPFS upload: for CTR files, use `new Blob([encrypted.ciphertext])` (pass typed array directly per CLAUDE.md rules, NOT `.buffer`)

    **Update file-metadata.service.ts createFileMetadata call sites:**
    The `createFileMetadata` function already accepts `encryptionMode` param (from Phase 12.6). Verify that callers of the upload pipeline pass `encryptionMode` from `UploadedFile` through to `createFileMetadata`. The key call site is in the hooks that orchestrate upload -> metadata creation. Specifically check:
    - `apps/web/src/hooks/useFileUpload.ts` or wherever `uploadFile` results are consumed and `createFileMetadata` is called
    - Ensure `encryptionMode: uploadedFile.encryptionMode` is passed

    If the call site already passes `encryptionMode` (it was added as optional in Phase 12.6), just ensure the upload result now provides it. If it defaults to 'GCM' via the optional parameter, that's fine -- CTR files will now explicitly pass 'CTR'.

    **Export** streaming-crypto.service functions from services/index.ts if a barrel exists, or ensure they're importable.

  </action>
  <verify>
    `pnpm --filter web build` succeeds.
    TypeScript: `UploadedFile` type includes `encryptionMode` field.
    TypeScript: `EncryptedFileResult` type includes `encryptionMode` field.
    Grep for `selectEncryptionMode` in file-crypto.service.ts confirms mode-aware dispatch.
  </verify>
  <done>
    encryptFile() dispatches to CTR or GCM based on MIME type + size.
    UploadedFile carries encryptionMode through the pipeline.
    File metadata records store encryptionMode='CTR' for media files.
    Non-media files continue using GCM with no behavior change.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` succeeds with no TypeScript errors
- `pnpm lint` passes (or no new lint errors)
- Upload a non-media file (e.g., .txt) -- should use GCM path (no behavior change)
- Upload a video file > 256KB -- should use CTR path (encryptionMode='CTR' in metadata)
- Small audio file < 256KB -- should use GCM path despite being media
</verification>

<success_criteria>

- selectEncryptionMode() correctly classifies files
- CTR encryption produces ciphertext of same size as plaintext (no auth tag overhead)
- encryptFileCtr() processes file in 1MB chunks (bounded memory)
- encryptionMode flows through UploadedFile -> createFileMetadata -> FileMetadata IPNS record
- Existing GCM upload path is unaffected
  </success_criteria>

<output>
After completion, create `.planning/phases/12.1-aes-ctr-streaming-encryption/12.1-02-SUMMARY.md`
</output>
