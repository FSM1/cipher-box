---
phase: 09-desktop-client
plan: 05
type: execute
wave: 3
depends_on: ["09-01", "09-03", "09-04"]
files_modified:
  - apps/desktop/src-tauri/src/fuse/operations.rs
  - apps/desktop/src-tauri/src/fuse/file_handle.rs
  - apps/desktop/src-tauri/src/fuse/mod.rs
  - apps/desktop/src-tauri/src/api/ipfs.rs
  - apps/desktop/src-tauri/src/api/ipns.rs
autonomous: true

must_haves:
  truths:
    - "User can save files through FUSE mount and they appear encrypted on IPFS"
    - "User can create new files via Finder or CLI (touch, echo >)"
    - "User can delete files via Finder or CLI (rm)"
    - "User can create folders (mkdir ~/CipherVault/NewFolder)"
    - "User can delete folders (rmdir, rm -rf)"
    - "User can rename files and folders (mv)"
    - "Writes are buffered to temp file and uploaded on close (temp-file commit model)"
  artifacts:
    - path: "apps/desktop/src-tauri/src/fuse/file_handle.rs"
      provides: "OpenFileHandle with temp file write buffering and dirty tracking"
      exports: ["OpenFileHandle"]
    - path: "apps/desktop/src-tauri/src/fuse/operations.rs"
      provides: "FUSE write operations: write, create, unlink, mkdir, rmdir, rename, setattr"
  key_links:
    - from: "apps/desktop/src-tauri/src/fuse/operations.rs"
      to: "apps/desktop/src-tauri/src/api/ipfs.rs"
      via: "upload_content for encrypted file upload on release"
      pattern: "upload_content"
    - from: "apps/desktop/src-tauri/src/fuse/operations.rs"
      to: "apps/desktop/src-tauri/src/api/ipns.rs"
      via: "publish_ipns for folder metadata updates after write"
      pattern: "publish_ipns"
    - from: "apps/desktop/src-tauri/src/fuse/operations.rs"
      to: "apps/desktop/src-tauri/src/crypto/folder.rs"
      via: "encrypt_folder_metadata for metadata updates"
      pattern: "encrypt_folder_metadata"
---

<objective>
Implement FUSE write operations: file creation, writing, deletion, folder creation/deletion, and rename. Uses the temp-file commit model -- writes buffer to a local temp file, then encrypt and upload on file close.

Purpose: Complete the read-write FUSE mount so users can use ~/CipherVault as a normal folder -- create, edit, delete, and rename files and folders transparently.

Output: Full read-write FUSE filesystem with all file/folder operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@.planning/phases/09-desktop-client/09-01-SUMMARY.md
@.planning/phases/09-desktop-client/09-03-SUMMARY.md
@.planning/phases/09-desktop-client/09-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement temp-file write model and IPNS publish helpers</name>
  <files>
    apps/desktop/src-tauri/src/fuse/file_handle.rs
    apps/desktop/src-tauri/src/api/ipfs.rs
    apps/desktop/src-tauri/src/api/ipns.rs
    apps/desktop/src-tauri/src/fuse/mod.rs
  </files>
  <action>
    **fuse/file_handle.rs** - OpenFileHandle with write buffering:
    - Refactor the existing `OpenFileHandle` (from plan 09-04) into a proper struct:
    ```rust
    pub struct OpenFileHandle {
        pub ino: u64,
        pub flags: i32,
        pub temp_path: Option<PathBuf>,     // temp file for writes
        pub dirty: bool,                     // has been written to
        pub cached_content: Option<Vec<u8>>, // pre-fetched content for reads
        pub original_size: u64,              // size before modifications
    }
    ```
    - Methods:
      - `new_read(ino: u64, flags: i32) -> Self` -- No temp file, not dirty.
      - `new_write(ino: u64, flags: i32, temp_dir: &Path) -> Result<Self>` -- Create temp file at `{temp_dir}/cb-write-{ino}-{timestamp}`. If file is existing (edit), pre-populate temp file with decrypted content.
      - `write_at(&self, offset: i64, data: &[u8]) -> Result<usize>` -- Write to temp file at offset. Mark dirty.
      - `read_at(&self, offset: i64, size: u32) -> Result<Vec<u8>>` -- Read from temp file (for files opened for write that also need reading).
      - `get_size(&self) -> Result<u64>` -- Current temp file size.
      - `read_all(&self) -> Result<Vec<u8>>` -- Read entire temp file contents (for encrypt+upload on close).
      - `cleanup(&self)` -- Delete temp file. Called after upload or on error.

    Temp directory: `std::env::temp_dir().join("cipherbox")`. Create on app start if it doesn't exist.

    **api/ipfs.rs** - Complete the upload function:
    - `upload_content(client: &ApiClient, data: &[u8], filename: &str) -> Result<UploadResponse>` -- POST `/ipfs/upload` with multipart form. The backend expects the same format as the web app upload. Returns `{ cid, size }`.
    - `unpin_content(client: &ApiClient, cid: &str) -> Result<()>` -- POST `/vault/unpin` with `{ cid }`. Fire-and-forget on delete (matches web app pattern).

    **api/ipns.rs** - Complete the publish function:
    - `publish_ipns(client: &ApiClient, record: &IpnsPublishRequest) -> Result<()>` -- POST `/ipns/publish` with the signed IPNS record. The request body matches what the web app sends:
      ```rust
      pub struct IpnsPublishRequest {
          pub ipns_name: String,
          pub record: String,           // base64-encoded signed IPNS record
          pub sequence_number: u64,
          pub ttl_seconds: u64,          // 86400 (24h) for client publishes
          pub encrypted_ipns_private_key: Option<String>, // hex, only on first publish
          pub key_epoch: Option<u32>,    // TEE epoch
      }
      ```
    - NOTE: IPNS record creation requires signing with Ed25519 in Rust. The IPNS record format must match what the TypeScript `createIpnsRecord` function produces. Use the `ipns` crate if available in Rust, or construct the protobuf/CBOR record manually following the same format as `@cipherbox/crypto/ipns`. For v1, prioritize correctness over elegance -- if constructing IPNS records in Rust is too complex, consider using the `prost` crate for protobuf encoding matching the IPNS spec.

    **fuse/mod.rs** updates:
    - Add `temp_dir: PathBuf` field to CipherVaultFS.
    - Create temp directory in mount_filesystem initialization.
    - Clean up temp directory on unmount.
    - Add helper: `update_folder_metadata(&mut self, parent_ino: u64) -> Result<()>` -- Rebuild FolderMetadata from inode table children, encrypt with folder_key, create new CID, sign IPNS record, publish via API. This is called after any mutation (create, delete, rename).
  </action>
  <verify>
    `cargo check` passes.
    OpenFileHandle can create temp files, write, read, and cleanup.
    API functions compile with correct request/response types.
  </verify>
  <done>
    Temp-file write model, IPFS upload/unpin, and IPNS publish helpers implemented and compiling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FUSE write operations on Filesystem trait</name>
  <files>
    apps/desktop/src-tauri/src/fuse/operations.rs
    apps/desktop/src-tauri/src/fuse/mod.rs
  </files>
  <action>
    Add write operations to the CipherVaultFS Filesystem implementation:

    1. **`create(&mut self, _req, parent, name, mode, umask, flags, reply)`**: Create a new file:
       - Allocate new inode.
       - Generate random file ID (UUID).
       - Add InodeData to inode table (kind=File, empty CID initially, size=0).
       - Add to parent's children list.
       - Create OpenFileHandle with temp file for writing.
       - Reply with ReplyCreated (TTL, attr, generation=0, fh, flags=0).
       - The file isn't uploaded until release() -- it exists only locally in temp file.

    2. **`write(&mut self, _req, ino, fh, offset, data, _write_flags, _flags, _lock, reply)`**: Write to open file:
       - Get OpenFileHandle by fh.
       - Call handle.write_at(offset, data).
       - Mark handle dirty.
       - Update inode attr.size if offset+data.len() > current size.
       - reply.written(data.len() as u32).

    3. **`open` (update from plan 09-04)**: If flags include O_WRONLY or O_RDWR:
       - Create OpenFileHandle with temp file.
       - If existing file (has CID): fetch encrypted content from IPFS, decrypt, write to temp file (so edits work on full file content).
       - Reply with fh.

    4. **`release` (update from plan 09-04)**: If handle is dirty:
       - Read complete temp file content.
       - Generate new random file key (32 bytes) and IV (12 bytes).
       - Encrypt content: `encrypt_aes_gcm(plaintext, &file_key, &iv)`.
       - Wrap file key: `wrap_key(&file_key, &public_key)`.
       - Upload encrypted content to IPFS via `upload_content`. Get new CID.
       - If file had a previous CID: fire-and-forget unpin of old CID.
       - Update inode data: new CID, new encrypted_file_key, new IV, new size.
       - Call `update_folder_metadata(parent_ino)` to re-encrypt and publish folder metadata.
       - Zero file_key from memory.
       - Cleanup temp file.
       - reply.ok().
       On error: log error, cleanup temp file, reply.ok() (don't return EIO to avoid confusing apps).

    5. **`unlink(&mut self, _req, parent, name, reply)`**: Delete a file:
       - Find child inode by (parent, name).
       - If not a file, reply.error(EISDIR).
       - Fire-and-forget unpin of file's CID.
       - Remove inode from table.
       - Remove from parent's children.
       - Update parent's folder metadata via `update_folder_metadata(parent)`.
       - Invalidate content cache for this CID.
       - reply.ok().

    6. **`mkdir(&mut self, _req, parent, name, _mode, _umask, reply)`**: Create folder:
       - Allocate new inode.
       - Generate new folder ID (UUID), new folder_key (32 random bytes).
       - Generate new Ed25519 keypair for this folder's IPNS.
       - Derive IPNS name from public key.
       - Create initial empty FolderMetadata, encrypt with folder_key, upload to IPFS to get initial CID.
       - Create and sign IPNS record pointing to the CID.
       - Publish IPNS record via API.
       - Wrap folder_key with user's public key (ECIES) for storage in parent metadata.
       - Encrypt IPNS private key with TEE public key for republishing enrollment.
       - Add InodeData (kind=Folder) to inode table with children=[].
       - Add to parent's children.
       - Update parent's folder metadata.
       - reply.entry(TTL, attr, 0).

    7. **`rmdir(&mut self, _req, parent, name, reply)`**: Delete folder:
       - Find child inode by (parent, name).
       - If not a folder, reply.error(ENOTDIR).
       - If folder has children, reply.error(ENOTEMPTY). (Finder will recursively delete children first.)
       - Remove inode from table.
       - Remove from parent's children.
       - Update parent's folder metadata.
       - Fire-and-forget: unpin folder's IPNS CID.
       - reply.ok().

    8. **`rename(&mut self, _req, parent, name, newparent, newname, _flags, reply)`**: Rename/move:
       - Find source inode.
       - If destination exists: handle replacement (unlink existing if file, error if non-empty dir).
       - Update inode name.
       - If moving across folders (parent != newparent):
         a. Remove from old parent's children.
         b. Add to new parent's children.
         c. Update inode's parent_ino.
         d. Update BOTH parents' folder metadata.
       - If renaming in same folder:
         a. Update inode name.
         b. Update parent's folder metadata.
       - reply.ok().

    9. **`setattr(&mut self, _req, ino, _mode, _uid, _gid, size, _atime, _mtime, _ctime, fh, _crtime, _chgtime, _bkuptime, _flags, reply)`**: Handle truncate:
       - If `size` is Some: truncate the file. If file handle exists, truncate temp file. Update inode attr.size.
       - Reply with updated attr.
       - Per RESEARCH.md pitfall 4: don't try to independently set atime/mtime (FUSE-T limitation).

    10. **`flush(&mut self, _req, ino, fh, _lock, reply)`**: No-op for now (actual upload happens on release). reply.ok().

    **update_folder_metadata helper** (in mod.rs or operations.rs):
    - Collect all children of parent_ino from inode table.
    - Build FolderMetadata struct with proper FolderChild entries.
    - Encrypt with parent's folder_key using `encrypt_folder_metadata`.
    - Upload encrypted metadata to IPFS.
    - Get previous sequence_number from metadata cache, increment.
    - Sign new IPNS record (Ed25519) pointing to new CID.
    - Publish via `api::ipns::publish_ipns`.
    - Update metadata cache.
    - If old metadata CID exists, fire-and-forget unpin.
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes.
    Verify all write operations are implemented: create, write, release (with upload), unlink, mkdir, rmdir, rename, setattr, flush.
    Verify temp-file commit model: writes go to temp file, encrypt+upload on release only.
    Verify folder metadata is updated after every mutation.
  </verify>
  <done>
    Full read-write FUSE filesystem with temp-file commit model. Files created/edited/deleted through FUSE mount. Folders created/deleted/renamed. All mutations trigger folder metadata re-encryption and IPNS publish.
  </done>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass
- FUSE write operations: create, write, release, unlink, mkdir, rmdir, rename, setattr, flush
- Temp-file commit: writes buffer to temp, encrypt+upload on close
- New file: generate random key+IV, encrypt, upload, wrap key, update metadata
- Delete: unpin CID (fire-and-forget), update parent metadata
- Rename: update inode + parent metadata (both parents if cross-folder move)
- mkdir: generate folder_key, IPNS keypair, initial empty metadata, TEE enrollment
- All mutations call update_folder_metadata to re-encrypt and publish IPNS
</verification>

<success_criteria>
Users can create, edit, delete, and rename files and folders through the FUSE mount. All operations correctly encrypt/decrypt data and publish updated IPNS metadata.
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-05-SUMMARY.md`
</output>
