---
phase: 09-desktop-client
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - apps/desktop/src-tauri/src/crypto/mod.rs
  - apps/desktop/src-tauri/src/crypto/aes.rs
  - apps/desktop/src-tauri/src/crypto/ecies.rs
  - apps/desktop/src-tauri/src/crypto/ed25519.rs
  - apps/desktop/src-tauri/src/crypto/utils.rs
  - apps/desktop/src-tauri/src/crypto/folder.rs
  - apps/desktop/src-tauri/src/crypto/ipns.rs
  - apps/desktop/src-tauri/src/crypto/tests.rs
  - apps/desktop/src-tauri/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Rust crypto module encrypts/decrypts data identically to @cipherbox/crypto TypeScript module"
    - "ECIES cross-language compatibility verified with test vectors from existing crypto tests"
    - "AES-256-GCM sealed format (IV || ciphertext || tag) matches TypeScript sealAesGcm output"
    - "Ed25519 signatures are deterministic and identical across Rust and TypeScript"
    - "IPNS records created in Rust can be unmarshaled by the TypeScript ipns package"
    - "IPNS name derivation from Ed25519 public key produces identical results in Rust and TypeScript"
  artifacts:
    - path: "apps/desktop/src-tauri/src/crypto/mod.rs"
      provides: "Rust crypto module with AES-256-GCM, ECIES, Ed25519, IPNS"
      exports: ["encrypt_aes_gcm", "decrypt_aes_gcm", "seal_aes_gcm", "unseal_aes_gcm", "wrap_key", "unwrap_key", "create_ipns_record", "derive_ipns_name", "marshal_ipns_record"]
    - path: "apps/desktop/src-tauri/src/crypto/ipns.rs"
      provides: "IPNS record creation, marshaling, and name derivation in Rust"
      exports: ["create_ipns_record", "marshal_ipns_record", "derive_ipns_name"]
    - path: "apps/desktop/src-tauri/src/crypto/tests.rs"
      provides: "Cross-language test vectors for AES, ECIES, Ed25519, and IPNS"
      contains: "cross_language"
  key_links:
    - from: "apps/desktop/src-tauri/src/crypto/aes.rs"
      to: "packages/crypto/src/aes/seal.ts"
      via: "identical sealed format: IV(12) || ciphertext || tag(16)"
      pattern: "AES_IV_SIZE.*12|AES_TAG_SIZE.*16"
    - from: "apps/desktop/src-tauri/src/crypto/ecies.rs"
      to: "packages/crypto/src/ecies/encrypt.ts"
      via: "eciesjs-compatible ECIES format"
      pattern: "ecies::encrypt|ecies::decrypt"
    - from: "apps/desktop/src-tauri/src/crypto/ipns.rs"
      to: "packages/crypto/src/ipns/create-record.ts"
      via: "Protobuf-encoded IPNS record with V2 CBOR data and Ed25519 signature"
      pattern: "IpnsEntry|signatureV2|data"
    - from: "apps/desktop/src-tauri/src/crypto/ipns.rs"
      to: "packages/crypto/src/ipns/derive-name.ts"
      via: "CIDv1 with libp2p-key codec (0x72) + identity multihash"
      pattern: "derive_ipns_name|0x72|identity"
---

<objective>
Implement the Rust-native crypto module that produces byte-identical output to the existing @cipherbox/crypto TypeScript module, including IPNS record creation and name derivation.

Purpose: This is the highest-value task in the entire phase because every FUSE operation depends on it. The Rust crypto module eliminates the webview IPC bottleneck -- FUSE operations call Rust crypto directly without round-tripping through JavaScript. IPNS record creation is needed for write operations (folder metadata updates). Cross-language format compatibility is critical: files encrypted by the web app must decrypt in the desktop app and vice versa, and IPNS records created in Rust must be accepted by the backend and IPFS network.

Output: A Rust crypto module verified against TypeScript test vectors, including IPNS record creation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@.planning/phases/09-desktop-client/09-01-SUMMARY.md
@packages/crypto/src/index.ts
@packages/crypto/src/constants.ts
@packages/crypto/src/types.ts
@packages/crypto/src/aes/encrypt.ts
@packages/crypto/src/aes/seal.ts
@packages/crypto/src/ecies/encrypt.ts
@packages/crypto/src/ecies/decrypt.ts
@packages/crypto/src/ipns/index.ts
@packages/crypto/src/ipns/create-record.ts
@packages/crypto/src/ipns/marshal.ts
@packages/crypto/src/ipns/sign-record.ts
@packages/crypto/src/ipns/derive-name.ts
@packages/crypto/src/__tests__/aes.test.ts
@packages/crypto/src/__tests__/ecies.test.ts
@packages/crypto/src/__tests__/ed25519.test.ts
@packages/crypto/src/__tests__/ipns-record.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Rust AES-256-GCM, ECIES, Ed25519, and folder metadata</name>
  <files>
    apps/desktop/src-tauri/src/crypto/mod.rs
    apps/desktop/src-tauri/src/crypto/aes.rs
    apps/desktop/src-tauri/src/crypto/ecies.rs
    apps/desktop/src-tauri/src/crypto/ed25519.rs
    apps/desktop/src-tauri/src/crypto/utils.rs
    apps/desktop/src-tauri/src/crypto/folder.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    Create the Rust crypto module that mirrors `@cipherbox/crypto` operations.

    **crypto/mod.rs**: Module declarations for aes, ecies, ed25519, utils, folder, ipns. Re-export public functions. Add `#[cfg(test)] mod tests;`.

    **crypto/aes.rs**: Implement AES-256-GCM operations using the `aes-gcm` crate:
    - `encrypt_aes_gcm(plaintext: &[u8], key: &[u8; 32], iv: &[u8; 12]) -> Result<Vec<u8>>` -- Returns ciphertext with 16-byte auth tag appended (same as Web Crypto API)
    - `decrypt_aes_gcm(ciphertext: &[u8], key: &[u8; 32], iv: &[u8; 12]) -> Result<Vec<u8>>` -- Expects ciphertext with tag appended
    - `seal_aes_gcm(plaintext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>>` -- Generate random IV, encrypt, return IV(12) || ciphertext || tag(16). This MUST match the TypeScript `sealAesGcm` format exactly.
    - `unseal_aes_gcm(sealed: &[u8], key: &[u8; 32]) -> Result<Vec<u8>>` -- Extract IV from first 12 bytes, decrypt remainder.
    - Constants: `AES_KEY_SIZE = 32`, `AES_IV_SIZE = 12`, `AES_TAG_SIZE = 16`.

    **crypto/ecies.rs**: Implement ECIES using the `ecies` crate:
    - `wrap_key(data: &[u8], recipient_public_key: &[u8]) -> Result<Vec<u8>>` -- ECIES encrypt. The `ecies` Rust crate and `eciesjs` npm package are from the same author (ecies/rs and ecies/js). They use the same format: ephemeral_pubkey(65) || nonce(16) || tag(16) || ciphertext. Verify this with test vectors.
    - `unwrap_key(wrapped: &[u8], private_key: &[u8]) -> Result<Vec<u8>>` -- ECIES decrypt.
    - Validate public key: 65 bytes, 0x04 prefix (uncompressed secp256k1).
    - Validate private key: 32 bytes.

    CRITICAL: The `ecies` Rust crate MUST produce output that `eciesjs` TypeScript can decrypt, and vice versa. The cross-language test vectors will confirm this. If the `ecies` crate uses a different format, fall back to manual ECDH + HKDF + AES-GCM construction matching eciesjs exactly.

    **crypto/ed25519.rs**: Implement Ed25519 using `ed25519-dalek`:
    - `generate_ed25519_keypair() -> (Vec<u8>, Vec<u8>)` -- Returns (public_key_32bytes, private_key_32bytes).
    - `sign_ed25519(message: &[u8], private_key: &[u8]) -> Result<Vec<u8>>` -- Returns 64-byte signature.
    - `verify_ed25519(message: &[u8], signature: &[u8], public_key: &[u8]) -> bool` -- Returns bool, no exceptions.
    - `get_public_key(private_key: &[u8]) -> Result<Vec<u8>>` -- Derive 32-byte public key from 32-byte private key.

    **crypto/utils.rs**: Utility functions:
    - `generate_random_bytes(len: usize) -> Vec<u8>` -- Using `rand::rngs::OsRng`.
    - `generate_file_key() -> [u8; 32]` -- Random 32-byte AES key.
    - `generate_iv() -> [u8; 12]` -- Random 12-byte IV.
    - `hex_to_bytes(hex: &str) -> Result<Vec<u8>>` and `bytes_to_hex(bytes: &[u8]) -> String`.
    - `clear_bytes(buf: &mut [u8])` -- Zeroize sensitive data using `zeroize` crate.

    **crypto/folder.rs**: Folder metadata types:
    - `FolderMetadata` struct with `children: Vec<FolderChild>` matching the TypeScript `FolderMetadata` type.
    - `FolderChild` enum: `File(FileEntry)` or `Folder(FolderEntry)`.
    - `FileEntry` struct: `id: String, name: String, cid: String, file_key_encrypted: String, file_iv: String, size: u64, created_at: u64, modified_at: u64, encryption_mode: String`.
      - IMPORTANT: Add `#[serde(rename_all = "camelCase")]` to `FileEntry`. Serde will serialize/deserialize using camelCase field names matching the TypeScript JSON format: `fileKeyEncrypted`, `fileIv`, `encryptionMode`, `createdAt`, `modifiedAt`. The Rust struct uses snake_case per Rust convention; Serde handles the translation.
    - `FolderEntry` struct: `id: String, name: String, ipns_name: String, folder_key_encrypted: String, ipns_private_key_encrypted: String, created_at: u64, modified_at: u64`.
      - IMPORTANT: Add `#[serde(rename_all = "camelCase")]` to `FolderEntry`. Serde will serialize/deserialize using camelCase field names matching the TypeScript JSON format: `ipnsName`, `folderKeyEncrypted`, `ipnsPrivateKeyEncrypted`, `createdAt`, `modifiedAt`. The Rust struct uses snake_case per Rust convention; Serde handles the translation.
      - The `ipns_private_key_encrypted` field contains the hex-encoded ECIES-wrapped Ed25519 IPNS private key. This is needed for write operations on subfolders -- without it, the desktop client cannot sign IPNS records when updating folder metadata.
      - The `folder_key_encrypted` field contains the hex-encoded ECIES-wrapped folder AES key.
    - `encrypt_folder_metadata(metadata: &FolderMetadata, folder_key: &[u8; 32]) -> Result<Vec<u8>>` -- JSON serialize then sealAesGcm.
    - `decrypt_folder_metadata(sealed: &[u8], folder_key: &[u8; 32]) -> Result<FolderMetadata>` -- unsealAesGcm then JSON deserialize.

    Update **main.rs** to add `mod crypto;` declaration.
  </action>
  <verify>
    Run `cd apps/desktop/src-tauri && cargo check` -- no compilation errors.
    Verify AES, ECIES, Ed25519, and folder metadata modules compile.
    Verify FolderEntry has ipns_private_key_encrypted field.
    Verify FileEntry has encryption_mode field.
    Verify both structs have `#[serde(rename_all = "camelCase")]`.
  </verify>
  <done>
    Rust crypto module (AES, ECIES, Ed25519, folder) compiles without errors. FolderEntry includes ipnsPrivateKeyEncrypted (camelCase via Serde). FileEntry includes encryptionMode (camelCase via Serde). IPNS module comes in Task 2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IPNS record creation and cross-language test vectors</name>
  <files>
    apps/desktop/src-tauri/src/crypto/ipns.rs
    apps/desktop/src-tauri/src/crypto/tests.rs
    apps/desktop/src-tauri/src/crypto/mod.rs
  </files>
  <action>
    **crypto/ipns.rs** - Implement IPNS record creation in Rust matching the TypeScript `ipns` npm package output. Reference `packages/crypto/src/ipns/` source files for the exact format.

    The TypeScript `createIpnsRecord` uses the `ipns` npm package which produces:
    - A protobuf-encoded `IpnsEntry` (the marshaled record)
    - CBOR-encoded `data` field containing: Value, Validity, ValidityType, Sequence, TTL
    - `signatureV2`: Ed25519 signature over "ipns-signature:" + CBOR data
    - `signatureV1`: Ed25519 signature over Value + Validity + ValidityType (for V1 compat)

    Implement these functions:

    1. `create_ipns_record(ed25519_private_key: &[u8; 32], value: &str, sequence_number: u64, lifetime_ms: u64) -> Result<IpnsRecord>`:
       - Build CBOR data map with fields: Value, Validity, ValidityType, Sequence, TTL
       - Compute signatureV2: sign("ipns-signature:" + cbor_data) with ed25519_private_key
       - Compute signatureV1: sign(value_bytes + validity_bytes + varint(0)) with ed25519_private_key (for V1 compatibility)
       - Use `ciborium` crate for CBOR encoding

    2. `marshal_ipns_record(record: &IpnsRecord) -> Result<Vec<u8>>`:
       - Encode as protobuf `IpnsEntry` message using `prost` crate
       - IpnsEntry protobuf schema (field numbers match ipns spec):
         - field 1 (bytes): Value
         - field 2 (bytes): signatureV1
         - field 3 (enum): ValidityType (0 = EOL)
         - field 4 (bytes): Validity (RFC3339 as bytes)
         - field 5 (uint64): Sequence
         - field 6 (uint64): TTL (nanoseconds)
         - field 7 (bytes): pubKey (Ed25519 public key, protobuf-wrapped: type=Ed25519(1) + data)
         - field 8 (bytes): signatureV2
         - field 9 (bytes): data (CBOR)

       For the `pubKey` field: This is the Ed25519 public key wrapped in a libp2p crypto protobuf: `message PublicKey { KeyType Type = 1; bytes Data = 2; }` where KeyType.Ed25519 = 1. Encode this inner protobuf and set as pubKey field.

       Use `prost` for protobuf encoding. Define the message struct with `prost::Message` derive, OR manually encode using prost's encoding functions (prost::encoding::bytes, prost::encoding::uint64, etc.) to match exact field numbers.

    3. `derive_ipns_name(ed25519_public_key: &[u8; 32]) -> Result<String>`:
       - The IPNS name is a CIDv1 with libp2p-key multicodec
       - Steps:
         a. Wrap public key in libp2p PublicKey protobuf: `{Type: 1 (Ed25519), Data: <32 bytes>}`
         b. Create identity multihash: `0x00` (identity code) + varint(length) + protobuf_bytes
         c. Create CIDv1: version=1, codec=0x72 (libp2p-key), multihash=identity_hash
         d. Encode as base36 string (k51... prefix)
       - Use `multihash` crate with identity feature, and `unsigned-varint` for varint encoding
       - For base36 encoding: implement a simple base36 encoder or use the `multibase` crate. The base36 alphabet is `0123456789abcdefghijklmnopqrstuvwxyz` with prefix `k`.

    4. `IpnsRecord` struct:
       ```rust
       pub struct IpnsRecord {
           pub value: String,
           pub validity: String,       // RFC3339 timestamp
           pub validity_type: u32,     // 0 = EOL
           pub sequence: u64,
           pub ttl: u64,              // nanoseconds
           pub signature_v1: Vec<u8>, // 64-byte Ed25519
           pub signature_v2: Vec<u8>, // 64-byte Ed25519
           pub data: Vec<u8>,         // CBOR-encoded
           pub public_key: Vec<u8>,   // 32-byte Ed25519 public key
       }
       ```

    CRITICAL IPNS SIGNATURE PREFIX: The V2 signature is computed over `b"ipns-signature:" + cbor_data`. This matches the TypeScript `IPNS_SIGNATURE_PREFIX` in `packages/crypto/src/ipns/sign-record.ts`.

    CRITICAL CBOR FIELD ORDER: The `ipns` npm package encodes CBOR data with specific field ordering. Use an ordered map (BTreeMap or explicit CBOR map construction) to ensure deterministic output. The fields in the CBOR data map are: Value, Validity, ValidityType, Sequence, TTL -- use string keys matching the ipns spec exactly.

    **crypto/tests.rs** - Cross-language test vectors for ALL crypto operations:

    First, generate test vectors from TypeScript. Create a small script or use the existing test infrastructure to produce known ciphertext/signatures from fixed keys:

    1. **AES-256-GCM cross-language test**: Use a fixed key (32 bytes hex) and IV (12 bytes hex), encrypt known plaintext "Hello, CipherBox!" in BOTH TypeScript and Rust, assert byte-identical ciphertext. Include the raw ciphertext bytes as a constant in the Rust test (pre-computed from the TypeScript module).

    2. **seal/unseal cross-language test**: Given a sealed blob from TypeScript sealAesGcm (pre-computed), verify Rust unseal_aes_gcm decrypts correctly.

    3. **ECIES cross-language test**: wrap_key with a known keypair in TypeScript, verify unwrap_key in Rust decrypts to the same plaintext. Also test Rust wrap -> TypeScript unwrap direction by including a Rust-encrypted test vector.

    4. **Ed25519 cross-language test**: Sign same message with same private key in both, verify signatures are deterministic and identical.

    5. **IPNS record cross-language test**: This is the new critical test.
       - Use a fixed Ed25519 keypair (32-byte private key as hex constant).
       - Create an IPNS record in TypeScript with: value="/ipfs/bafybeicklkqcnlvtiscr2hzkubjwnwjinvskffn4xorqeduft3wq7vm5u4", sequence=42, lifetime=86400000ms (24h), fixed validity timestamp.
       - Marshal the record to bytes in TypeScript using `marshalIpnsRecord`.
       - Include the marshaled bytes as a constant in Rust tests.
       - In Rust: create an IPNS record with the SAME inputs, marshal it, and verify:
         a. The `signatureV2` field is byte-identical (since Ed25519 is deterministic, same CBOR data + same key = same signature).
         b. The `data` (CBOR) field is byte-identical.
         c. The `value` and `sequence` fields match.
       - Note: The `validity` field contains a timestamp, so for deterministic testing, either use a fixed timestamp in both implementations or only compare the structural fields (signatureV2, data, value, sequence).
       - Alternative approach: Create record in Rust, marshal, then unmarshal in TypeScript (via a Node.js script run during `cargo test`) and verify fields match. If running Node.js from cargo test is too complex, use the pre-computed approach.

    6. **IPNS name derivation cross-language test**:
       - Use the same fixed Ed25519 keypair.
       - Derive IPNS name in TypeScript using `deriveIpnsName`.
       - Include the resulting name string as a constant in Rust tests.
       - Verify Rust `derive_ipns_name` produces the identical string.

    To generate TypeScript test vectors: Write a small Node.js script (`apps/desktop/src-tauri/generate-test-vectors.mjs`) that uses `@cipherbox/crypto` to produce hex-encoded test vectors. Run it once, paste results into Rust tests as constants. The script should be committed for reproducibility but does not need to run as part of `cargo test`.

    Update **crypto/mod.rs** to declare ipns submodule.
  </action>
  <verify>
    Run `cd apps/desktop/src-tauri && cargo test` -- all crypto tests pass including IPNS.
    Run `cd apps/desktop/src-tauri && cargo check` -- no compilation errors.
    Verify AES seal/unseal round-trip works.
    Verify ECIES wrap/unwrap round-trip works.
    Verify Ed25519 sign/verify round-trip works.
    Verify IPNS record creation produces valid protobuf output.
    Verify IPNS name derivation produces k51... format string.
    Verify cross-language test vectors match pre-computed TypeScript values.
  </verify>
  <done>
    All `cargo test` crypto tests pass. AES, ECIES, Ed25519, and IPNS operations produce correct output. Cross-language test vectors (pre-computed from TypeScript) verify format compatibility for all operations including IPNS records and name derivation.
  </done>
</task>

</tasks>

<verification>
- `cargo check` succeeds
- `cargo test` passes all crypto tests
- Crypto constants match TypeScript: AES_KEY_SIZE=32, AES_IV_SIZE=12, AES_TAG_SIZE=16, SECP256K1_PUBLIC_KEY_SIZE=65
- IPNS record marshaling produces valid protobuf with signatureV1, signatureV2, CBOR data, and pubKey fields
- IPNS name derivation produces CIDv1 base36 string matching TypeScript deriveIpnsName
- Cross-language test vectors pass for all operations
- FolderEntry has ipns_private_key_encrypted field (camelCase via Serde: ipnsPrivateKeyEncrypted)
- FileEntry has encryption_mode field (camelCase via Serde: encryptionMode)
- Both FolderEntry and FileEntry use #[serde(rename_all = "camelCase")]
</verification>

<success_criteria>
Rust crypto module passes all tests including cross-language format verification for AES, ECIES, Ed25519, and IPNS. IPNS records created in Rust are structurally compatible with the TypeScript ipns package output. FolderEntry and FileEntry structs include all fields needed for write operations (ipnsPrivateKeyEncrypted, encryptionMode) with correct Serde camelCase renaming.
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-02-SUMMARY.md`
</output>
