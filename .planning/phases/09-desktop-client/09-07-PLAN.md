---
phase: 09-desktop-client
plan: 07
type: execute
wave: 6
depends_on: ["09-04", "09-05", "09-06"]
files_modified:
  - apps/desktop/src-tauri/src/tray/mod.rs
  - apps/desktop/src-tauri/src/tray/status.rs
  - apps/desktop/src-tauri/src/sync/mod.rs
  - apps/desktop/src-tauri/src/sync/queue.rs
  - apps/desktop/src-tauri/src/sync/tests.rs
  - apps/desktop/src-tauri/src/main.rs
  - apps/desktop/src-tauri/src/commands.rs
autonomous: false

must_haves:
  truths:
    - "App runs in system tray with menu bar icon (no Dock icon)"
    - "Tray menu shows current status (synced/syncing/error/offline/not connected)"
    - "Tray menu has Open CipherVault, Sync Now, Logout, and Quit items"
    - "Background sync polls IPNS every 30 seconds and refreshes folder metadata on changes"
    - "Sync pauses when offline and resumes immediately on reconnect"
    - "Queued writes (from offline edits) are uploaded when connectivity returns"
    - "Clicking Open CipherVault opens ~/CipherVault in Finder"
  artifacts:
    - path: "apps/desktop/src-tauri/src/tray/mod.rs"
      provides: "Tray icon builder with menu items and event handling"
      exports: ["build_tray", "update_tray_status"]
    - path: "apps/desktop/src-tauri/src/tray/status.rs"
      provides: "Status state machine for tray icon"
      exports: ["TrayStatus"]
    - path: "apps/desktop/src-tauri/src/sync/mod.rs"
      provides: "Background sync daemon polling IPNS"
      exports: ["SyncDaemon"]
    - path: "apps/desktop/src-tauri/src/sync/queue.rs"
      provides: "Offline write queue for deferred uploads"
      exports: ["WriteQueue", "QueuedWrite"]
    - path: "apps/desktop/src-tauri/src/sync/tests.rs"
      provides: "Unit tests for WriteQueue.process()"
      contains: "test_write_queue"
  key_links:
    - from: "apps/desktop/src-tauri/src/sync/mod.rs"
      to: "apps/desktop/src-tauri/src/api/ipns.rs"
      via: "resolve_ipns polling every 30s"
      pattern: "resolve_ipns"
    - from: "apps/desktop/src-tauri/src/sync/mod.rs"
      to: "apps/desktop/src-tauri/src/fuse/inode.rs"
      via: "refresh inode table when IPNS changes detected"
      pattern: "populate_folder|InodeTable"
    - from: "apps/desktop/src-tauri/src/tray/mod.rs"
      to: "apps/desktop/src-tauri/src/commands.rs"
      via: "menu event handlers trigger commands"
      pattern: "logout|mount_filesystem|unmount_filesystem"
---

<objective>
Implement the system tray menu bar icon, background sync daemon, and offline write queue. This completes the desktop client as a background utility that stays in sync.

Purpose: The app needs to feel like a native macOS background utility (like Dropbox). Menu bar icon for status at a glance, background sync for automatic updates, and offline queue so writes don't fail when the network drops.

Output: Fully functional menu bar app with background sync and offline resilience.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@.planning/phases/09-desktop-client/09-04-SUMMARY.md
@.planning/phases/09-desktop-client/09-05-SUMMARY.md
@.planning/phases/09-desktop-client/09-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tray icon, background sync daemon, and offline write queue with tests</name>
  <files>
    apps/desktop/src-tauri/src/tray/mod.rs
    apps/desktop/src-tauri/src/tray/status.rs
    apps/desktop/src-tauri/src/sync/mod.rs
    apps/desktop/src-tauri/src/sync/queue.rs
    apps/desktop/src-tauri/src/sync/tests.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    **tray/status.rs** - Status state machine:
    ```rust
    pub enum TrayStatus {
        NotConnected,   // No auth, no mount
        Mounting,       // Auth complete, FUSE mounting
        Syncing,        // Polling/refreshing metadata
        Synced,         // Up to date
        Offline,        // Network unavailable
        Error(String),  // Something went wrong
    }
    ```
    - `impl TrayStatus { fn label(&self) -> &str }` -- Returns human-readable status text.
    - `impl TrayStatus { fn is_connected(&self) -> bool }` -- True for Syncing, Synced, Offline.

    **tray/mod.rs** - Tray icon setup:
    - `build_tray(app: &AppHandle) -> Result<()>`:
      - Create menu items:
        - `status`: "Status: Not Connected" (disabled, informational)
        - `open`: "Open CipherVault" (enabled when mounted)
        - `sync`: "Sync Now" (enabled when connected)
        - Separator
        - `login`: "Login..." (shown when not connected)
        - `logout`: "Logout" (shown when connected)
        - Separator
        - `quit`: "Quit CipherBox"
      - Build TrayIcon with menu, set `menu_on_left_click(true)`.
      - Register on_menu_event handler:
        - `"open"`: `std::process::Command::new("open").arg(mount_point).spawn()`
        - `"sync"`: Trigger immediate sync via SyncDaemon channel
        - `"login"`: Show webview window for Web3Auth login
        - `"logout"`: Invoke logout command (unmount + clear keys + clear Keychain)
        - `"quit"`: Unmount if mounted, then `app.exit(0)`
      - Set icon using default window icon or a custom icon from icons/ directory.

    - `update_tray_status(app: &AppHandle, status: &TrayStatus)`:
      - Update the status menu item text: "Status: {status.label()}"
      - Enable/disable menu items based on status:
        - open: enabled only when status is Syncing or Synced
        - sync: enabled only when status is Synced or Error
        - login: visible only when NotConnected
        - logout: visible only when connected
      - On Error status: send notification via tauri-plugin-notification with error message.

    **sync/mod.rs** - Background sync daemon:
    - `SyncDaemon` struct:
      - `api: ApiClient`
      - `state: Arc<AppState>` (shared app state)
      - `fs: Arc<RwLock<CipherVaultFS>>` (shared filesystem reference for inode updates)
      - `poll_interval: Duration` (30s)
      - `cached_sequence_numbers: HashMap<String, u64>` -- ipns_name -> last known sequence_number
      - `sync_now_rx: tokio::sync::mpsc::Receiver<()>` -- channel for manual sync trigger
      - `write_queue: WriteQueue`

    - `SyncDaemon::run(&mut self)`:
      - Loop:
        - `tokio::select!` on either `ticker.tick()` or `sync_now_rx.recv()`.
        - Call `self.poll()`.
        - Process write queue: `self.write_queue.process(&self.api)`.
        - On network error: set TrayStatus::Offline, increase backoff.
        - On success: set TrayStatus::Synced, reset backoff.

    - `SyncDaemon::poll(&mut self) -> Result<()>`:
      - For each known folder (starting with root):
        - Resolve IPNS name via `api::ipns::resolve_ipns`.
        - Compare sequence_number with cached value.
        - If changed: fetch new encrypted metadata, decrypt, update inode table.
        - Update cached_sequence_numbers.
      - For root folder: also check if root CID changed and recursively refresh.
      - Use sequence_number comparison (not CID) per project decision from Phase 7.

    - Network detection: After each failed HTTP call, check if online. If offline, switch to TrayStatus::Offline and pause polling (just wait for the next tick, check connectivity first). On first successful call after being offline, set TrayStatus::Syncing.

    **sync/queue.rs** - Offline write queue:
    - `QueuedWrite` struct:
      - `id: String` (UUID)
      - `parent_ino: u64`
      - `encrypted_content: Vec<u8>` -- already encrypted (encrypt at queue time, not upload time)
      - `encrypted_file_key: Vec<u8>` -- already wrapped
      - `iv: Vec<u8>`
      - `filename: String`
      - `created_at: Instant`
      - `retries: u32`

    - `WriteQueue` struct:
      - `queue: VecDeque<QueuedWrite>`
      - `max_retries: u32` (= 5)

    - `WriteQueue::enqueue(&mut self, write: QueuedWrite)` -- Add to queue.
    - `WriteQueue::process(&mut self, api: &ApiClient) -> Result<usize>`:
      - Process queue FIFO.
      - For each item: try upload_content + update_folder_metadata.
      - On success: remove from queue, return count of processed items.
      - On failure: increment retries, move to back of queue.
      - If retries > max_retries: drop the item and log error.
    - `WriteQueue::len(&self) -> usize` -- Queue size for monitoring.
    - `WriteQueue::is_empty(&self) -> bool`.

    Memory-only queue per CONTEXT.md ("Claude's Discretion" on offline write queue persistence). Queued items lost on app quit -- acceptable for v1 given small file sizes and tech demo scope.

    **sync/tests.rs** - Unit tests for WriteQueue:
    - `test_write_queue_enqueue_and_len`: Enqueue items, verify len increases.
    - `test_write_queue_process_success`: Create a mock ApiClient (or use a trait-based mock). Verify process() removes items from queue on success, returns count.
    - `test_write_queue_process_failure_retries`: Mock API failure. Verify item is moved to back of queue with retries incremented. Verify item is dropped after max_retries exceeded.
    - `test_write_queue_fifo_order`: Enqueue A then B. Verify A is processed first.
    - `test_write_queue_is_empty`: Verify empty on init, non-empty after enqueue, empty after successful process.

    For testability: Make WriteQueue's `process` method accept a trait `UploadHandler` instead of a concrete `ApiClient`. In production, `ApiClient` implements `UploadHandler`. In tests, use a mock implementation that can be configured to succeed or fail.

    **main.rs** updates:
    - Add `mod tray;` and `mod sync;` declarations.
    - In setup, call `tray::build_tray(app)` to create the menu bar icon.
    - After auth + mount succeeds: spawn SyncDaemon on tokio runtime.
    - Wire up TrayStatus updates throughout the auth and mount lifecycle:
      - On app start: NotConnected
      - On silent refresh attempt: Mounting
      - On mount success: Synced
      - On sync error: Error(msg)
      - On network down: Offline
      - On logout: NotConnected
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes -- including new WriteQueue unit tests.
    Verify tray module creates menu with all items: status, open, sync, login, logout, quit.
    Verify SyncDaemon has 30s polling interval.
    Verify WriteQueue processes FIFO with retry logic (unit tests).
    Verify status state machine covers all states: NotConnected, Mounting, Syncing, Synced, Offline, Error.
  </verify>
  <done>
    Tray icon and sync daemon compile. Menu items wired to app actions. Background sync polls every 30s. Write queue handles offline resilience with unit-tested process() logic.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete desktop client: Tauri app with FUSE mount, Web3Auth login via webview, Keychain token storage, background sync, and system tray menu bar icon.
  </what-built>
  <how-to-verify>
    This is a manual end-to-end verification of the full desktop client.

    Prerequisites:
    - FUSE-T installed on macOS (`brew install macfuse` or download from fuse-t.org)
    - API running locally (`pnpm --filter @cipherbox/api dev`)
    - An existing CipherBox account with some files uploaded via the web app

    Steps:
    1. Build the desktop app: `cd apps/desktop && pnpm tauri dev`
    2. Verify: Menu bar icon appears (no Dock icon). Click it to see the tray menu.
    3. Click "Login..." -- Web3Auth modal should appear in a webview window.
    4. Complete login in the Web3Auth modal.
    5. Verify: Webview window closes after auth. Tray status changes to "Mounting..." then "Synced".
    6. Verify: `ls ~/CipherVault` shows your vault folders and files with decrypted names.
    7. Open a file: `open ~/CipherVault/somefile.txt` -- should open in TextEdit.
    8. Create a file: `echo "test" > ~/CipherVault/test.txt` -- should succeed.
    9. Verify in web app: the file `test.txt` appears after sync.
    10. Create a folder: `mkdir ~/CipherVault/TestFolder` -- should succeed.
    11. Delete the test file: `rm ~/CipherVault/test.txt` -- should succeed.
    12. Delete the test folder: `rmdir ~/CipherVault/TestFolder` -- should succeed.
    13. Click "Sync Now" in tray menu -- status should briefly show "Syncing".
    14. Click "Open CipherVault" in tray -- Finder should open ~/CipherVault.
    15. **Offline write test**: Disconnect from network (Wi-Fi off). Create a file: `echo "offline" > ~/CipherVault/offline-test.txt`. Verify the command succeeds (queued locally). Reconnect to network. Wait for sync (up to 30s). Verify the file appears in the web app.
    16. Click "Logout" in tray -- FUSE unmounts, status returns to "Not Connected".
    17. Relaunch app -- Web3Auth login should appear (silent refresh restores API session but needs Web3Auth for private key).
    18. Click "Quit" -- app exits cleanly, FUSE unmounted.
  </how-to-verify>
  <resume-signal>Type "approved" if the desktop client works end-to-end, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass (including WriteQueue unit tests)
- App compiles with `pnpm tauri dev` or `pnpm tauri build`
- Menu bar icon appears with all menu items
- Status transitions: NotConnected -> Mounting -> Synced -> (Syncing/Offline/Error) -> Synced
- Background sync polls every 30s
- Sequence number comparison detects changes
- Write queue buffers offline writes and processes on reconnect (verified by unit tests AND checkpoint step 15)
- Quit unmounts FUSE before exit
</verification>

<success_criteria>
System tray app with background sync daemon. Tray shows status, provides Open/Sync/Login/Logout/Quit actions. Background sync polls IPNS every 30s. Offline writes queued and retried on reconnect. WriteQueue.process() has unit test coverage.
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-07-SUMMARY.md`
</output>
