---
phase: 09-desktop-client
plan: 04
type: execute
wave: 2
depends_on: ["09-01", "09-02", "09-03"]
files_modified:
  - apps/desktop/src-tauri/src/api/mod.rs
  - apps/desktop/src-tauri/src/api/auth.rs
  - apps/desktop/src-tauri/src/api/client.rs
  - apps/desktop/src-tauri/src/api/types.rs
  - apps/desktop/src-tauri/src/state.rs
  - apps/desktop/src-tauri/src/commands.rs
  - apps/desktop/src-tauri/src/main.rs
  - apps/desktop/src/main.ts
  - apps/desktop/src/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can log in via Web3Auth running inside the Tauri webview and receive tokens in the Rust side"
    - "Refresh token is stored in macOS Keychain via keyring crate"
    - "On app launch, silent refresh from Keychain token is attempted before showing login"
    - "After login, vault keys are fetched and decrypted in Rust (privateKey in memory only)"
    - "Logout clears Keychain token and zeroes keys from memory"
  artifacts:
    - path: "apps/desktop/src-tauri/src/api/auth.rs"
      provides: "Keychain storage and token management"
      exports: ["store_refresh_token", "get_refresh_token", "delete_refresh_token"]
    - path: "apps/desktop/src-tauri/src/api/client.rs"
      provides: "HTTP client with auth header injection and desktop client type header"
      exports: ["ApiClient"]
    - path: "apps/desktop/src-tauri/src/state.rs"
      provides: "App state holding keys in memory"
      exports: ["AppState"]
    - path: "apps/desktop/src-tauri/src/commands.rs"
      provides: "Tauri IPC commands for auth flow"
      exports: ["handle_auth_complete", "try_silent_refresh", "logout"]
  key_links:
    - from: "apps/desktop/src-tauri/src/api/client.rs"
      to: "apps/api/src/auth/auth.controller.ts"
      via: "X-Client-Type: desktop header on all requests"
      pattern: "X-Client-Type.*desktop"
    - from: "apps/desktop/src-tauri/src/api/auth.rs"
      to: "macOS Keychain"
      via: "keyring crate with apple-native feature"
      pattern: "keyring::Entry"
    - from: "apps/desktop/src-tauri/src/commands.rs"
      to: "apps/desktop/src/auth.ts"
      via: "Tauri invoke IPC"
      pattern: "invoke.*handle_auth_complete"
---

<objective>
Implement the desktop authentication flow: Web3Auth login inside the Tauri webview, IPC command for passing credentials to Rust, Keychain storage for refresh tokens, silent refresh on app launch, and vault key decryption.

Purpose: Authentication is the gateway to all vault operations. After this plan, the app can authenticate, fetch vault keys, and hold decrypted keys in memory ready for FUSE operations.

Output: Working auth flow from login through vault key decryption, with Keychain persistence for session resumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@.planning/phases/09-desktop-client/09-01-SUMMARY.md
@.planning/phases/09-desktop-client/09-02-SUMMARY.md
@.planning/phases/09-desktop-client/09-03-SUMMARY.md
@apps/api/src/auth/auth.controller.ts
@apps/api/src/auth/dto/login.dto.ts
@apps/web/src/stores/useAuthStore.ts
@apps/web/src/stores/useVaultStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement API client, Keychain auth, and app state</name>
  <files>
    apps/desktop/src-tauri/src/api/mod.rs
    apps/desktop/src-tauri/src/api/auth.rs
    apps/desktop/src-tauri/src/api/client.rs
    apps/desktop/src-tauri/src/api/types.rs
    apps/desktop/src-tauri/src/state.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    **api/client.rs** - Create `ApiClient` struct wrapping `reqwest::Client`:
    - Constructor takes `base_url: String` (e.g., "http://localhost:3000" for dev)
    - All requests include `X-Client-Type: desktop` header
    - `set_access_token(&self, token: String)` -- stores in Arc<RwLock<Option<String>>>
    - `authenticated_get(&self, path: &str) -> Result<Response>` -- includes Bearer token
    - `authenticated_post<T: Serialize>(&self, path: &str, body: &T) -> Result<Response>`
    - `post<T: Serialize>(&self, path: &str, body: &T) -> Result<Response>` -- unauthenticated
    - `get_bytes(&self, url: &str) -> Result<Vec<u8>>` -- for IPFS content fetching

    **api/types.rs** - Response/request types (Serde):
    - `LoginRequest { id_token: String }` (camelCase serialization: `idToken`)
    - `LoginResponse { access_token: String, refresh_token: String, is_new_user: bool }` (camelCase: `accessToken`, `refreshToken`, `isNewUser`)
    - `RefreshRequest { refresh_token: String }` (camelCase: `refreshToken`)
    - `RefreshResponse { access_token: String, refresh_token: String }`
    - `VaultResponse { encrypted_root_folder_key: String, root_ipns_name: String, tee_keys: Option<TeeKeysResponse> }` (camelCase)
    - `TeeKeysResponse { current_epoch: u32, current_public_key: String, previous_epoch: Option<u32>, previous_public_key: Option<String> }`
    - Use `#[serde(rename_all = "camelCase")]` on all structs.

    **api/auth.rs** - Keychain operations using `keyring` crate:
    - `const SERVICE_NAME: &str = "com.cipherbox.desktop";`
    - `store_refresh_token(user_id: &str, token: &str) -> Result<()>` -- `Entry::new(SERVICE_NAME, user_id).set_password(token)`
    - `get_refresh_token(user_id: &str) -> Result<Option<String>>` -- Returns None for `NoEntry` error
    - `delete_refresh_token(user_id: &str) -> Result<()>` -- Ignores `NoEntry` error (idempotent)
    - `store_user_id(user_id: &str) -> Result<()>` -- Store user ID separately so we know which Keychain entry to check on launch. Use `Entry::new(SERVICE_NAME, "last_user_id")`.
    - `get_last_user_id() -> Result<Option<String>>` -- Retrieve last user ID for silent refresh.

    **state.rs** - `AppState` struct (thread-safe):
    - `api: ApiClient`
    - `private_key: RwLock<Option<Vec<u8>>>` -- 32-byte secp256k1 private key (memory only)
    - `public_key: RwLock<Option<Vec<u8>>>` -- 65-byte uncompressed public key
    - `root_folder_key: RwLock<Option<Vec<u8>>>` -- 32-byte AES key
    - `root_ipns_name: RwLock<Option<String>>`
    - `user_id: RwLock<Option<String>>`
    - `tee_keys: RwLock<Option<TeeKeys>>` -- Current/previous TEE public keys
    - `is_authenticated: RwLock<bool>`
    - `mount_status: RwLock<MountStatus>` -- enum: Unmounted, Mounting, Mounted, Error(String)
    - Implement `clear_keys(&self)` -- zeros all sensitive data using zeroize pattern, sets is_authenticated to false.
    - Implement `AppState::new(api_base_url: &str) -> Self`.

    Register `AppState` with Tauri via `.manage(AppState::new(...))` in main.rs setup.

    **api/mod.rs** - Module declarations.

    Update **main.rs**:
    - Add `mod api;` and `mod state;` declarations.
    - In setup, create AppState with API base URL from env or default "http://localhost:3000".
    - Register AppState with `app.manage(app_state)`.
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes (existing crypto tests still work).
  </verify>
  <done>
    ApiClient, Keychain storage, and AppState compile and are registered with Tauri.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Tauri commands for auth flow with webview-based Web3Auth</name>
  <files>
    apps/desktop/src-tauri/src/commands.rs
    apps/desktop/src-tauri/src/main.rs
    apps/desktop/src/main.ts
    apps/desktop/src/auth.ts
  </files>
  <action>
    **IMPORTANT: Web3Auth runs INSIDE the Tauri webview, NOT in the system browser.** The CONTEXT.md originally mentioned system browser redirect, but this is revised for security: using the webview avoids passing the private key through URL parameters or deep links. The webview handles the full Web3Auth SDK flow internally (modal popup within the webview). After authentication, the webview passes the idToken and derived private key to the Rust side via Tauri IPC commands -- a secure in-process communication channel.

    **commands.rs** - Tauri IPC commands:

    1. `handle_auth_complete(state: State<AppState>, id_token: String, private_key: String) -> Result<(), String>`:
       - This is called FROM the webview AFTER Web3Auth completes inside the webview.
       - The webview has already run the Web3Auth SDK and has the idToken and private key.
       - POST `/auth/login` with `{ idToken }` and `X-Client-Type: desktop` header.
       - Receives `{ accessToken, refreshToken, isNewUser }`.
       - Store accessToken in ApiClient.
       - Extract user ID from JWT claims (decode the accessToken payload, read `sub` claim -- use base64 decode, no verification needed since server already verified).
       - Store refreshToken in Keychain via `auth::store_refresh_token(user_id, refresh_token)`.
       - Store user_id via `auth::store_user_id(user_id)`.
       - Convert private_key from hex to bytes, store in AppState.private_key.
       - Derive public key from private key, store in AppState.public_key.
       - Call `fetch_and_decrypt_vault(state)` (see below).
       - Set `state.is_authenticated` to true.

    2. `try_silent_refresh(state: State<AppState>) -> Result<bool, String>`:
       - Check `auth::get_last_user_id()` -- if None, return false (no stored session).
       - Get refresh token from Keychain: `auth::get_refresh_token(user_id)` -- if None, return false.
       - POST `/auth/refresh` with `{ refreshToken }` body and `X-Client-Type: desktop` header.
       - If success: Store new access token, store new refresh token in Keychain, fetch vault, return true.
       - If 401: Delete stale Keychain token, return false.
       - If network error: return false (user needs to try again).
       - NOTE: Silent refresh cannot restore the private key (it's not stored). The webview must re-run Web3Auth to get the private key. So silent refresh alone is NOT sufficient for full vault access -- it refreshes the API session, but the user still needs to complete Web3Auth login in the webview to get the private key. Adjust flow accordingly: silent refresh only works if private key is already in memory (e.g., token refresh during active session), not cold start.

    3. `logout(state: State<AppState>) -> Result<(), String>`:
       - POST `/auth/logout` with access token.
       - Delete refresh token from Keychain.
       - Call `state.clear_keys()` -- zeros all sensitive data.
       - (FUSE unmount will be added in plan 09-05)

    4. Helper `fetch_and_decrypt_vault(state: &AppState) -> Result<(), String>`:
       - GET `/vault/my-vault` (authenticated).
       - Deserialize `VaultResponse`.
       - Decode `encryptedRootFolderKey` from hex to bytes.
       - Use crypto::ecies::unwrap_key to decrypt rootFolderKey with privateKey.
       - Store rootFolderKey, rootIpnsName, teeKeys in AppState.

    Register all commands in main.rs: `tauri::generate_handler![commands::handle_auth_complete, commands::try_silent_refresh, commands::logout]`.

    **src/auth.ts** - Webview-side auth handling:
    - Import Web3Auth SDK (`@web3auth/modal` and related packages -- add to apps/desktop/package.json).
    - Initialize Web3Auth with the same configuration as the web app (reference `apps/web/src/stores/useAuthStore.ts` for config).
    - Provide `login()` function that:
      1. Initializes Web3Auth modal
      2. Calls `web3auth.connect()` to trigger the modal flow
      3. After successful auth, extracts idToken from `web3auth.authenticateUser()`
      4. Extracts private key from `web3auth.provider` (via `eth_private_key` RPC call, same as web app)
      5. Calls Tauri IPC: `invoke('handle_auth_complete', { idToken, privateKey: hexEncodedPrivateKey })`
    - Provide `logout()` function that calls `invoke('logout')` and `web3auth.logout()`.

    **src/main.ts** - Update entry point:
    - Import and initialize auth module.
    - On app start, invoke `try_silent_refresh`.
    - If silent refresh returns true AND private key is in memory: App is authenticated, emit ready event.
    - If silent refresh fails or no private key: Show login UI in webview (Web3Auth modal).
    - After auth completes: hide webview window (app transitions to headless menu bar mode).
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes.
    Verify commands are registered by checking main.rs invoke_handler.
    Verify Keychain operations compile (they require macOS runtime to actually test).
    Verify auth.ts imports Web3Auth SDK correctly.
  </verify>
  <done>
    Auth flow implemented: Web3Auth runs in webview, handle_auth_complete receives credentials via IPC, try_silent_refresh resumes sessions from Keychain, logout clears everything. Vault keys decrypted and stored in AppState.
  </done>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass
- Commands registered: handle_auth_complete, try_silent_refresh, logout
- ApiClient sends X-Client-Type: desktop header
- Keychain operations use "com.cipherbox.desktop" service name
- AppState holds keys in memory only (no disk persistence of sensitive data)
- clear_keys zeroes all sensitive buffers
- Web3Auth runs in Tauri webview (NOT system browser) -- private key stays in-process
- Private key passed to Rust via Tauri IPC invoke (secure in-process channel), NOT URL parameters
</verification>

<success_criteria>
Desktop auth flow compiles and is wired up: Web3Auth in webview, IPC credential passing, Keychain token storage, silent refresh, vault key decryption, and logout with key zeroing.
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-04-SUMMARY.md`
</output>
