---
phase: 09-desktop-client
plan: 04
type: execute
wave: 3
depends_on: ["09-01", "09-03"]
files_modified:
  - apps/desktop/src-tauri/src/fuse/mod.rs
  - apps/desktop/src-tauri/src/fuse/inode.rs
  - apps/desktop/src-tauri/src/fuse/operations.rs
  - apps/desktop/src-tauri/src/fuse/cache.rs
  - apps/desktop/src-tauri/src/api/ipfs.rs
  - apps/desktop/src-tauri/src/api/ipns.rs
  - apps/desktop/src-tauri/src/main.rs
autonomous: true

must_haves:
  truths:
    - "FUSE mount appears at ~/CipherVault after authentication"
    - "User can see folders and files in Finder (ls ~/CipherVault shows decrypted file names)"
    - "User can open files in native apps (e.g., open ~/CipherVault/file.txt opens in TextEdit)"
    - "File content is fetched from IPFS, decrypted in Rust, and returned to the kernel"
    - "Folder metadata is cached with 30s TTL and refreshed on next access after expiry"
  artifacts:
    - path: "apps/desktop/src-tauri/src/fuse/mod.rs"
      provides: "CipherVaultFS struct implementing fuser::Filesystem trait"
      exports: ["CipherVaultFS", "mount_filesystem", "unmount_filesystem"]
    - path: "apps/desktop/src-tauri/src/fuse/inode.rs"
      provides: "Inode table mapping inode numbers to folder/file metadata"
      exports: ["InodeTable", "InodeData"]
    - path: "apps/desktop/src-tauri/src/fuse/cache.rs"
      provides: "Memory cache for file content and folder metadata with TTL"
      exports: ["ContentCache", "MetadataCache"]
    - path: "apps/desktop/src-tauri/src/api/ipfs.rs"
      provides: "IPFS content fetch via backend API"
      exports: ["fetch_content", "upload_content"]
    - path: "apps/desktop/src-tauri/src/api/ipns.rs"
      provides: "IPNS resolve via backend API"
      exports: ["resolve_ipns"]
  key_links:
    - from: "apps/desktop/src-tauri/src/fuse/operations.rs"
      to: "apps/desktop/src-tauri/src/crypto/aes.rs"
      via: "unseal_aes_gcm for file decryption, decrypt_folder_metadata for readdir"
      pattern: "unseal_aes_gcm|decrypt_folder_metadata"
    - from: "apps/desktop/src-tauri/src/fuse/operations.rs"
      to: "apps/desktop/src-tauri/src/api/ipfs.rs"
      via: "fetch_content for uncached file reads"
      pattern: "fetch_content"
    - from: "apps/desktop/src-tauri/src/fuse/inode.rs"
      to: "apps/desktop/src-tauri/src/fuse/cache.rs"
      via: "metadata cache for folder children lookup"
      pattern: "MetadataCache"
---

<objective>
Implement the FUSE filesystem for read operations: mount at ~/CipherVault, list directories (readdir), get file attributes (getattr), open files, and read file content. All crypto happens in Rust using the module from plan 09-01.

Purpose: This is the core user experience -- seeing their encrypted vault as a native macOS folder. Users can browse folders in Finder, see decrypted file names, and open files in native apps. This plan covers the read path; write operations come in plan 09-05.

Output: A mountable FUSE filesystem that serves decrypted folder listings and file content from the CipherBox vault.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@.planning/phases/09-desktop-client/09-01-SUMMARY.md
@.planning/phases/09-desktop-client/09-03-SUMMARY.md
@packages/crypto/src/folder/index.ts
@packages/crypto/src/folder/metadata.ts
@packages/crypto/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement IPFS/IPNS API calls and inode table</name>
  <files>
    apps/desktop/src-tauri/src/api/ipfs.rs
    apps/desktop/src-tauri/src/api/ipns.rs
    apps/desktop/src-tauri/src/api/mod.rs
    apps/desktop/src-tauri/src/fuse/inode.rs
    apps/desktop/src-tauri/src/fuse/cache.rs
    apps/desktop/src-tauri/src/fuse/mod.rs
  </files>
  <action>
    **api/ipfs.rs** - IPFS operations via backend:
    - `fetch_content(client: &ApiClient, cid: &str) -> Result<Vec<u8>>` -- GET `/ipfs/{cid}` (or Pinata gateway URL directly). Returns raw encrypted bytes.
    - `upload_content(client: &ApiClient, data: &[u8]) -> Result<String>` -- POST `/ipfs/upload` with multipart form data. Returns CID string. (Used by write ops in plan 09-05, but define the function signature now.)

    **api/ipns.rs** - IPNS operations via backend:
    - `resolve_ipns(client: &ApiClient, ipns_name: &str) -> Result<IpnsResolveResponse>` -- GET `/ipns/resolve?ipnsName={name}`. Returns `{ cid, sequenceNumber }`.
    - `IpnsResolveResponse` struct with `cid: String` and `sequence_number: u64`.

    Update **api/mod.rs** to declare ipfs and ipns submodules.

    **fuse/inode.rs** - Inode table:
    - `InodeData` struct:
      - `ino: u64` -- inode number
      - `parent_ino: u64` -- parent inode
      - `name: String` -- decrypted name
      - `kind: InodeKind` -- enum: Root, Folder { ipns_name, encrypted_folder_key, folder_key (decrypted) }, File { cid, encrypted_file_key, iv, size }
      - `attr: FileAttr` -- fuser FileAttr (size, timestamps, permissions)
      - `children: Option<Vec<u64>>` -- child inode numbers (for directories)

    - `InodeTable` struct:
      - `inodes: HashMap<u64, InodeData>`
      - `name_to_ino: HashMap<(u64, String), u64>` -- (parent_ino, name) -> child_ino for lookup
      - `next_ino: AtomicU64` -- starts at 2 (1 is root)

    - Methods:
      - `new() -> Self` -- Create with root inode (ino=1, kind=Root)
      - `allocate_ino() -> u64` -- Atomic increment
      - `insert(&mut self, data: InodeData)` -- Add inode and update name_to_ino
      - `get(&self, ino: u64) -> Option<&InodeData>` -- Lookup by inode
      - `get_mut(&mut self, ino: u64) -> Option<&mut InodeData>` -- Mutable lookup
      - `find_child(&self, parent_ino: u64, name: &str) -> Option<u64>` -- Lookup by parent + name
      - `remove(&mut self, ino: u64)` -- Remove inode and clean up name_to_ino
      - `populate_folder(&mut self, parent_ino: u64, metadata: &FolderMetadata, folder_key: &[u8], private_key: &[u8])` -- Parse FolderMetadata children, create InodeData for each child, set parent's children list. Decrypt each child's folder_key (for subfolders) using the user's private key via unwrap_key. Store file sizes from metadata for getattr.

    - Inode number strategy: Use sequential allocation (start at 2). The inode table is rebuilt on mount from IPNS metadata. Stability across syncs is ensured by not re-assigning inodes during incremental updates (only add new, mark removed).

    **fuse/cache.rs** - Caching layer:
    - `MetadataCache` struct:
      - `entries: HashMap<String, CachedMetadata>` -- keyed by ipns_name
      - `CachedMetadata { metadata: FolderMetadata, fetched_at: Instant, cid: String }`
      - `get(&self, ipns_name: &str) -> Option<&FolderMetadata>` -- Returns None if TTL expired (30s)
      - `set(&mut self, ipns_name: &str, metadata: FolderMetadata, cid: String)`
      - `invalidate(&mut self, ipns_name: &str)` -- Remove entry
      - `METADATA_TTL: Duration = Duration::from_secs(30)`

    - `ContentCache` struct:
      - `entries: HashMap<String, CachedContent>` -- keyed by CID
      - `CachedContent { data: Vec<u8>, accessed_at: Instant, size: usize }`
      - `MAX_CACHE_SIZE: usize = 256 * 1024 * 1024` -- 256 MiB memory limit
      - `current_size: usize`
      - `get(&mut self, cid: &str) -> Option<&[u8]>` -- Updates accessed_at (LRU)
      - `set(&mut self, cid: &str, data: Vec<u8>)` -- Evicts LRU if over budget
      - `evict_lru(&mut self)` -- Remove least recently accessed entry until under budget

    **fuse/mod.rs** - Module declarations and `CipherVaultFS` struct skeleton:
    - `CipherVaultFS` struct with: inodes (InodeTable), metadata_cache (MetadataCache), content_cache (ContentCache), api (ApiClient clone), crypto keys from AppState, tokio runtime handle, next_fh (AtomicU64), open_files (HashMap).
    - `mount_filesystem(state: &AppState) -> Result<()>` -- Create CipherVaultFS, populate root folder from IPNS, call `fuser::mount2(fs, mount_point, options)` on a background thread.
    - `unmount_filesystem()` -- Call `fuser::unmount(mount_point)`.
    - Mount point: `dirs::home_dir().unwrap().join("CipherVault")`. Create directory if it doesn't exist.
    - Mount options: `MountOption::FSName("CipherBox".to_string())`, `MountOption::AllowOther` (if available), `MountOption::AutoUnmount`.

    IMPORTANT per RESEARCH.md pitfall 1: FUSE-T requires ALL readdir entries in a single response. Never paginate.
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes (crypto tests still pass, inode/cache logic has unit tests).
    Verify InodeTable can allocate inodes, insert, find_child.
    Verify MetadataCache returns None after TTL expiry.
    Verify ContentCache evicts when over budget.
  </verify>
  <done>
    IPFS/IPNS API clients, inode table, and caching layer compile. Unit tests for inode and cache logic pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FUSE read operations (Filesystem trait)</name>
  <files>
    apps/desktop/src-tauri/src/fuse/operations.rs
    apps/desktop/src-tauri/src/fuse/mod.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    **fuse/operations.rs** - Implement `fuser::Filesystem` trait for `CipherVaultFS`:

    All async operations use the pattern: spawn task on tokio runtime, complete the reply from the spawned task. NEVER block the FUSE thread with `.await` (pitfall 3 from RESEARCH.md).

    1. **`init(&mut self, ...)`**: Populate root folder. Resolve root IPNS name, fetch encrypted metadata from CID, decrypt with root_folder_key, populate inode table with root's children. This is the initial tree load.

    2. **`lookup(&mut self, _req, parent, name, reply)`**: Find child inode by (parent_ino, name). If found, reply.entry() with TTL=1s and child's FileAttr. If not found, reply.error(ENOENT). For folders, if children not yet loaded (lazy), trigger async metadata fetch.

    3. **`getattr(&mut self, _req, ino, _fh, reply)`**: Return cached FileAttr from inode table. For directories: permissions 0o755. For files: permissions 0o644. Size from metadata. Timestamps from metadata (createdAt, modifiedAt). If inode not found, reply.error(ENOENT).

    4. **`readdir(&mut self, _req, ino, _fh, offset, mut reply)`**: Return ALL directory entries in one pass (FUSE-T requirement). Build entries list:
       - offset 0: (ino, Directory, ".")
       - offset 1: (parent_ino, Directory, "..")
       - offset 2+: children from inode table
       Skip entries before `offset`. Call `reply.add(ino, next_offset, filetype, name)` for each. If `reply.add` returns true (buffer full), break. Call `reply.ok()`.

       If folder metadata is stale (TTL expired), trigger async refresh AFTER responding with cached data. This prevents Finder from hanging while IPNS resolves.

    5. **`open(&mut self, _req, ino, flags, reply)`**: Allocate a file handle (fh). If flags indicate read-only: allocate OpenFileHandle with no temp file. If write flags: will be handled in plan 09-05 (for now, reply.error(EACCES) for write opens). Reply with fh and flags 0 (direct_io not needed). DON'T pre-fetch content yet -- lazy fetch on read().

    6. **`read(&mut self, _req, ino, fh, offset, size, _flags, _lock, reply)`**:
       - Check content cache for the file's CID.
       - If hit: slice cached data at offset..offset+size, reply.data(&slice).
       - If miss: Spawn async task:
         a. Fetch encrypted bytes from IPFS via `api::ipfs::fetch_content(cid)`.
         b. Get file's encrypted_file_key and iv from inode data.
         c. Unwrap file key: `crypto::ecies::unwrap_key(encrypted_file_key, private_key)`.
         d. Decrypt file: `crypto::aes::decrypt_aes_gcm(encrypted_bytes, &file_key, &iv)`.
         e. Store decrypted content in content cache.
         f. Slice at offset..offset+size, reply.data(&slice).
         g. Zero the file_key from memory after use.
       - On any error: reply.error(EIO).

    7. **`release(&mut self, _req, ino, fh, _flags, _lock, _flush, reply)`**: Remove file handle from open_files map. reply.ok(). (Dirty file handling for writes comes in plan 09-05.)

    8. **`statfs(&mut self, _req, _ino, reply)`**: Return filesystem stats. Use 500 MiB as total blocks (matching quota). Report used blocks based on known total size.

    9. **`access(&mut self, _req, ino, mask, reply)`**: If inode exists, reply.ok(). If not, reply.error(ENOENT).

    **Lazy folder loading**: When lookup encounters a folder whose children haven't been loaded yet, trigger an async metadata fetch:
    - Resolve folder's IPNS name to CID.
    - Fetch encrypted metadata from CID.
    - Decrypt with folder's folder_key.
    - Populate inode table with children.
    - Cache metadata with 30s TTL.

    **fuse/mod.rs** updates:
    - Add `OpenFileHandle` struct: `ino: u64, flags: i32, cached_content: Option<Vec<u8>>` (content may be pre-fetched).
    - Wire up `mount_filesystem` to:
      1. Create `~/CipherVault` directory if missing.
      2. Build `CipherVaultFS` with all dependencies.
      3. Spawn `fuser::mount2` on a dedicated std::thread (not tokio -- fuser runs its own event loop).
      4. Return JoinHandle for the mount thread.
    - Wire `unmount_filesystem` to call `fuser::unmount_raw(mount_point)` or send signal to mount thread.

    **main.rs** updates:
    - Add `mod fuse;` declaration.
    - After successful auth (in commands.rs handle_auth_callback), call `mount_filesystem`.
    - In logout command, call `unmount_filesystem` before clearing keys.
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes.
    Verify all required Filesystem trait methods are implemented (lookup, getattr, readdir, open, read, release, statfs, access).
    Verify async patterns: no .await on FUSE thread, tasks spawned on tokio runtime.
    Verify readdir returns all entries in single pass (no pagination).
  </verify>
  <done>
    FUSE filesystem compiles with read operations. Mount/unmount functions available. Async IPFS fetch and Rust-native decryption wired together. Inode table populated from IPNS metadata.
  </done>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass
- CipherVaultFS implements: init, lookup, getattr, readdir, open, read, release, statfs, access
- Content cache has 256 MiB limit with LRU eviction
- Metadata cache has 30s TTL
- readdir returns ALL entries in single pass (FUSE-T compatibility)
- No .await calls on FUSE threads (async tasks spawned on tokio runtime)
- File decryption: fetch -> unwrap_key -> decrypt_aes_gcm -> cache -> reply
- mount_filesystem creates ~/CipherVault directory and mounts FUSE
</verification>

<success_criteria>
FUSE read operations compile and are wired to mount after auth. The filesystem can list directories (readdir), return file attributes (getattr), and read file content (fetch + decrypt from IPFS).
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-04-SUMMARY.md`
</output>
