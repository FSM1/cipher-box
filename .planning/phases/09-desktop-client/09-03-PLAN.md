---
phase: 09-desktop-client
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - apps/desktop/src-tauri/src/api/mod.rs
  - apps/desktop/src-tauri/src/api/auth.rs
  - apps/desktop/src-tauri/src/api/client.rs
  - apps/desktop/src-tauri/src/api/types.rs
  - apps/desktop/src-tauri/src/state.rs
  - apps/desktop/src-tauri/src/commands.rs
  - apps/desktop/src-tauri/src/main.rs
  - apps/desktop/src/main.ts
  - apps/desktop/src/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can log in via system browser Web3Auth redirect and receive tokens in the desktop app"
    - "Refresh token is stored in macOS Keychain via keyring crate"
    - "On app launch, silent refresh from Keychain token is attempted before showing login"
    - "After login, vault keys are fetched and decrypted in Rust (privateKey in memory only)"
    - "Logout clears Keychain token and zeroes keys from memory"
  artifacts:
    - path: "apps/desktop/src-tauri/src/api/auth.rs"
      provides: "Keychain storage and token management"
      exports: ["store_refresh_token", "get_refresh_token", "delete_refresh_token"]
    - path: "apps/desktop/src-tauri/src/api/client.rs"
      provides: "HTTP client with auth header injection and desktop client type header"
      exports: ["ApiClient"]
    - path: "apps/desktop/src-tauri/src/state.rs"
      provides: "App state holding keys in memory"
      exports: ["AppState"]
    - path: "apps/desktop/src-tauri/src/commands.rs"
      provides: "Tauri IPC commands for auth flow"
      exports: ["start_auth", "handle_auth_callback", "try_silent_refresh", "logout"]
  key_links:
    - from: "apps/desktop/src-tauri/src/api/client.rs"
      to: "apps/api/src/auth/auth.controller.ts"
      via: "X-Client-Type: desktop header on all requests"
      pattern: "X-Client-Type.*desktop"
    - from: "apps/desktop/src-tauri/src/api/auth.rs"
      to: "macOS Keychain"
      via: "keyring crate with apple-native feature"
      pattern: "keyring::Entry"
    - from: "apps/desktop/src-tauri/src/commands.rs"
      to: "apps/desktop/src/auth.ts"
      via: "Tauri invoke IPC"
      pattern: "invoke.*start_auth|invoke.*handle_auth_callback"
---

<objective>
Implement the desktop authentication flow: system browser redirect for Web3Auth login, deep link callback handling, Keychain storage for refresh tokens, silent refresh on app launch, and vault key decryption.

Purpose: Authentication is the gateway to all vault operations. After this plan, the app can authenticate, fetch vault keys, and hold decrypted keys in memory ready for FUSE operations.

Output: Working auth flow from login through vault key decryption, with Keychain persistence for session resumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@.planning/phases/09-desktop-client/09-01-SUMMARY.md
@.planning/phases/09-desktop-client/09-02-SUMMARY.md
@apps/api/src/auth/auth.controller.ts
@apps/api/src/auth/dto/login.dto.ts
@apps/web/src/stores/useAuthStore.ts
@apps/web/src/stores/useVaultStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement API client, Keychain auth, and app state</name>
  <files>
    apps/desktop/src-tauri/src/api/mod.rs
    apps/desktop/src-tauri/src/api/auth.rs
    apps/desktop/src-tauri/src/api/client.rs
    apps/desktop/src-tauri/src/api/types.rs
    apps/desktop/src-tauri/src/state.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    **api/client.rs** - Create `ApiClient` struct wrapping `reqwest::Client`:
    - Constructor takes `base_url: String` (e.g., "http://localhost:3000" for dev)
    - All requests include `X-Client-Type: desktop` header
    - `set_access_token(&self, token: String)` -- stores in Arc<RwLock<Option<String>>>
    - `authenticated_get(&self, path: &str) -> Result<Response>` -- includes Bearer token
    - `authenticated_post<T: Serialize>(&self, path: &str, body: &T) -> Result<Response>`
    - `post<T: Serialize>(&self, path: &str, body: &T) -> Result<Response>` -- unauthenticated
    - `get_bytes(&self, url: &str) -> Result<Vec<u8>>` -- for IPFS content fetching

    **api/types.rs** - Response/request types (Serde):
    - `LoginRequest { id_token: String }` (camelCase serialization: `idToken`)
    - `LoginResponse { access_token: String, refresh_token: String, is_new_user: bool }` (camelCase: `accessToken`, `refreshToken`, `isNewUser`)
    - `RefreshRequest { refresh_token: String }` (camelCase: `refreshToken`)
    - `RefreshResponse { access_token: String, refresh_token: String }`
    - `VaultResponse { encrypted_root_folder_key: String, root_ipns_name: String, tee_keys: Option<TeeKeysResponse> }` (camelCase)
    - `TeeKeysResponse { current_epoch: u32, current_public_key: String, previous_epoch: Option<u32>, previous_public_key: Option<String> }`
    - Use `#[serde(rename_all = "camelCase")]` on all structs.

    **api/auth.rs** - Keychain operations using `keyring` crate:
    - `const SERVICE_NAME: &str = "com.cipherbox.desktop";`
    - `store_refresh_token(user_id: &str, token: &str) -> Result<()>` -- `Entry::new(SERVICE_NAME, user_id).set_password(token)`
    - `get_refresh_token(user_id: &str) -> Result<Option<String>>` -- Returns None for `NoEntry` error
    - `delete_refresh_token(user_id: &str) -> Result<()>` -- Ignores `NoEntry` error (idempotent)
    - `store_user_id(user_id: &str) -> Result<()>` -- Store user ID separately so we know which Keychain entry to check on launch. Use `Entry::new(SERVICE_NAME, "last_user_id")`.
    - `get_last_user_id() -> Result<Option<String>>` -- Retrieve last user ID for silent refresh.

    **state.rs** - `AppState` struct (thread-safe):
    - `api: ApiClient`
    - `private_key: RwLock<Option<Vec<u8>>>` -- 32-byte secp256k1 private key (memory only)
    - `public_key: RwLock<Option<Vec<u8>>>` -- 65-byte uncompressed public key
    - `root_folder_key: RwLock<Option<Vec<u8>>>` -- 32-byte AES key
    - `root_ipns_name: RwLock<Option<String>>`
    - `user_id: RwLock<Option<String>>`
    - `tee_keys: RwLock<Option<TeeKeys>>` -- Current/previous TEE public keys
    - `is_authenticated: RwLock<bool>`
    - `mount_status: RwLock<MountStatus>` -- enum: Unmounted, Mounting, Mounted, Error(String)
    - Implement `clear_keys(&self)` -- zeros all sensitive data using zeroize pattern, sets is_authenticated to false.
    - Implement `AppState::new(api_base_url: &str) -> Self`.

    Register `AppState` with Tauri via `.manage(AppState::new(...))` in main.rs setup.

    **api/mod.rs** - Module declarations.

    Update **main.rs**:
    - Add `mod api;` and `mod state;` declarations.
    - In setup, create AppState with API base URL from env or default "http://localhost:3000".
    - Register AppState with `app.manage(app_state)`.
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes (existing crypto tests still work).
  </verify>
  <done>
    ApiClient, Keychain storage, and AppState compile and are registered with Tauri.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Tauri commands for auth flow and deep link handling</name>
  <files>
    apps/desktop/src-tauri/src/commands.rs
    apps/desktop/src-tauri/src/main.rs
    apps/desktop/src/main.ts
    apps/desktop/src/auth.ts
  </files>
  <action>
    **commands.rs** - Tauri IPC commands:

    1. `start_auth(app: AppHandle) -> Result<(), String>`:
       - Open system browser to Web3Auth login URL using tauri-plugin-shell's `app.shell().open(url, None)`.
       - For dev mode: Start a temporary HTTP server on localhost:19287/auth/callback as fallback (since deep links only work in bundled app). Use a oneshot channel to wait for the callback.
       - For production: Deep link `cipherbox://auth/callback` handles the return.
       - The Web3Auth redirect URL should be: `{WEB3AUTH_LOGIN_URL}?redirect_uri=cipherbox://auth/callback` (or localhost for dev).

    2. `handle_auth_callback(app: AppHandle, state: State<AppState>, id_token: String) -> Result<(), String>`:
       - POST `/auth/login` with `{ idToken }` and `X-Client-Type: desktop` header.
       - Receives `{ accessToken, refreshToken, isNewUser }`.
       - Store accessToken in ApiClient.
       - Extract user ID from JWT claims (decode the accessToken payload, read `sub` claim -- use base64 decode, no verification needed since server already verified).
       - Store refreshToken in Keychain via `auth::store_refresh_token(user_id, refresh_token)`.
       - Store user_id via `auth::store_user_id(user_id)`.
       - Call `fetch_and_decrypt_vault(state)` (see below).
       - Set `state.is_authenticated` to true.

    3. `try_silent_refresh(state: State<AppState>) -> Result<bool, String>`:
       - Check `auth::get_last_user_id()` -- if None, return false (no stored session).
       - Get refresh token from Keychain: `auth::get_refresh_token(user_id)` -- if None, return false.
       - POST `/auth/refresh` with `{ refreshToken }` body and `X-Client-Type: desktop` header.
       - If success: Store new access token, store new refresh token in Keychain, fetch vault, return true.
       - If 401: Delete stale Keychain token, return false.
       - If network error: return false (user needs to try again).

    4. `logout(state: State<AppState>) -> Result<(), String>`:
       - POST `/auth/logout` with access token.
       - Delete refresh token from Keychain.
       - Call `state.clear_keys()` -- zeros all sensitive data.
       - (FUSE unmount will be added in plan 09-04)

    5. Helper `fetch_and_decrypt_vault(state: &AppState) -> Result<(), String>`:
       - GET `/vault/my-vault` (authenticated).
       - Deserialize `VaultResponse`.
       - Decode `encryptedRootFolderKey` from hex to bytes.
       - Use crypto::ecies::unwrap_key to decrypt rootFolderKey with privateKey.
       - Store rootFolderKey, rootIpnsName, teeKeys in AppState.

    NOTE on privateKey: The Web3Auth flow returns the user's private key as part of the auth callback. This needs to be passed from the webview (where Web3Auth JS runs) to the Rust side. The `handle_auth_callback` command should accept `private_key: String` (hex-encoded) alongside `id_token`. The webview sends both after Web3Auth completes. Convert hex to bytes and store in AppState.private_key.

    Register all commands in main.rs: `tauri::generate_handler![commands::start_auth, commands::handle_auth_callback, commands::try_silent_refresh, commands::logout]`.

    Also in main.rs setup, register deep link handler:
    ```rust
    app.deep_link().on_open_url(|event| {
        // Parse cipherbox://auth/callback?token=...&private_key=...
        // Emit "auth-callback" event to webview with parsed params
    });
    ```

    **src/auth.ts** - Webview-side auth handling:
    - Listen for "auth-callback" Tauri event (from deep link handler).
    - On receiving callback, invoke `handle_auth_callback` Tauri command with id_token and private_key.
    - Export `startAuth()` function that invokes `start_auth` Tauri command.

    **src/main.ts** - Update entry point:
    - Import and initialize auth module.
    - On app start, invoke `try_silent_refresh`.
    - If silent refresh succeeds: App is authenticated, emit ready event.
    - If fails: show login prompt (for now, just log -- actual tray login button added in plan 09-05).
  </action>
  <verify>
    `cargo check` passes.
    `cargo test` passes.
    Verify commands are registered by checking main.rs invoke_handler.
    Verify Keychain operations compile (they require macOS runtime to actually test).
  </verify>
  <done>
    Auth flow implemented: start_auth opens browser, handle_auth_callback processes tokens, try_silent_refresh resumes sessions from Keychain, logout clears everything. Vault keys decrypted and stored in AppState.
  </done>
</task>

</tasks>

<verification>
- `cargo check` and `cargo test` pass
- Commands registered: start_auth, handle_auth_callback, try_silent_refresh, logout
- ApiClient sends X-Client-Type: desktop header
- Keychain operations use "com.cipherbox.desktop" service name
- AppState holds keys in memory only (no disk persistence of sensitive data)
- clear_keys zeroes all sensitive buffers
</verification>

<success_criteria>
Desktop auth flow compiles and is wired up: browser redirect, deep link callback, Keychain token storage, silent refresh, vault key decryption, and logout with key zeroing.
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-03-SUMMARY.md`
</output>
