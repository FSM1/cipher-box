---
phase: 09-desktop-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src-tauri/Cargo.toml
  - apps/desktop/src-tauri/src/main.rs
  - apps/desktop/src-tauri/src/crypto/mod.rs
  - apps/desktop/src-tauri/src/crypto/aes.rs
  - apps/desktop/src-tauri/src/crypto/ecies.rs
  - apps/desktop/src-tauri/src/crypto/ed25519.rs
  - apps/desktop/src-tauri/src/crypto/utils.rs
  - apps/desktop/src-tauri/src/crypto/folder.rs
  - apps/desktop/src-tauri/src/crypto/tests.rs
  - apps/desktop/src-tauri/tauri.conf.json
  - apps/desktop/src-tauri/capabilities/default.json
  - apps/desktop/src-tauri/build.rs
  - apps/desktop/package.json
  - apps/desktop/tsconfig.json
  - apps/desktop/src/main.ts
  - apps/desktop/index.html
autonomous: true

must_haves:
  truths:
    - "Tauri desktop app compiles and launches on macOS"
    - "Rust crypto module encrypts/decrypts data identically to @cipherbox/crypto TypeScript module"
    - "ECIES cross-language compatibility verified with test vectors from existing crypto tests"
    - "AES-256-GCM sealed format (IV || ciphertext || tag) matches TypeScript sealAesGcm output"
  artifacts:
    - path: "apps/desktop/src-tauri/Cargo.toml"
      provides: "Rust dependencies including tauri, fuser, keyring, reqwest, aes-gcm, ecies, ed25519-dalek, tokio"
    - path: "apps/desktop/src-tauri/src/crypto/mod.rs"
      provides: "Rust crypto module with AES-256-GCM, ECIES, Ed25519"
      exports: ["encrypt_aes_gcm", "decrypt_aes_gcm", "seal_aes_gcm", "unseal_aes_gcm", "wrap_key", "unwrap_key"]
    - path: "apps/desktop/src-tauri/tauri.conf.json"
      provides: "Tauri configuration with tray-icon, deep-link, no default window"
    - path: "apps/desktop/package.json"
      provides: "Desktop app package in pnpm workspace"
  key_links:
    - from: "apps/desktop/src-tauri/src/crypto/aes.rs"
      to: "packages/crypto/src/aes/seal.ts"
      via: "identical sealed format: IV(12) || ciphertext || tag(16)"
      pattern: "AES_IV_SIZE.*12|AES_TAG_SIZE.*16"
    - from: "apps/desktop/src-tauri/src/crypto/ecies.rs"
      to: "packages/crypto/src/ecies/encrypt.ts"
      via: "eciesjs-compatible ECIES format"
      pattern: "ecies::encrypt|ecies::decrypt"
---

<objective>
Scaffold the Tauri v2 desktop app within the monorepo and implement the Rust-native crypto module that produces byte-identical output to the existing @cipherbox/crypto TypeScript module.

Purpose: Establish the foundation for all desktop work. The Rust crypto module eliminates the webview IPC bottleneck -- FUSE operations will call Rust crypto directly without round-tripping through JavaScript. Cross-language format compatibility is critical: files encrypted by the web app must decrypt in the desktop app and vice versa.

Output: A compilable Tauri app with a Rust crypto module verified against TypeScript test vectors.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-desktop-client/09-CONTEXT.md
@.planning/phases/09-desktop-client/09-RESEARCH.md
@packages/crypto/src/index.ts
@packages/crypto/src/constants.ts
@packages/crypto/src/types.ts
@packages/crypto/src/aes/encrypt.ts
@packages/crypto/src/aes/seal.ts
@packages/crypto/src/ecies/encrypt.ts
@packages/crypto/src/ecies/decrypt.ts
@packages/crypto/src/__tests__/aes.test.ts
@packages/crypto/src/__tests__/ecies.test.ts
@packages/crypto/src/__tests__/ed25519.test.ts
@pnpm-workspace.yaml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Tauri v2 app in monorepo</name>
  <files>
    apps/desktop/package.json
    apps/desktop/tsconfig.json
    apps/desktop/src/main.ts
    apps/desktop/index.html
    apps/desktop/src-tauri/Cargo.toml
    apps/desktop/src-tauri/tauri.conf.json
    apps/desktop/src-tauri/capabilities/default.json
    apps/desktop/src-tauri/build.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    Create the `apps/desktop` directory as a new pnpm workspace member. The existing `pnpm-workspace.yaml` already has `apps/*` so it will be auto-included.

    **package.json**: Create with name `@cipherbox/desktop`, type `module`, scripts for `tauri dev` and `tauri build`. Dependencies: `@tauri-apps/api` ^2, `@tauri-apps/cli` ^2 (devDep), `@tauri-apps/plugin-deep-link` ^2, `@tauri-apps/plugin-shell` ^2.

    **tsconfig.json**: Extend from `@cipherbox/tsconfig/base.json` (the shared config). Target ESNext, module ESNext, moduleResolution bundler.

    **index.html**: Minimal HTML shell for Tauri webview. Single div with id="app". Script tag pointing to `src/main.ts`. This webview is only used for initial Web3Auth login -- most work happens in Rust.

    **src/main.ts**: Minimal entry point. Import `@tauri-apps/api`. Log "CipherBox Desktop ready". This will be expanded in plan 09-03 for auth flow.

    **Cargo.toml**: Create with these dependencies:
    ```toml
    [package]
    name = "cipherbox-desktop"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    tauri = { version = "2", features = ["tray-icon"] }
    tauri-plugin-deep-link = "2"
    tauri-plugin-autostart = "2"
    tauri-plugin-shell = "2"
    tauri-plugin-notification = "2"
    fuser = { version = "0.16", default-features = false }
    keyring = { version = "3", features = ["apple-native"] }
    reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
    tokio = { version = "1", features = ["full"] }
    serde = { version = "1", features = ["derive"] }
    serde_json = "1"
    aes-gcm = "0.10"
    ecies = { version = "0.2", default-features = false, features = ["pure"] }
    ed25519-dalek = { version = "2", features = ["rand_core"] }
    rand = "0.8"
    hex = "0.4"
    base64 = "0.22"
    dirs = "5"
    log = "0.4"
    env_logger = "0.11"
    libc = "0.2"
    thiserror = "2"

    [build-dependencies]
    tauri-build = { version = "2", features = [] }
    ```

    **tauri.conf.json**: Configure with:
    - `identifier`: "com.cipherbox.desktop"
    - `app.windows`: [] (empty -- no default window, menu bar only)
    - `plugins.deep-link.desktop.schemes`: ["cipherbox"]
    - `bundle.identifier`: "com.cipherbox.desktop"
    - `bundle.macOS.entitlements`: null (will add signing later)
    - `app.security.dangerousDisableAssetCspModification`: true (needed for Web3Auth redirect)
    - `build.devUrl`: "http://localhost:1420" (Tauri default for Vite)
    - `build.frontendDist`: "../dist"
    - `build.beforeDevCommand`: "" (empty, no frontend dev server needed since webview is minimal)
    - `build.beforeBuildCommand`: "" (empty)

    **capabilities/default.json**: Grant permissions for deep-link, shell open-url, notification, autostart.

    **build.rs**: Standard Tauri build script: `tauri_build::build()`.

    **main.rs**: Minimal Tauri app that compiles and runs:
    - Register plugins: deep-link, autostart (MacosLauncher::LaunchAgent), shell, notification
    - In setup: set ActivationPolicy::Accessory (hide dock icon)
    - Register empty invoke_handler (commands added in later plans)
    - No window creation -- app starts headless
    - Print log message "CipherBox Desktop starting..."

    Do NOT add FUSE mounting, tray icon, or auth -- those come in later plans. This task is scaffold only.
  </action>
  <verify>
    Run `cd apps/desktop && pnpm install` to verify workspace resolution.
    Run `cd apps/desktop/src-tauri && cargo check` to verify Rust compilation (may take a few minutes for first build).
    Verify `tauri.conf.json` is valid JSON.
    Verify the app is included in pnpm workspace by running `pnpm ls --filter @cipherbox/desktop`.
  </verify>
  <done>
    `cargo check` passes without errors. Package visible in pnpm workspace. Tauri conf valid.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Rust-native crypto module with cross-language test vectors</name>
  <files>
    apps/desktop/src-tauri/src/crypto/mod.rs
    apps/desktop/src-tauri/src/crypto/aes.rs
    apps/desktop/src-tauri/src/crypto/ecies.rs
    apps/desktop/src-tauri/src/crypto/ed25519.rs
    apps/desktop/src-tauri/src/crypto/utils.rs
    apps/desktop/src-tauri/src/crypto/folder.rs
    apps/desktop/src-tauri/src/crypto/tests.rs
    apps/desktop/src-tauri/src/main.rs
  </files>
  <action>
    Create the Rust crypto module that mirrors `@cipherbox/crypto` operations. This is the highest-value task in the entire phase because every FUSE operation depends on it.

    **crypto/mod.rs**: Module declarations, re-exports of public functions.

    **crypto/aes.rs**: Implement AES-256-GCM operations using the `aes-gcm` crate:
    - `encrypt_aes_gcm(plaintext: &[u8], key: &[u8; 32], iv: &[u8; 12]) -> Result<Vec<u8>>` -- Returns ciphertext with 16-byte auth tag appended (same as Web Crypto API)
    - `decrypt_aes_gcm(ciphertext: &[u8], key: &[u8; 32], iv: &[u8; 12]) -> Result<Vec<u8>>` -- Expects ciphertext with tag appended
    - `seal_aes_gcm(plaintext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>>` -- Generate random IV, encrypt, return IV(12) || ciphertext || tag(16). This MUST match the TypeScript `sealAesGcm` format exactly.
    - `unseal_aes_gcm(sealed: &[u8], key: &[u8; 32]) -> Result<Vec<u8>>` -- Extract IV from first 12 bytes, decrypt remainder.
    - Constants: `AES_KEY_SIZE = 32`, `AES_IV_SIZE = 12`, `AES_TAG_SIZE = 16`.

    **crypto/ecies.rs**: Implement ECIES using the `ecies` crate:
    - `wrap_key(data: &[u8], recipient_public_key: &[u8]) -> Result<Vec<u8>>` -- ECIES encrypt. The `ecies` Rust crate and `eciesjs` npm package are from the same author (ecies/rs and ecies/js). They use the same format: ephemeral_pubkey(65) || nonce(16) || tag(16) || ciphertext. Verify this with test vectors.
    - `unwrap_key(wrapped: &[u8], private_key: &[u8]) -> Result<Vec<u8>>` -- ECIES decrypt.
    - Validate public key: 65 bytes, 0x04 prefix (uncompressed secp256k1).
    - Validate private key: 32 bytes.

    CRITICAL: The `ecies` Rust crate MUST produce output that `eciesjs` TypeScript can decrypt, and vice versa. The cross-language test vectors in Task 2 verification will confirm this. If the `ecies` crate uses a different format, fall back to manual ECDH + HKDF + AES-GCM construction matching eciesjs exactly.

    **crypto/ed25519.rs**: Implement Ed25519 using `ed25519-dalek`:
    - `generate_ed25519_keypair() -> (Vec<u8>, Vec<u8>)` -- Returns (public_key_32bytes, private_key_32bytes).
    - `sign_ed25519(message: &[u8], private_key: &[u8]) -> Result<Vec<u8>>` -- Returns 64-byte signature.
    - `verify_ed25519(message: &[u8], signature: &[u8], public_key: &[u8]) -> bool` -- Returns bool, no exceptions.

    **crypto/utils.rs**: Utility functions:
    - `generate_random_bytes(len: usize) -> Vec<u8>` -- Using `rand::rngs::OsRng`.
    - `generate_file_key() -> [u8; 32]` -- Random 32-byte AES key.
    - `generate_iv() -> [u8; 12]` -- Random 12-byte IV.
    - `hex_to_bytes(hex: &str) -> Result<Vec<u8>>` and `bytes_to_hex(bytes: &[u8]) -> String`.
    - `clear_bytes(buf: &mut [u8])` -- Zeroize sensitive data. Use `zeroize` crate or manual zeroing.

    **crypto/folder.rs**: Folder metadata types:
    - `FolderMetadata` struct with `children: Vec<FolderChild>` matching the TypeScript `FolderMetadata` type.
    - `FolderChild` enum: `File(FileEntry)` or `Folder(FolderEntry)`.
    - `FileEntry` struct: `id: String, name: String, cid: String, encrypted_file_key: Vec<u8>, iv: Vec<u8>, size: u64, created_at: u64, modified_at: u64`.
    - `FolderEntry` struct: `id: String, name: String, ipns_name: String, encrypted_folder_key: Vec<u8>, created_at: u64, modified_at: u64`.
    - `encrypt_folder_metadata(metadata: &FolderMetadata, folder_key: &[u8; 32]) -> Result<Vec<u8>>` -- JSON serialize then sealAesGcm.
    - `decrypt_folder_metadata(sealed: &[u8], folder_key: &[u8; 32]) -> Result<FolderMetadata>` -- unsealAesGcm then JSON deserialize.
    - Serde derives for JSON serialization using camelCase field names (matching TypeScript).

    **crypto/tests.rs**: Cross-language test vectors:
    - AES-256-GCM: Use a fixed key and IV, encrypt known plaintext "Hello, CipherBox!" in BOTH TypeScript and Rust, assert byte-identical ciphertext. Include the raw ciphertext bytes as a constant in the Rust test (pre-computed from the TypeScript module).
    - seal/unseal: Given a sealed blob from TypeScript sealAesGcm, verify Rust unseal_aes_gcm decrypts correctly.
    - ECIES: wrap_key with a known keypair in TypeScript, verify unwrap_key in Rust decrypts to the same plaintext. Also test Rust wrap -> TypeScript unwrap direction by including a Rust-encrypted test vector.
    - Ed25519: Sign same message with same private key in both, verify signatures are deterministic and identical.

    Add `#[cfg(test)] mod tests;` to crypto/mod.rs.

    Update **main.rs** to add `mod crypto;` declaration.

    Note: Add `zeroize = "1"` to Cargo.toml if not already included for secure memory clearing.
  </action>
  <verify>
    Run `cd apps/desktop/src-tauri && cargo test` -- all crypto tests pass.
    Run `cd apps/desktop/src-tauri && cargo check` -- no compilation errors.
    Verify AES seal/unseal round-trip works.
    Verify ECIES wrap/unwrap round-trip works.
    Verify Ed25519 sign/verify round-trip works.
  </verify>
  <done>
    All `cargo test` crypto tests pass. AES, ECIES, and Ed25519 operations produce correct output. Cross-language test vectors (pre-computed from TypeScript) verify format compatibility.
  </done>
</task>

</tasks>

<verification>
- `cargo check` succeeds for the Tauri app
- `cargo test` passes all crypto tests
- The desktop app package is visible in `pnpm ls -r`
- tauri.conf.json has no default windows, has deep-link scheme "cipherbox", identifier "com.cipherbox.desktop"
- Crypto constants match TypeScript: AES_KEY_SIZE=32, AES_IV_SIZE=12, AES_TAG_SIZE=16, SECP256K1_PUBLIC_KEY_SIZE=65
</verification>

<success_criteria>
Tauri app compiles. Rust crypto module passes all tests including cross-language format verification. Desktop app is a proper pnpm workspace member.
</success_criteria>

<output>
After completion, create `.planning/phases/09-desktop-client/09-01-SUMMARY.md`
</output>
