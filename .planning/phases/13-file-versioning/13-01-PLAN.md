---
phase: 13-file-versioning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/crypto/src/file/types.ts
  - packages/crypto/src/file/metadata.ts
  - packages/crypto/src/index.ts
  - apps/desktop/src-tauri/src/crypto/folder.rs
autonomous: true

must_haves:
  truths:
    - 'FileMetadata type includes optional versions array with VersionEntry items'
    - 'VersionEntry stores cid, fileKeyEncrypted, fileIv, size, timestamp, and encryptionMode'
    - 'Validator accepts FileMetadata with and without versions array (backward compat)'
    - 'Rust FileMetadata struct includes optional versions field matching TS type'
  artifacts:
    - path: 'packages/crypto/src/file/types.ts'
      provides: 'VersionEntry type and updated FileMetadata with versions field'
      contains: 'VersionEntry'
    - path: 'packages/crypto/src/file/metadata.ts'
      provides: 'Updated validator accepting versions array'
      contains: 'versions'
    - path: 'apps/desktop/src-tauri/src/crypto/folder.rs'
      provides: 'Rust VersionEntry struct and updated FileMetadata'
      contains: 'VersionEntry'
  key_links:
    - from: 'packages/crypto/src/file/types.ts'
      to: 'packages/crypto/src/file/metadata.ts'
      via: 'VersionEntry import in validator'
      pattern: 'VersionEntry'
    - from: 'packages/crypto/src/file/types.ts'
      to: 'packages/crypto/src/index.ts'
      via: 're-export of VersionEntry'
      pattern: 'VersionEntry'
---

<objective>
Add version entry types to the crypto package (TypeScript and Rust) so that FileMetadata can store a history of previous file versions.

Purpose: This is the foundational type change that all versioning logic depends on. The versions array in FileMetadata is the data structure that makes file versioning possible -- each entry captures the full crypto context needed to decrypt a past version independently.

Output: Updated FileMetadata types in both TypeScript and Rust with VersionEntry support, backward-compatible validator that accepts metadata with or without versions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-file-versioning/13-CONTEXT.md
@packages/crypto/src/file/types.ts
@packages/crypto/src/file/metadata.ts
@packages/crypto/src/index.ts
@apps/desktop/src-tauri/src/crypto/folder.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add VersionEntry type and update FileMetadata in TypeScript crypto</name>
  <files>
    packages/crypto/src/file/types.ts
    packages/crypto/src/file/metadata.ts
    packages/crypto/src/file/index.ts
    packages/crypto/src/index.ts
  </files>
  <action>
    In `packages/crypto/src/file/types.ts`:

    1. Add a new `VersionEntry` type BEFORE the FileMetadata type:
       ```typescript
       /** A single past version of a file. Stores full crypto context for independent decryption. */
       export type VersionEntry = {
         /** IPFS CID of the encrypted file content for this version */
         cid: string;
         /** Hex-encoded ECIES-wrapped AES-256 key for decrypting this version */
         fileKeyEncrypted: string;
         /** Hex-encoded IV used for this version's encryption */
         fileIv: string;
         /** Original file size in bytes (before encryption) */
         size: number;
         /** When this version was created (Unix ms) -- i.e., when it became a "past" version */
         timestamp: number;
         /** Encryption mode used for this version */
         encryptionMode: 'GCM' | 'CTR';
       };
       ```

    2. Add an optional `versions` field to the `FileMetadata` type:
       ```typescript
       /** Past versions of this file (newest first). Omitted if no versions exist. */
       versions?: VersionEntry[];
       ```

    In `packages/crypto/src/file/metadata.ts`:

    3. Import `VersionEntry` alongside `FileMetadata` and `EncryptedFileMetadata` from `./types`.

    4. Add a `validateVersionEntry` helper function that validates a single version entry:
       - `cid` must be string
       - `fileKeyEncrypted` must be string
       - `fileIv` must be string
       - `size` must be number
       - `timestamp` must be number
       - `encryptionMode` must be 'GCM' or 'CTR' (required, not optional like in FileMetadata -- versions always have explicit mode)
       - Return a typed `VersionEntry`

    5. Update `validateFileMetadata` to validate the optional `versions` array:
       - If `obj.versions` is `undefined` or not present, skip (backward compat)
       - If present, it must be an array
       - Each element must pass `validateVersionEntry`
       - Include validated versions in the return object (only if present/non-empty)

    In `packages/crypto/src/file/index.ts`:

    6. Add `VersionEntry` to the type exports: `export type { FileMetadata, FilePointer, EncryptedFileMetadata, VersionEntry } from './types';`

    In `packages/crypto/src/index.ts`:

    7. Add `VersionEntry` to the per-file IPNS metadata type exports alongside FileMetadata, FilePointer, etc.

  </action>
  <verify>
    Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto build` -- should compile without errors.
    Run `cd /Users/michael/Code/cipher-box && pnpm --filter @cipherbox/crypto test` -- existing tests should pass (backward compat).
  </verify>
  <done>
    VersionEntry type exported from @cipherbox/crypto. FileMetadata accepts optional versions array. Validator handles both versioned and non-versioned metadata. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add VersionEntry to Rust crypto and update FileMetadata struct</name>
  <files>
    apps/desktop/src-tauri/src/crypto/folder.rs
  </files>
  <action>
    In `apps/desktop/src-tauri/src/crypto/folder.rs`:

    1. Add a `VersionEntry` struct right before the `FileMetadata` struct:
       ```rust
       /// A single past version of a file.
       #[derive(Debug, Clone, Serialize, Deserialize)]
       pub struct VersionEntry {
           /// IPFS CID of the encrypted file content for this version.
           pub cid: String,
           /// Hex-encoded ECIES-wrapped AES-256 key for decrypting this version.
           pub file_key_encrypted: String,
           /// Hex-encoded IV used for this version's encryption.
           pub file_iv: String,
           /// Original file size in bytes (before encryption).
           pub size: u64,
           /// When this version was created (Unix ms).
           pub timestamp: u64,
           /// Encryption mode used for this version.
           pub encryption_mode: String,
       }
       ```

    2. Add an optional `versions` field to the `FileMetadata` struct:
       ```rust
       /// Past versions of this file (newest first). None if no versions exist.
       #[serde(skip_serializing_if = "Option::is_none")]
       #[serde(default)]
       pub versions: Option<Vec<VersionEntry>>,
       ```

    The `#[serde(default)]` ensures backward compatibility when deserializing metadata that doesn't have a versions field (pre-Phase 13 data). The `#[serde(skip_serializing_if = "Option::is_none")]` avoids writing `"versions": null` to JSON when there are no versions.

    3. Update the `FileMetadata` construction in `operations.rs` release() (around line 1544) to include `versions: None` when building FileMetadata for new files/updates. Search for `crate::crypto::folder::FileMetadata {` and add `versions: None,` field.

  </action>
  <verify>
    Run `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo check --features fuse` -- should compile without errors.
    Run `cd /Users/michael/Code/cipher-box/apps/desktop/src-tauri && cargo test` -- existing tests should pass.
  </verify>
  <done>
    Rust VersionEntry struct exists. FileMetadata has optional versions field with serde backward compat. Desktop compiles and tests pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @cipherbox/crypto build` succeeds
- `pnpm --filter @cipherbox/crypto test` passes (all existing tests)
- `cargo check --features fuse` succeeds in desktop
- `cargo test` passes in desktop
- VersionEntry is importable from `@cipherbox/crypto` in TypeScript
- FileMetadata with and without `versions` field can be serialized/deserialized in both TS and Rust
</verification>

<success_criteria>

- VersionEntry type exists in both TypeScript and Rust with matching fields
- FileMetadata includes optional versions array in both languages
- Validator accepts metadata with versions, without versions, and with empty versions array
- All existing tests pass (backward compatibility preserved)
- No breaking changes to existing code
  </success_criteria>

<output>
After completion, create `.planning/phases/13-file-versioning/13-01-SUMMARY.md`
</output>
